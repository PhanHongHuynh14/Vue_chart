import {
  Animation,
  Button,
  Circle,
  Color,
  ColorSet,
  Component,
  Cone,
  Container,
  DataItem,
  DesaturateFilter,
  InterfaceColorSet,
  Label,
  Line,
  LinearGradient,
  LinearGradientModifier,
  List,
  ListDisposer,
  ListTemplate,
  MonotoneX,
  MonotoneY,
  MouseCursorStyle,
  OrderedListTemplate,
  Polyline,
  Polyspline,
  Rectangle,
  Rectangle3D,
  ResponsiveBreakpoints,
  RoundedRectangle,
  Scrollbar,
  Slice,
  Slice3D,
  SortedListTemplate,
  Sprite,
  Tension,
  TextLink,
  Tooltip,
  Trapezoid,
  Triangle,
  WavedCircle,
  WavedLine,
  WavedRectangle,
  ZoomOutButton,
  add,
  arc,
  arcTo,
  blur,
  capitalize,
  checkChange,
  closePath,
  color,
  copy,
  copyProperties as copyProperties2,
  cubicIn,
  decimalPlaces,
  defaultRules,
  documentPointToSprite,
  documentPointToSvg,
  getDuration,
  getInteraction,
  getNextUnit,
  interpolate,
  isIE,
  keyboard,
  lineTo,
  moveTo,
  options,
  order as order2,
  plainText,
  polyline,
  quadraticCurveTo,
  rectToPath,
  rectangle,
  relativeRadiusToValue,
  relativeToValue,
  reverse,
  round as round2,
  setTimezone,
  sinOut,
  spritePointToDocument,
  spritePointToSprite,
  spritePointToSvg,
  spriteRectToSvg,
  svgPointToDocument,
  svgPointToSprite,
  system,
  toColor,
  used,
  visualProperties
} from "./chunk-HJIF4676.js";
import {
  DEGREES,
  Dictionary,
  DictionaryDisposer,
  DictionaryTemplate,
  Disposer,
  ListIterator,
  MultiDisposer,
  MutableValueDisposer,
  Percent,
  ceil,
  closest,
  contains,
  copyProperties,
  cos,
  each,
  each2,
  each3,
  eachContinue,
  eachContinue3 as eachContinue2,
  find,
  fitAngleToRange,
  fitToRange,
  forceCopyProperties,
  getAngle,
  getArcRect,
  getCommonRectangle,
  getDistance,
  getHorizontalDistance,
  getPointOnQuadraticCurve,
  getVerticalDistance,
  hasValue,
  indexed,
  intersect,
  intersection,
  invertRange,
  isArray,
  isInRectangle,
  isNaN,
  isNumber,
  isObject,
  isString,
  length,
  max,
  min,
  move,
  normalizeAngle,
  order,
  percent,
  registry,
  remove,
  round,
  sin,
  sort,
  tan,
  toArray2 as toArray,
  toBoolean,
  toNumber
} from "./chunk-G3NKYBZD.js";
import {
  __assign,
  __extends,
  __read,
  __spread,
  __values
} from "./chunk-GHANC6LZ.js";
import "./chunk-UV5CTPV7.js";

// node_modules/@amcharts/amcharts4/.internal/core/elements/Grip.js
var Grip = (
  /** @class */
  function(_super) {
    __extends(Grip2, _super);
    function Grip2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "Grip";
      var cs = new InterfaceColorSet();
      _this.layout = "absolute";
      _this.padding(10, 10, 10, 10);
      _this.margin(3, 3, 3, 3);
      _this.background.fillOpacity = 0.3;
      _this.background.cornerRadius(10, 10, 10, 10);
      var icon = new Sprite();
      icon.element = _this.paper.add("path");
      var path = moveTo({ x: -6, y: 0 });
      path += lineTo({ x: 6, y: 0 });
      path += moveTo({ x: -8, y: -6 });
      path += lineTo({ x: 0, y: -12 });
      path += lineTo({ x: 8, y: -6 });
      path += moveTo({ x: -8, y: 6 });
      path += lineTo({ x: 0, y: 12 });
      path += lineTo({ x: 8, y: 6 });
      icon.path = path;
      icon.strokeWidth = 2;
      icon.fillOpacity = 0;
      icon.pixelPerfect = true;
      icon.padding(0, 4, 0, 4);
      icon.stroke = cs.getFor("text");
      icon.strokeOpacity = 0.7;
      icon.align = "center";
      icon.valign = "middle";
      _this.icon = icon;
      _this.label.dispose();
      _this.label = void 0;
      _this.position = "right";
      _this.autoHideDelay = 3e3;
      _this.events.on("shown", function(ev) {
        if (_this._autoHideTimeout) {
          _this._autoHideTimeout.dispose();
        }
        if (_this.autoHideDelay) {
          _this._autoHideTimeout = _this.setTimeout(function() {
            _this.hide();
          }, _this.autoHideDelay);
        }
      });
      _this.events.on("down", function(ev) {
        if (_this._autoHideTimeout) {
          _this._autoHideTimeout.dispose();
        }
      });
      _this.events.on("out", function(ev) {
        if (_this.autoHideDelay) {
          _this._autoHideTimeout = _this.setTimeout(function() {
            _this.hide();
          }, _this.autoHideDelay);
        }
      });
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(Grip2.prototype, "position", {
      /**
       * @return Position
       */
      get: function() {
        return this.getPropertyValue("position");
      },
      /**
       * Sets position of the grip.
       *
       * Available options: "left", "right" (default), "top", "bottom".
       *
       * @param  value  Position
       */
      set: function(value) {
        if (this.setPropertyValue("position", value)) {
          switch (value) {
            case "left":
              this.align = "left";
              this.valign = "middle";
              this.horizontalCenter = "left";
              this.verticalCenter = "middle";
              this.icon.rotation = 0;
              this.width = void 0;
              this.height = percent(30);
              break;
            case "right":
              this.align = "right";
              this.valign = "middle";
              this.horizontalCenter = "right";
              this.verticalCenter = "middle";
              this.icon.rotation = 0;
              this.width = void 0;
              this.height = percent(30);
              break;
            case "top":
              this.align = "center";
              this.valign = "top";
              this.horizontalCenter = "middle";
              this.verticalCenter = "top";
              this.icon.rotation = 90;
              this.width = percent(30);
              this.height = void 0;
              break;
            case "bottom":
              this.align = "center";
              this.valign = "bottom";
              this.horizontalCenter = "middle";
              this.verticalCenter = "bottom";
              this.icon.rotation = 90;
              this.width = percent(30);
              this.height = void 0;
              break;
            default:
              this.align = "center";
              this.valign = "middle";
              this.horizontalCenter = "middle";
              this.verticalCenter = "middle";
              this.icon.rotation = 90;
              this.width = percent(30);
              this.height = void 0;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Grip2.prototype, "autoHideDelay", {
      /**
       * @return Delay
       */
      get: function() {
        return this.getPropertyValue("autoHideDelay");
      },
      /**
       * Number of milliseconds to show grip until it is hidden automatically.
       *
       * @default 3000
       * @param  value  Delay
       */
      set: function(value) {
        this.setPropertyValue("autoHideDelay", value);
      },
      enumerable: true,
      configurable: true
    });
    return Grip2;
  }(Button)
);
registry.registeredClasses["Grip"] = Grip;

// node_modules/@amcharts/amcharts4/.internal/charts/Chart.js
var ChartDataItem = (
  /** @class */
  function(_super) {
    __extends(ChartDataItem2, _super);
    function ChartDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "ChartDataItem";
      _this.applyTheme();
      return _this;
    }
    return ChartDataItem2;
  }(DataItem)
);
var Chart = (
  /** @class */
  function(_super) {
    __extends(Chart2, _super);
    function Chart2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._legend = new MutableValueDisposer();
      if (_this.constructor === Chart2) {
        throw new Error("'Chart' cannot be instantiated directly. Please use a specific chart type.");
      }
      _this.className = "Chart";
      var template = new Label();
      _this.titles = new ListTemplate(template);
      _this._disposers.push(new ListDisposer(_this.titles));
      _this._disposers.push(template);
      _this.width = percent(100);
      _this.height = percent(100);
      _this.layout = "vertical";
      var chartAndLegendContainer = _this.createChild(Container);
      chartAndLegendContainer.shouldClone = false;
      chartAndLegendContainer.layout = "vertical";
      chartAndLegendContainer.width = percent(100);
      chartAndLegendContainer.height = percent(100);
      _this.chartAndLegendContainer = chartAndLegendContainer;
      var chartContainer = chartAndLegendContainer.createChild(Container);
      chartContainer.shouldClone = false;
      chartContainer.width = percent(100);
      chartContainer.height = percent(100);
      _this.chartContainer = chartContainer;
      _this.showOnInit = true;
      _this._disposers.push(_this._legend);
      _this.titles.events.on("inserted", function(label) {
        _this.processTitle(label);
        _this.updateReaderTitleReferences();
      }, _this, false);
      _this.titles.events.on("removed", function(label) {
        _this.updateReaderTitleReferences();
      }, _this, false);
      _this.role = "region";
      _this.defaultState.transitionDuration = 1;
      _this.applyTheme();
      return _this;
    }
    Chart2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Chart");
      }
    };
    Chart2.prototype.draw = function() {
      this.fixLayout();
      _super.prototype.draw.call(this);
    };
    Chart2.prototype.fixLayout = function() {
      var legend = this.legend;
      if (legend) {
        var chartAndLegendContainer = this.chartAndLegendContainer;
        var chartContainer = this.chartContainer;
        chartContainer.x = void 0;
        chartContainer.y = void 0;
        if (legend.position != "absolute") {
          legend.x = void 0;
          legend.y = void 0;
        }
        switch (legend.position) {
          case "left":
            chartAndLegendContainer.layout = "horizontal";
            legend.toBack();
            break;
          case "right":
            chartAndLegendContainer.layout = "horizontal";
            legend.toFront();
            break;
          case "top":
            chartAndLegendContainer.layout = "vertical";
            legend.toBack();
            break;
          case "bottom":
            chartAndLegendContainer.layout = "vertical";
            legend.toFront();
            break;
          case "absolute":
            legend.isMeasured = false;
            break;
        }
      }
    };
    Chart2.prototype.feedLegend = function() {
    };
    Chart2.prototype.processTitle = function(event) {
      var title = event.newValue;
      title.parent = this;
      title.toBack();
      title.shouldClone = false;
      title.align = "center";
      title.uidAttr();
      return title;
    };
    Chart2.prototype.updateReaderTitleReferences = function() {
      if (this.titles.length) {
        var titleIds_1 = [];
        each3(this.titles.iterator(), function(title) {
          titleIds_1.push(title.uid);
        });
        this.setSVGAttribute({ "aria-labelledby": titleIds_1.join(" ") });
      } else {
        this.removeSVGAttribute("aria-labelledby");
      }
    };
    Object.defineProperty(Chart2.prototype, "legend", {
      /**
       * @return Legend
       */
      get: function() {
        return this._legend.get();
      },
      /**
       * Holds the instance of chart's [[Leged]].
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/legend/} for more information about legends
       * @param Legend
       */
      set: function(legend) {
        this.setLegend(legend);
      },
      enumerable: true,
      configurable: true
    });
    Chart2.prototype.setLegend = function(legend) {
      var _this = this;
      if (this._legend.get() !== legend) {
        if (legend) {
          legend.parent = this.chartAndLegendContainer;
          this._legend.set(legend, legend.events.on("propertychanged", function(event) {
            if (event.property == "position") {
              _this.fixLayout();
            }
          }, void 0, false));
          legend.addDisposer(new Disposer(function() {
            _this.legend = void 0;
          }));
        } else {
          this._legend.reset();
        }
        this.feedLegend();
      }
    };
    Chart2.prototype.dispose = function() {
      if (this.legend) {
        this.legend.dispose();
      }
      _super.prototype.dispose.call(this);
    };
    Chart2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config.legend) && !hasValue(config.legend.type)) {
          config.legend.type = "Legend";
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    Chart2.prototype.copyFrom = function(source) {
      this.titles.copyFrom(source.titles);
      this.chartContainer.copyFrom(source.chartContainer);
      if (source.legend) {
        this.legend = source.legend.clone();
        this.legend.removeChildren();
      }
      _super.prototype.copyFrom.call(this, source);
    };
    Object.defineProperty(Chart2.prototype, "dragGrip", {
      /**
       * @return Grip
       */
      get: function() {
        var _this = this;
        if (!this._dragGrip) {
          var grip_1 = this.tooltipContainer.createChild(Grip);
          grip_1.align = "right";
          grip_1.valign = "middle";
          grip_1.hide(0);
          grip_1.events.on("down", function(ev) {
            if (ev.touch) {
              _this.interactionsEnabled = false;
            }
          });
          grip_1.events.on("up", function(ev) {
            _this.interactionsEnabled = true;
          });
          this.events.on("down", function(ev) {
            if (ev.touch) {
              grip_1.show();
            }
          });
          this._dragGrip = grip_1;
        }
        return this._dragGrip;
      },
      /**
       * An instance of [[Grip]] which serves as a grip point which appears on
       * touch and allows scrolling whole page even if chart is occupying the
       * whole of the screen and would otherwise prevent scrolling.
       *
       * @since 4.4.0
       * @see {@link https://www.amcharts.com/docs/v4/concepts/touch/} For more information.
       * @param  value  Grip
       */
      set: function(value) {
        this._dragGrip = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Chart2.prototype, "focusable", {
      get: function() {
        return this.parent.focusable;
      },
      set: function(value) {
        this.parent.focusable = value;
      },
      enumerable: true,
      configurable: true
    });
    return Chart2;
  }(Component)
);
registry.registeredClasses["Chart"] = Chart;
defaultRules.push({
  relevant: ResponsiveBreakpoints.widthXS,
  state: function(target, stateId) {
    if (target instanceof Chart) {
      var state = target.states.create(stateId);
      if (target.pixelPaddingLeft > 10) {
        state.properties.paddingLeft = 10;
      }
      if (target.pixelPaddingRight > 10) {
        state.properties.paddingRight = 10;
      }
      return state;
    }
    return null;
  }
});
defaultRules.push({
  relevant: ResponsiveBreakpoints.heightXS,
  state: function(target, stateId) {
    if (target instanceof Chart) {
      var state = target.states.create(stateId);
      if (target.pixelPaddingTop > 10) {
        state.properties.paddingTop = 10;
      }
      if (target.pixelPaddingBottom > 10) {
        state.properties.paddingBottom = 10;
      }
      return state;
    }
    return null;
  }
});
defaultRules.push({
  relevant: ResponsiveBreakpoints.widthXXS,
  state: function(target, stateId) {
    if (target instanceof Chart) {
      var state = target.states.create(stateId);
      state.properties.paddingLeft = 0;
      state.properties.paddingRight = 0;
      return state;
    }
    return null;
  }
});
defaultRules.push({
  relevant: ResponsiveBreakpoints.heightXXS,
  state: function(target, stateId) {
    if (target instanceof Chart) {
      var state = target.states.create(stateId);
      state.properties.paddingTop = 0;
      state.properties.paddingBottom = 0;
      return state;
    }
    return null;
  }
});

// node_modules/@amcharts/amcharts4/.internal/charts/elements/Bullet.js
var Bullet = (
  /** @class */
  function(_super) {
    __extends(Bullet2, _super);
    function Bullet2() {
      var _this = _super.call(this) || this;
      _this.className = "Bullet";
      _this.isMeasured = false;
      _this.tooltipX = 0;
      _this.tooltipY = 0;
      _this.layout = "none";
      _this.applyOnClones = true;
      _this.copyToLegendMarker = true;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(Bullet2.prototype, "locationX", {
      /**
       * @return Location (0-1)
       */
      get: function() {
        return this.getPropertyValue("locationX");
      },
      /**
       * Relative horizontal location within cell. (0-1)
       *
       * @param value  Location (0-1)
       */
      set: function(value) {
        if (this.setPropertyValue("locationX", value)) {
          var dataItem = this.dataItem;
          if (dataItem && dataItem.component) {
            dataItem.component.invalidate();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Bullet2.prototype, "locationY", {
      /**
       * @return Location (0-1)
       */
      get: function() {
        return this.getPropertyValue("locationY");
      },
      /**
       * Relative vertical location within cell. (0-1)
       *
       * @param value  Location (0-1)
       */
      set: function(value) {
        if (this.setPropertyValue("locationY", value)) {
          var dataItem = this.dataItem;
          if (dataItem && dataItem.component) {
            dataItem.component.invalidate();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Bullet2.prototype, "xField", {
      /**
       * @return [description]
       */
      get: function() {
        return this.getPropertyValue("xField");
      },
      /**
       * [xField description]
       *
       * @todo Description
       * @param value  [description]
       */
      set: function(value) {
        this.setPropertyValue("xField", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Bullet2.prototype, "yField", {
      /**
       * @return [description]
       */
      get: function() {
        return this.getPropertyValue("yField");
      },
      /**
       * [yField description]
       *
       * Description
       * @param value  [description]
       */
      set: function(value) {
        this.setPropertyValue("yField", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Bullet2.prototype, "isDynamic", {
      /**
       * @return Redraw on data change?
       */
      get: function() {
        return this.getPropertyValue("isDynamic");
      },
      /**
       * Indicates if the bullet is "dynamic".
       *
       * In most cases the bullets remain the same, even if the underlying data
       * changes.
       *
       * However, in cases where bullet also displays a label, or its size depends
       * on data, it also needs to be redrawn when the underlying data changes.
       *
       * Only those bullets that have set `isDynamic = true` will be redrawn each
       * time data changes. Regular bullets will be reused as they are.
       *
       * @default false
       * @param value  Redraw on data change?
       */
      set: function(value) {
        this.setPropertyValue("isDynamic", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Bullet2.prototype, "copyToLegendMarker", {
      /**
       * @return Redraw on data change?
       */
      get: function() {
        return this.getPropertyValue("copyToLegendMarker");
      },
      /**
       * Indicates if the bullet should be copied to legend marker
       *
       * @default false
       * @param value  Redraw on data change?
       */
      set: function(value) {
        this.setPropertyValue("copyToLegendMarker", value);
      },
      enumerable: true,
      configurable: true
    });
    return Bullet2;
  }(Container)
);
registry.registeredClasses["Bullet"] = Bullet;
defaultRules.push({
  relevant: ResponsiveBreakpoints.isXS,
  state: function(target, stateId) {
    if (target instanceof Bullet) {
      var state = target.states.create(stateId);
      state.properties.disabled = true;
      return state;
    }
    return null;
  }
});

// node_modules/@amcharts/amcharts4/.internal/charts/Legend.js
var LegendDataItem = (
  /** @class */
  function(_super) {
    __extends(LegendDataItem2, _super);
    function LegendDataItem2() {
      var _this = _super.call(this) || this;
      _this.childrenCreated = false;
      _this.className = "LegendDataItem";
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(LegendDataItem2.prototype, "label", {
      /**
       * A legend item's [[Label]] element.
       *
       * @return Label
       */
      get: function() {
        var _this = this;
        if (!this._label) {
          var label_1 = this.component.labels.create();
          this._label = label_1;
          this.addSprite(label_1);
          this._disposers.push(label_1);
          label_1.parent = this.itemContainer;
          this._disposers.push(new Disposer(function() {
            if (hasValue(_this.component)) {
              _this.component.labels.removeValue(label_1);
            }
          }));
        }
        return this._label;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(LegendDataItem2.prototype, "color", {
      /**
       * @return Main color
       */
      get: function() {
        return this.properties.color;
      },
      /**
       * Main color of legend data item.
       *
       * This is set by the target element this legend item represents, like
       * a Series or a Slice.
       *
       * It can be used to derive a color in legend's sub-items, like label:
       *
       * ```TypeScript
       * chart.legend.labels.template.text = "[{color}]{name}[/]";
       * ```
       * ```JavaScript
       * chart.legend.labels.template.text = "[{color}]{name}[/]";
       * ```
       * ```JSON
       * {
       *   // ...
       *   "legend": {
       *     // ...
       *     "labels": {
       *       "text": "[{color}]{name}[/]"
       *     }
       *   }
       * }
       * ```
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/legend/#Legend_labels} For more information about configuring legend labels.
       * @param value  Main color
       */
      set: function(value) {
        this.setProperty("color", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(LegendDataItem2.prototype, "valueLabel", {
      /**
       * A legend item's [[Label]] element for "value label".
       *
       * @return Label
       */
      get: function() {
        var _this = this;
        if (!this._valueLabel) {
          var valueLabel_1 = this.component.valueLabels.create();
          this._valueLabel = valueLabel_1;
          this.addSprite(valueLabel_1);
          this._disposers.push(valueLabel_1);
          valueLabel_1.parent = this.itemContainer;
          this._disposers.push(new Disposer(function() {
            if (hasValue(_this.component)) {
              _this.component.valueLabels.removeValue(valueLabel_1);
            }
          }));
        }
        return this._valueLabel;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(LegendDataItem2.prototype, "itemContainer", {
      /**
       * A reference to the main [[Container]] that holds legend item's elements:
       * marker and labels.
       *
       * @return Item container
       */
      get: function() {
        var _this = this;
        if (!this._itemContainer) {
          var component_1 = this.component;
          var itemContainer_1 = component_1.itemContainers.create();
          itemContainer_1.parent = component_1;
          this._itemContainer = itemContainer_1;
          this.addSprite(itemContainer_1);
          this._disposers.push(itemContainer_1);
          if (itemContainer_1.togglable) {
            itemContainer_1.events.on("toggled", function(ev) {
              component_1.toggleDataItem(ev.target.dataItem);
            }, void 0, false);
          }
          if (itemContainer_1.focusable) {
            itemContainer_1.events.on("hit", function(ev) {
              component_1.focusedItem = void 0;
            }, void 0, false);
            itemContainer_1.events.on("focus", function(ev) {
              component_1.focusedItem = ev.target.dataItem;
            }, void 0, false);
            itemContainer_1.events.on("blur", function(ev) {
              component_1.focusedItem = void 0;
            }, void 0, false);
          }
          this._disposers.push(new Disposer(function() {
            if (hasValue(_this.component)) {
              _this.component.itemContainers.removeValue(itemContainer_1);
            }
          }));
          if (this.dataContext.uidAttr) {
            itemContainer_1.readerControls = this.dataContext.uidAttr();
            itemContainer_1.readerLabelledBy = this.dataContext.uidAttr();
          }
          var sprite = this.dataContext;
          if ((sprite instanceof DataItem || sprite instanceof Sprite) && !sprite.isDisposed()) {
            var visibilitychanged = function(ev) {
              itemContainer_1.readerChecked = ev.visible;
              itemContainer_1.events.disableType("toggled");
              itemContainer_1.isActive = !ev.visible;
              itemContainer_1.events.enableType("toggled");
            };
            sprite.addDisposer(new Disposer(function() {
              if (_this.component) {
                _this.component.dataItems.remove(_this);
              }
            }));
            if (sprite instanceof Sprite) {
              itemContainer_1.addDisposer(sprite.events.on("visibilitychanged", visibilitychanged, void 0, false));
              itemContainer_1.addDisposer(sprite.events.on("hidden", function(ev) {
                itemContainer_1.readerChecked = false;
                itemContainer_1.events.disableType("toggled");
                itemContainer_1.isActive = true;
                itemContainer_1.events.enableType("toggled");
              }, void 0, false));
              itemContainer_1.addDisposer(sprite.events.on("shown", function(ev) {
                itemContainer_1.readerChecked = true;
                itemContainer_1.events.disableType("toggled");
                itemContainer_1.isActive = false;
                itemContainer_1.events.enableType("toggled");
              }, void 0, false));
            } else {
              itemContainer_1.addDisposer(sprite.events.on("visibilitychanged", visibilitychanged, void 0, false));
            }
          }
        }
        return this._itemContainer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(LegendDataItem2.prototype, "marker", {
      /**
       * A [[Container]] that holds legend item's marker element.
       *
       * @return Marker
       */
      get: function() {
        var _this = this;
        if (!this._marker) {
          var marker_1 = this.component.markers.create();
          this._marker = marker_1;
          marker_1.parent = this.itemContainer;
          this.addSprite(marker_1);
          this._disposers.push(marker_1);
          this._disposers.push(new Disposer(function() {
            if (hasValue(_this.component)) {
              _this.component.markers.removeValue(marker_1);
            }
          }));
        }
        return this._marker;
      },
      enumerable: true,
      configurable: true
    });
    return LegendDataItem2;
  }(DataItem)
);
var LegendSettings = (
  /** @class */
  /* @__PURE__ */ function() {
    function LegendSettings2() {
      this.createMarker = true;
    }
    return LegendSettings2;
  }()
);
var Legend = (
  /** @class */
  function(_super) {
    __extends(Legend2, _super);
    function Legend2() {
      var _this = _super.call(this) || this;
      _this.className = "Legend";
      _this.layout = "grid";
      _this.setPropertyValue("useDefaultMarker", false);
      _this.setPropertyValue("scrollable", false);
      _this.setPropertyValue("contentAlign", "center");
      var itemContainer = new Container();
      itemContainer.applyOnClones = true;
      itemContainer.padding(8, 0, 8, 0);
      itemContainer.margin(0, 10, 0, 10);
      itemContainer.layout = "horizontal";
      itemContainer.clickable = true;
      itemContainer.focusable = true;
      itemContainer.role = "switch";
      itemContainer.togglable = true;
      itemContainer.cursorOverStyle = MouseCursorStyle.pointer;
      itemContainer.background.fillOpacity = 0;
      _this.itemContainers = new ListTemplate(itemContainer);
      _this._disposers.push(new ListDisposer(_this.itemContainers));
      _this._disposers.push(_this.itemContainers.template);
      _this._disposers.push(getInteraction().body.events.on("keyup", function(ev) {
        if (keyboard.isKey(ev.event, "enter") && _this.focusedItem) {
          var focusedItem = _this.focusedItem;
          var target = focusedItem.itemContainer;
          if (target.togglable) {
            _this.toggleDataItem(focusedItem);
          } else if (target.clickable && target.events.isEnabled("hit")) {
            target.dispatchImmediately("hit", { event: ev });
            _this.focusedItem = focusedItem;
          }
        }
      }, _this));
      var interfaceColors = new InterfaceColorSet();
      var marker = new Container();
      marker.width = 23;
      marker.height = 23;
      marker.interactionsEnabled = false;
      marker.applyOnClones = true;
      marker.setStateOnChildren = true;
      marker.background.fillOpacity = 0;
      marker.background.strokeOpacity = 0;
      marker.propertyFields.fill = "fill";
      marker.valign = "middle";
      var disabledColor = interfaceColors.getFor("disabledBackground");
      marker.events.on("childadded", function(event) {
        var child = event.newValue;
        var activeState = child.states.create("active");
        activeState.properties.stroke = disabledColor;
        activeState.properties.fill = disabledColor;
      });
      _this.markers = new ListTemplate(marker);
      _this._disposers.push(new ListDisposer(_this.markers));
      _this._disposers.push(_this.markers.template);
      var rectangle2 = marker.createChild(RoundedRectangle);
      rectangle2.width = percent(100);
      rectangle2.height = percent(100);
      rectangle2.applyOnClones = true;
      rectangle2.propertyFields.fill = "fill";
      rectangle2.strokeOpacity = 0;
      var label = new Label();
      label.text = "{name}";
      label.margin(0, 5, 0, 5);
      label.valign = "middle";
      label.applyOnClones = true;
      label.states.create("active").properties.fill = interfaceColors.getFor("disabledBackground");
      _this.labels = new ListTemplate(label);
      _this._disposers.push(new ListDisposer(_this.labels));
      _this._disposers.push(_this.labels.template);
      label.interactionsEnabled = false;
      label.truncate = true;
      label.fullWords = false;
      var valueLabel = new Label();
      valueLabel.margin(0, 5, 0, 0);
      valueLabel.valign = "middle";
      valueLabel.width = 50;
      valueLabel.align = "right";
      valueLabel.textAlign = "end";
      valueLabel.applyOnClones = true;
      valueLabel.states.create("active").properties.fill = interfaceColors.getFor("disabledBackground");
      valueLabel.interactionsEnabled = false;
      _this.valueLabels = new ListTemplate(valueLabel);
      _this._disposers.push(new ListDisposer(_this.valueLabels));
      _this._disposers.push(_this.valueLabels.template);
      _this.position = "bottom";
      itemContainer.states.create("active");
      itemContainer.setStateOnChildren = true;
      _this.role = "group";
      _this.events.on("layoutvalidated", _this.handleScrollbar, _this, false);
      _this.events.on("parentset", function() {
        var parent = _this.parent;
        if (parent) {
          _this._disposers.push(parent.events.on("maxsizechanged", function() {
            if (_this.scrollable) {
              _this.setTimeout(function() {
                _this.updateMasks();
                _this.handleScrollbar();
                _this._handleWheelReal(1);
              }, 100);
            }
          }));
        }
      });
      _this.applyTheme();
      return _this;
    }
    Legend2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Legend");
      }
    };
    Legend2.prototype.createDataItem = function() {
      return new LegendDataItem();
    };
    Legend2.prototype.validateDataElements = function() {
      if (this.scrollbar) {
        this.scrollbar.start = 0;
        this.scrollbar.end = 1;
      }
      _super.prototype.validateDataElements.call(this);
    };
    Legend2.prototype.validateDataElement = function(dataItem) {
      _super.prototype.validateDataElement.call(this, dataItem);
      var container = dataItem.itemContainer;
      var marker = dataItem.marker;
      used(dataItem.label);
      var valueLabel = dataItem.valueLabel;
      container.readerChecked = dataItem.dataContext.visible;
      dataItem.dataContext.legendDataItem = dataItem;
      var tempMaxWidth = dataItem.label.maxWidth;
      if (!(dataItem.label.width instanceof Percent)) {
        dataItem.label.width = void 0;
      }
      if (tempMaxWidth > 0) {
        dataItem.label.maxWidth = tempMaxWidth;
      }
      if (valueLabel.align == "right") {
        valueLabel.width = void 0;
      }
      var legendSettings = dataItem.dataContext.legendSettings;
      var dataContext = dataItem.dataContext;
      if (dataContext.createLegendMarker && (!this.useDefaultMarker || !(dataContext instanceof Sprite))) {
        if (!dataItem.childrenCreated) {
          dataContext.createLegendMarker(marker);
          dataItem.childrenCreated = true;
        }
      } else {
        this.markers.template.propertyFields.fill = void 0;
      }
      if (dataContext.updateLegendValue) {
        dataContext.updateLegendValue();
      }
      if (dataContext.component && dataContext.component.updateLegendValue) {
        dataContext.component.updateLegendValue(dataContext);
      }
      if (valueLabel.invalid) {
        valueLabel.validate();
      }
      if (valueLabel.text == "" || valueLabel.text == void 0) {
        valueLabel.__disabled = true;
      } else {
        valueLabel.__disabled = false;
      }
      if (legendSettings && (legendSettings.itemValueText != void 0 || legendSettings.valueText != void 0)) {
        valueLabel.__disabled = false;
      }
      var visible = dataItem.dataContext.visible;
      if (visible === void 0) {
        visible = true;
      }
      visible = toBoolean(visible);
      dataItem.dataContext.visible = visible;
      container.events.disableType("toggled");
      container.isActive = !visible;
      if (container.isActive) {
        container.setState("active", 0);
      } else {
        container.setState("default", 0);
      }
      container.events.enableType("toggled");
    };
    Legend2.prototype.afterDraw = function() {
      var _this = this;
      var maxWidth = this.getPropertyValue("maxWidth");
      var maxLabelWidth = 0;
      this.labels.each(function(label) {
        if (label.invalid) {
          label.maxWidth = void 0;
          label.validate();
        }
        if (label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight > maxLabelWidth) {
          maxLabelWidth = label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight;
        }
      });
      var maxValueLabelWidth = 0;
      this.valueLabels.each(function(label) {
        if (label.invalid) {
          label.validate();
        }
        if (label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight > maxValueLabelWidth) {
          maxValueLabelWidth = label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight;
        }
      });
      var maxMarkerWidth = 0;
      this.markers.each(function(marker) {
        if (marker.invalid) {
          marker.validate();
        }
        if (marker.measuredWidth + marker.pixelMarginLeft + marker.pixelMarginRight > maxMarkerWidth) {
          maxMarkerWidth = marker.measuredWidth + marker.pixelMarginLeft + marker.pixelMarginRight;
        }
      });
      var itemContainer = this.itemContainers.template;
      var margin = itemContainer.pixelMarginRight + itemContainer.pixelMarginLeft;
      var maxAdjustedLabelWidth;
      var trueMaxWidth = maxLabelWidth + maxValueLabelWidth + maxMarkerWidth;
      if (!isNumber(maxWidth)) {
        maxAdjustedLabelWidth = maxLabelWidth;
      } else {
        maxWidth = maxWidth - margin;
        if (maxWidth > trueMaxWidth) {
          maxWidth = trueMaxWidth;
        }
        maxAdjustedLabelWidth = maxWidth - maxMarkerWidth - maxValueLabelWidth;
      }
      this.labels.each(function(label) {
        if (_this.valueLabels.template.align == "right" || label.measuredWidth > maxAdjustedLabelWidth) {
          if (!(label.width instanceof Percent)) {
            label.width = Math.min(label.maxWidth, maxAdjustedLabelWidth - label.pixelMarginLeft - label.pixelMarginRight);
            label.maxWidth = label.width;
          }
        }
      });
      if (this.valueLabels.template.align == "right") {
        this.valueLabels.each(function(valueLabel) {
          valueLabel.width = maxValueLabelWidth - valueLabel.pixelMarginRight - valueLabel.pixelMarginLeft;
        });
      }
      _super.prototype.afterDraw.call(this);
    };
    Legend2.prototype.handleScrollbar = function() {
      var scrollbar = this.scrollbar;
      if (this.scrollable && scrollbar) {
        var measuredHeight = this.maxHeight;
        scrollbar.height = measuredHeight;
        scrollbar.x = this.measuredWidth - scrollbar.pixelWidth - scrollbar.pixelMarginLeft;
        if (this.contentHeight > measuredHeight) {
          scrollbar.visible = true;
          scrollbar.thumb.height = scrollbar.height * measuredHeight / this.contentHeight;
          this.paddingRight = scrollbar.pixelWidth + scrollbar.pixelMarginLeft + scrollbar.pixelMarginRight;
        } else {
          scrollbar.thumb.height = scrollbar.height * measuredHeight / this.contentHeight;
          this.paddingRight = scrollbar.pixelWidth + scrollbar.pixelMarginLeft + scrollbar.pixelMarginRight;
          scrollbar.visible = false;
          scrollbar.start = 0;
          scrollbar.end = 1;
        }
        scrollbar.handleThumbPosition();
        this.updateMasks();
      }
    };
    Object.defineProperty(Legend2.prototype, "position", {
      /**
       * @return Position
       */
      get: function() {
        return this.getPropertyValue("position");
      },
      /**
       * Position of the legend.
       *
       * Options: "left", "right", "top", "bottom" (default), or "absolute".
       *
       * IMPORTANT: [[MapChart]] will ignore this setting, as it is using different
       * layout structure than other charts.
       *
       * To position legend in [[MapChart]] set legend's `align` (`"left"` or
       * `"right"`) and `valign` (`"top"` or `"bottom"`) properties instead.
       *
       * @default "bottom"
       * @param value  Position
       */
      set: function(value) {
        if (this.setPropertyValue("position", value)) {
          if (value == "left" || value == "right") {
            this.margin(10, 5, 10, 10);
            this.valign = "middle";
            this.contentAlign = "none";
            this.valueLabels.template.align = "right";
            if (!isNumber(this.maxColumns)) {
              this.maxColumns = 1;
            }
            this.width = void 0;
            this.maxWidth = 220;
          } else {
            this.maxColumns = void 0;
            this.width = percent(100);
            this.valueLabels.template.align = "left";
          }
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Legend2.prototype, "useDefaultMarker", {
      /**
       * @return Use default marker?
       */
      get: function() {
        return this.getPropertyValue("useDefaultMarker");
      },
      /**
       * Should legend try to mirror the look of the related item when building
       * the marker for legend item?
       *
       * If set to `false` it will try to make the marker look like its related
       * item.
       *
       * E.g. if an item is for a Line Series, it will display a line of the
       * same thickness, color, and will use the same bullets if series have them.
       *
       * If set to `true`, all markers will be shown as squares, regardless of te
       * series type.
       *
       * @default false
       * @param value Use default marker?
       */
      set: function(value) {
        this.setPropertyValue("useDefaultMarker", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Legend2.prototype, "scrollable", {
      /**
       * @return Legend Scrollable?
       */
      get: function() {
        return this.getPropertyValue("scrollable");
      },
      /**
       * If set to `true` the Legend will display a scrollbar if its contents do
       * not fit into its `maxHeight`.
       *
       * Please note that `maxHeight` is automatically set for Legend when its
       * `position` is set to `"left"` or `"right"`.
       *
       * @default false
       * @since 4.8.0
       * @param  value  Legend Scrollable?
       */
      set: function(value) {
        if (this.setPropertyValue("scrollable", value, true)) {
          if (value) {
            var scrollbar = this.createChild(Scrollbar);
            this.scrollbar = scrollbar;
            scrollbar.isMeasured = false;
            scrollbar.orientation = "vertical";
            scrollbar.endGrip.__disabled = true;
            scrollbar.startGrip.__disabled = true;
            scrollbar.visible = false;
            scrollbar.marginLeft = 5;
            this._mouseWheelDisposer = this.events.on("wheel", this.handleWheel, this, false);
            this._disposers.push(this._mouseWheelDisposer);
            this._disposers.push(scrollbar.events.on("rangechanged", this.updateMasks, this, false));
          } else {
            if (this._mouseWheelDisposer) {
              this._mouseWheelDisposer.dispose();
              if (this.scrollbar) {
                this.scrollbar.dispose();
                this.scrollbar = void 0;
              }
            }
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Legend2.prototype.handleWheel = function(event) {
      this._handleWheelReal(event.shift.y);
    };
    Legend2.prototype._handleWheelReal = function(shift) {
      var scrollbar = this.scrollbar;
      if (scrollbar) {
        var ds = shift / 1e3 * this.measuredHeight / this.contentHeight;
        var delta = scrollbar.end - scrollbar.start;
        if (shift > 0) {
          scrollbar.start = max(0, scrollbar.start - ds);
          scrollbar.end = scrollbar.start + delta;
        } else {
          scrollbar.end = min(1, scrollbar.end - ds);
          scrollbar.start = scrollbar.end - delta;
        }
      }
    };
    Legend2.prototype.updateMasks = function() {
      var _this = this;
      if (this.scrollbar) {
        this.itemContainers.each(function(itemContainer) {
          itemContainer.dy = -_this.scrollbar.thumb.pixelY * _this.contentHeight / _this.maxHeight;
          itemContainer.maskRectangle = { x: 0, y: -itemContainer.dy, width: _this.measuredWidth, height: _this.maxHeight };
        });
      }
      this.invalidatePosition();
    };
    Legend2.prototype.toggleDataItem = function(item) {
      var dataContext = item.dataContext;
      if (!dataContext.visible || dataContext.isHiding || dataContext instanceof Sprite && dataContext.isHidden) {
        item.color = item.colorOrig;
        dataContext.appeared = true;
        item.itemContainer.isActive = false;
        if (dataContext.hidden === true) {
          dataContext.hidden = false;
        }
        if (dataContext.show) {
          dataContext.show();
        } else {
          dataContext.visible = true;
        }
        this.svgContainer.readerAlert(this.language.translate("%1 shown", this.language.locale, item.label.readerTitle));
      } else {
        item.itemContainer.isActive = true;
        dataContext.appeared = true;
        if (dataContext.hide) {
          dataContext.hide();
        } else {
          dataContext.visible = false;
        }
        this.svgContainer.readerAlert(this.language.translate("%1 hidden", this.language.locale, item.label.readerTitle));
        item.color = new InterfaceColorSet().getFor("disabledBackground");
      }
    };
    Object.defineProperty(Legend2.prototype, "preloader", {
      /**
       * Override preloader method so that legend does not accidentally show its
       * own preloader.
       *
       * @ignore Exclude from docs
       * @return Always `undefined`
       */
      get: function() {
        return;
      },
      enumerable: true,
      configurable: true
    });
    Legend2.prototype.handleDataItemPropertyChange = function(dataItem, name) {
      dataItem.valueLabel.invalidate();
      dataItem.label.invalidate();
    };
    return Legend2;
  }(Component)
);
registry.registeredClasses["Legend"] = Legend;
defaultRules.push({
  relevant: ResponsiveBreakpoints.widthXS,
  state: function(target, stateId) {
    if (target instanceof Legend && (target.position == "left" || target.position == "right")) {
      var state = target.states.create(stateId);
      state.properties.position = "bottom";
      return state;
    }
    return null;
  }
});
defaultRules.push({
  relevant: ResponsiveBreakpoints.heightXS,
  state: function(target, stateId) {
    if (target instanceof Legend && (target.position == "top" || target.position == "bottom")) {
      var state = target.states.create(stateId);
      state.properties.position = "right";
      return state;
    }
    return null;
  }
});
defaultRules.push({
  relevant: ResponsiveBreakpoints.isXS,
  state: function(target, stateId) {
    if (target instanceof Legend) {
      var state = target.states.create(stateId);
      state.properties.disabled = true;
      return state;
    }
    return null;
  }
});

// node_modules/@amcharts/amcharts4/.internal/charts/series/Series.js
var SeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(SeriesDataItem2, _super);
    function SeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "SeriesDataItem";
      _this.values.value = {};
      _this.values.value = {};
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(SeriesDataItem2.prototype, "bullets", {
      /**
       * A dictionary of data items bullets, where key is uid of a bullet template.
       */
      get: function() {
        if (!this._bullets) {
          this._bullets = new Dictionary();
          this._disposers.push(new DictionaryDisposer(this._bullets));
        }
        return this._bullets;
      },
      enumerable: true,
      configurable: true
    });
    SeriesDataItem2.prototype.dispose = function() {
      this.bullets.clear();
      _super.prototype.dispose.call(this);
    };
    Object.defineProperty(SeriesDataItem2.prototype, "value", {
      /**
       * @return Value
       */
      get: function() {
        return this.values.value.value;
      },
      /**
       * data items's numeric value.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("value", value);
      },
      enumerable: true,
      configurable: true
    });
    return SeriesDataItem2;
  }(DataItem)
);
var Series = (
  /** @class */
  function(_super) {
    __extends(Series2, _super);
    function Series2() {
      var _this = _super.call(this) || this;
      _this._ignoreMinMax = false;
      _this._showBullets = true;
      _this.legendSettings = new LegendSettings();
      _this._tmin = new Dictionary();
      _this._tmax = new Dictionary();
      _this._smin = new Dictionary();
      _this._smax = new Dictionary();
      _this.dataItemsByAxis = new Dictionary();
      _this.skipFocusThreshold = 20;
      _this._itemReaderTextChanged = false;
      _this.calculatePercent = false;
      _this.usePercentHack = true;
      _this.autoDispose = true;
      _this.simplifiedProcessing = false;
      if (_this.constructor === Series2) {
        throw new Error("'Series' cannot be instantiated directly. Please use a specific series type.");
      }
      _this.className = "Series";
      _this.isMeasured = false;
      _this.layout = "none";
      _this.shouldClone = false;
      _this.setPropertyValue("hidden", false);
      _this.axisRanges = new List();
      _this.axisRanges.events.on("inserted", _this.processAxisRange, _this, false);
      _this.minBulletDistance = 0;
      _this.mainContainer = _this.createChild(Container);
      _this.mainContainer.shouldClone = false;
      _this.mainContainer.mask = _this.createChild(Sprite);
      _this._disposers.push(_this.mainContainer);
      var bulletsContainer = _this.mainContainer.createChild(Container);
      _this._shouldBeReady.push(bulletsContainer);
      bulletsContainer.shouldClone = false;
      bulletsContainer.layout = "none";
      bulletsContainer.virtualParent = _this;
      _this._disposers.push(bulletsContainer);
      _this.bulletsContainer = bulletsContainer;
      _this.tooltip = new Tooltip();
      _this.tooltip.virtualParent = _this;
      _this._disposers.push(_this.tooltip);
      _this.hiddenState.transitionEasing = cubicIn;
      _this.dataItem = _this.createDataItem();
      _this._disposers.push(_this.dataItem);
      _this.dataItem.component = _this;
      _this.role = "group";
      _this.applyTheme();
      return _this;
    }
    Series2.prototype.applyTheme = function() {
      _super.prototype.applyTheme.call(this);
      if (options.autoSetClassName && this.bulletsContainer) {
        this.bulletsContainer.className = this.className + "-bullets";
        this.bulletsContainer.setClassName();
      }
    };
    Series2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Series");
      }
    };
    Series2.prototype.createDataItem = function() {
      return new SeriesDataItem();
    };
    Object.defineProperty(Series2.prototype, "chart", {
      /**
       * @return Chart
       */
      get: function() {
        return this._chart;
      },
      /**
       * Chart series is used on.
       *
       * @param value  Chart
       */
      set: function(value) {
        this._chart = value;
      },
      enumerable: true,
      configurable: true
    });
    Series2.prototype.positionBullet = function(bullet) {
    };
    Series2.prototype.processBullet = function(event) {
      var _this = this;
      var bullet = event.newValue;
      bullet.isTemplate = true;
      this.events.once("datavalidated", function(ev) {
        if (_this.itemsFocusable()) {
          bullet.focusable = true;
        }
      });
      this.invalidate();
    };
    Series2.prototype.removeBullet = function(event) {
      var bullet = event.oldValue;
      this.dataItems.each(function(dataItem) {
        var eachBullet = dataItem.bullets.getKey(bullet.uid);
        if (eachBullet) {
          eachBullet.dispose();
        }
      });
      this.invalidate();
    };
    Series2.prototype.validateDataItems = function() {
      _super.prototype.validateDataItems.call(this);
      this.processValues(false);
    };
    Series2.prototype.getFirstValue = function(key, startIndex) {
      for (var i = startIndex; i >= 0; i--) {
        var dataItem = this.dataItems.getIndex(i);
        var value = dataItem.getActualWorkingValue(key);
        if (isNumber(value)) {
          return value;
        }
      }
      return null;
    };
    Series2.prototype.getAbsoluteFirstValue = function(key) {
      for (var i = 0; i < this.dataItems.length; i++) {
        var dataItem = this.dataItems.getIndex(i);
        var value = dataItem.values[key].value;
        if (isNumber(value)) {
          return value;
        }
      }
      return null;
    };
    Series2.prototype.rangeChangeUpdate = function() {
      _super.prototype.rangeChangeUpdate.call(this);
      this.processValues(true);
    };
    Series2.prototype.processValues = function(working) {
      var _this = this;
      if (!this.simplifiedProcessing) {
        var dataItems = this.dataItems;
        var count_1 = {};
        var sum_1 = {};
        var absoluteSum_1 = {};
        var low_1 = {};
        var high_1 = {};
        var open_1 = {};
        var close_1 = {};
        var previous_1 = {};
        var first_1 = {};
        var absoluteFirst_1 = {};
        var startIndex_1 = max(0, this.startIndex);
        startIndex_1 = min(startIndex_1, this.dataItems.length);
        var endIndex = min(this.endIndex, this.dataItems.length);
        if (!isNumber(startIndex_1)) {
          startIndex_1 = 0;
        }
        if (!isNumber(endIndex)) {
          endIndex = this.dataItems.length;
        }
        if (startIndex_1 > 0) {
          var dataItem_1 = dataItems.getIndex(startIndex_1 - 1);
          each2(dataItem_1.values, function(key, values) {
            var value = dataItem_1.getActualWorkingValue(key);
            if (isNumber(value)) {
              previous_1[key] = value;
            }
          });
        }
        var _loop_1 = function(i2) {
          var dataItem_2 = dataItems.getIndex(i2);
          each2(dataItem_2.values, function(key, values) {
            var value = dataItem_2.getActualWorkingValue(key);
            if (isNumber(value)) {
              if (!isNumber(count_1[key])) {
                count_1[key] = 0;
              }
              count_1[key]++;
              if (!isNumber(sum_1[key])) {
                sum_1[key] = 0;
              }
              sum_1[key] += value;
              if (!isNumber(absoluteSum_1[key])) {
                absoluteSum_1[key] = 0;
              }
              absoluteSum_1[key] += Math.abs(value);
              if (!isNumber(open_1[key])) {
                open_1[key] = value;
              }
              close_1[key] = value;
              if (!isNumber(low_1[key])) {
                low_1[key] = value;
              } else {
                if (low_1[key] > value) {
                  low_1[key] = value;
                }
              }
              if (!isNumber(high_1[key])) {
                high_1[key] = value;
              } else {
                if (high_1[key] < value) {
                  high_1[key] = value;
                }
              }
              if (!isNumber(first_1[key])) {
                first_1[key] = _this.getFirstValue(key, startIndex_1);
              }
              if (!isNumber(absoluteFirst_1[key])) {
                absoluteFirst_1[key] = _this.getAbsoluteFirstValue(key);
              }
              dataItem_2.setCalculatedValue(key, value - first_1[key], "change");
              dataItem_2.setCalculatedValue(key, (value - first_1[key]) / first_1[key] * 100, "changePercent");
              dataItem_2.setCalculatedValue(key, value - absoluteFirst_1[key], "startChange");
              dataItem_2.setCalculatedValue(key, (value - absoluteFirst_1[key]) / absoluteFirst_1[key] * 100, "startChangePercent");
              var prevValue = previous_1[key];
              if (!isNumber(prevValue)) {
                prevValue = value;
              }
              dataItem_2.setCalculatedValue(key, value - prevValue, "previousChange");
              dataItem_2.setCalculatedValue(key, (value - prevValue) / prevValue * 100, "previousChangePercent");
              previous_1[key] = value;
            }
          });
        };
        for (var i = startIndex_1; i < endIndex; i++) {
          _loop_1(i);
        }
        if (this.calculatePercent) {
          var _loop_2 = function(i2) {
            var dataItem_3 = dataItems.getIndex(i2);
            each2(dataItem_3.values, function(key) {
              var ksum = absoluteSum_1[key];
              var value = dataItem_3.getActualWorkingValue(key);
              if (isNumber(value)) {
                if (ksum > 0) {
                  if (_this.usePercentHack) {
                    if (value == ksum) {
                      ksum = dataItem_3.values[key].value;
                    }
                  }
                  var percent2 = value / ksum * 100;
                  dataItem_3.setCalculatedValue(key, percent2, "percent");
                } else {
                  dataItem_3.setCalculatedValue(key, 0, "percent");
                }
              }
            });
          };
          for (var i = startIndex_1; i < endIndex; i++) {
            _loop_2(i);
          }
        }
        if (startIndex_1 > 0) {
          var zeroItem_1 = dataItems.getIndex(startIndex_1 - 1);
          each2(zeroItem_1.values, function(key) {
            var value = zeroItem_1.values[key].value;
            zeroItem_1.setCalculatedValue(key, value - open_1[key], "change");
            zeroItem_1.setCalculatedValue(key, (value - open_1[key]) / open_1[key] * 100, "changePercent");
          });
        }
        var dataItem_4 = this.dataItem;
        each2(dataItem_4.values, function(key) {
          dataItem_4.setCalculatedValue(key, sum_1[key], "sum");
          dataItem_4.setCalculatedValue(key, absoluteSum_1[key], "absoluteSum");
          dataItem_4.setCalculatedValue(key, sum_1[key] / count_1[key], "average");
          dataItem_4.setCalculatedValue(key, open_1[key], "open");
          dataItem_4.setCalculatedValue(key, close_1[key], "close");
          dataItem_4.setCalculatedValue(key, low_1[key], "low");
          dataItem_4.setCalculatedValue(key, high_1[key], "high");
          dataItem_4.setCalculatedValue(key, count_1[key], "count");
        });
      }
    };
    Series2.prototype.validate = function() {
      if (isIE()) {
        this.filters.clear();
      }
      each3(this.axisRanges.iterator(), function(axisRange) {
        axisRange.validate();
      });
      _super.prototype.validate.call(this);
      var bulletsContainer = this.bulletsContainer;
      bulletsContainer.fill = this.fill;
      bulletsContainer.stroke = this.stroke;
      bulletsContainer.x = this.pixelX;
      bulletsContainer.y = this.pixelY;
      if (this.bulletsContainer.children.length > 0) {
        if (this._showBullets) {
          for (var i = 0; i < this.startIndex; i++) {
            var dataItem = this.dataItems.getIndex(i);
            if (dataItem) {
              dataItem.bullets.each(function(key, bullet) {
                bullet.__disabled = true;
              });
            }
          }
          for (var i = this.dataItems.length - 1; i > this.endIndex; i--) {
            var dataItem = this.dataItems.getIndex(i);
            if (dataItem) {
              dataItem.bullets.each(function(key, bullet) {
                bullet.__disabled = true;
              });
            }
          }
        } else {
          this.bulletsContainer.children.each(function(bullet) {
            bullet.__disabled = true;
          });
        }
      }
      this.updateTooltipBounds();
    };
    Series2.prototype.updateTooltipBounds = function() {
      if (this.topParent) {
        var x = 0;
        var y = 0;
        var w = this.topParent.maxWidth;
        var h = this.topParent.maxHeight;
        var rect = { x, y, width: w, height: h };
        this.tooltip.setBounds(rect);
      }
    };
    Series2.prototype.shouldCreateBullet = function(dataItem, bulletTemplate) {
      return true;
    };
    Series2.prototype.validateDataElement = function(dataItem) {
      var _this = this;
      _super.prototype.validateDataElement.call(this, dataItem);
      if (this._showBullets) {
        if (!this.isHidden) {
          this.bulletsContainer.visible = true;
        }
        this.bullets.each(function(bulletTemplate) {
          var bullet = dataItem.bullets.getKey(bulletTemplate.uid);
          if (_this.shouldCreateBullet(dataItem, bulletTemplate)) {
            if (!bullet) {
              var disabledField = bulletTemplate.propertyFields.disabled;
              var dataContext = dataItem.dataContext;
              if (disabledField && dataContext && dataContext[disabledField] === false) {
                bulletTemplate.applyOnClones = false;
                bulletTemplate.disabled = false;
                bullet = bulletTemplate.clone();
                bulletTemplate.disabled = true;
                bulletTemplate.applyOnClones = true;
              } else {
                bullet = bulletTemplate.clone();
              }
              bullet.shouldClone = false;
              dataItem.addSprite(bullet);
              if (!_this.visible || _this.isHiding) {
                bullet.hide(0);
              }
            }
            var currentDataItem = bullet.dataItem;
            if (currentDataItem != dataItem) {
              if (currentDataItem) {
                currentDataItem.bullets.setKey(bulletTemplate.uid, void 0);
              }
              var readerText_1 = _this.itemReaderText;
              if (bullet instanceof Bullet) {
                if (!readerText_1) {
                  readerText_1 = "{" + bullet.xField + "}: {" + bullet.yField + "}";
                }
                if (bullet.isDynamic) {
                  dataItem.events.on("workingvaluechanged", bullet.deepInvalidate, bullet, false);
                  _this.dataItem.events.on("workingvaluechanged", bullet.deepInvalidate, bullet, false);
                }
                bullet.deepInvalidate();
              }
              if (bullet.focusable) {
                bullet.events.on("focus", function(ev) {
                  bullet.readerTitle = _this.populateString(readerText_1, bullet.dataItem);
                }, void 0, false);
                bullet.events.on("blur", function(ev) {
                  bullet.readerTitle = "";
                }, void 0, false);
              }
              if (bullet.hoverable) {
                bullet.events.on("over", function(ev) {
                  bullet.readerTitle = _this.populateString(readerText_1, bullet.dataItem);
                }, void 0, false);
                bullet.events.on("out", function(ev) {
                  bullet.readerTitle = "";
                }, void 0, false);
              }
            }
            bullet.parent = _this.bulletsContainer;
            dataItem.bullets.setKey(bulletTemplate.uid, bullet);
            bullet.maxWidth = dataItem.itemWidth;
            bullet.maxHeight = dataItem.itemHeight;
            bullet.__disabled = false;
            _this.positionBullet(bullet);
          } else {
            if (bullet) {
              bullet.__disabled = true;
            }
          }
        });
      } else {
        this.bulletsContainer.visible = false;
      }
    };
    Series2.prototype.handleDataItemWorkingValueChange = function(dataItem, name) {
      if (!this.dataRangeInvalid) {
        this.invalidateProcessedData();
      }
    };
    Object.defineProperty(Series2.prototype, "ignoreMinMax", {
      /**
       * @return Exclude from calculations?
       */
      get: function() {
        return this._ignoreMinMax;
      },
      /**
       * Should this series excluded from the axis scale calculations?
       *
       * @default false
       * @param value  Exclude from calculations?
       */
      set: function(value) {
        this._ignoreMinMax = value;
        this.invalidateDataItems();
      },
      enumerable: true,
      configurable: true
    });
    Series2.prototype.createMask = function() {
    };
    Series2.prototype.processAxisRange = function(event) {
      if (!this.rangesContainer) {
        this.rangesContainer = this.createChild(Container);
        this.rangesContainer.shouldClone = false;
        this.rangesContainer.isMeasured = false;
      }
      var axisRange = event.newValue;
      if (axisRange) {
        axisRange.contents.parent = this.rangesContainer;
        axisRange.isRange = true;
        axisRange.events.on("valuechanged", this.invalidateDataItems, this, false);
      }
    };
    Series2.prototype.getAxisField = function(axis) {
      return;
    };
    Series2.prototype.showTooltipAtPosition = function(xPosition, yPosition) {
    };
    Object.defineProperty(Series2.prototype, "minBulletDistance", {
      /**
       * @return Distance (px)
       */
      get: function() {
        return this.getPropertyValue("minBulletDistance");
      },
      /**
       * Minimal distance between data points in pixels.
       *
       * If distance gets smaller than this, bullets are turned off to avoid
       * overlapping.
       *
       * `0` (zero) disables this behavior.
       *
       * IMPORTANT: This setting will work only when Series' base axis
       * is [[CategoryAxis]] or [[DateAxis]]. If base axis is [[ValueAxis]] the
       * setting will be ignored, because it would be a huge overhead to measure
       * distance between each and every bullet.
       *
       * @default 0
       * @param value  Distance (px)
       */
      set: function(value) {
        this.setPropertyValue("minBulletDistance", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Series2.prototype, "bullets", {
      /**
       * A list of bullets that will be added to each and every items in the
       * series.
       *
       * You can push any object that is a descendant of a [[Sprite]] here. All
       * items added to this list will be copied and used as a bullet on all data
       * items, including their properties, events, etc.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/bullets/} for more info about the concept of Bullets
       * @return List of bullets.
       */
      get: function() {
        if (!this._bullets) {
          this._bullets = new ListTemplate(new Bullet());
          this._bullets.template.virtualParent = this;
          this._bullets.events.on("inserted", this.processBullet, this, false);
          this._bullets.events.on("removed", this.removeBullet, this, false);
          this._disposers.push(new ListDisposer(this._bullets));
          this._disposers.push(this._bullets.template);
        }
        return this._bullets;
      },
      enumerable: true,
      configurable: true
    });
    Series2.prototype.createLegendMarker = function(marker) {
    };
    Object.defineProperty(Series2.prototype, "hiddenInLegend", {
      /**
       * @return Hidden in legend?
       */
      get: function() {
        return this.getPropertyValue("hiddenInLegend");
      },
      /**
       * Should the series be hidden in legend?
       *
       * @param value Hidden in legend?
       */
      set: function(value) {
        if (this.setPropertyValue("hiddenInLegend", value)) {
          if (this.chart) {
            this.chart.feedLegend();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Series2.prototype, "name", {
      /**
       * @return Name
       */
      get: function() {
        return this.getPropertyValue("name");
      },
      /**
       * Series' name.
       *
       * @param value  Name
       */
      set: function(value) {
        this.setPropertyValue("name", value);
        var legendDataItem = this.legendDataItem;
        if (legendDataItem) {
          legendDataItem.component.invalidate();
          legendDataItem.component.invalidateRawData();
        }
        this.readerTitle = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Series2.prototype, "itemReaderText", {
      /**
       * @return Screen reader text template
       */
      get: function() {
        var readerText = this._itemReaderText;
        if (!readerText) {
          if (this.tooltipText) {
            readerText = plainText(this.tooltipText);
          } else if (this.tooltipHTML) {
            readerText = plainText(this.tooltipHTML);
          }
        }
        if (!this._adapterO) {
          return readerText;
        } else {
          return this._adapterO.apply("itemReaderText", readerText);
        }
      },
      /**
       * Screen reader text to be applied to each individual data item, such
       * as bullets, columns or slices.
       *
       * The template can contain field reference meta codes, i.e. `{dateX}`,
       * `{valueY}`, etc.
       *
       * Any text formatting options, e.g. `[bold]` will be ignored.
       *
       * @param value Screen reader text template
       */
      set: function(value) {
        this._itemReaderText = value;
        this._itemReaderTextChanged = true;
      },
      enumerable: true,
      configurable: true
    });
    Series2.prototype.itemsFocusable = function() {
      return this.dataItems.length >= this.skipFocusThreshold ? false : true;
    };
    Object.defineProperty(Series2.prototype, "legendDataItem", {
      /**
       * @return Data item
       */
      get: function() {
        return this._legendDataItem;
      },
      /**
       * Legend data item that corresponds to this series.
       *
       * @param value  Data item
       */
      set: function(value) {
        this._legendDataItem = value;
        this._legendDataItem.itemContainer.deepInvalidate();
      },
      enumerable: true,
      configurable: true
    });
    Series2.prototype.updateLegendValue = function(dataItem, notRange) {
      if (this.legendDataItem) {
        var legendSettings = this.legendSettings;
        var legendDataItem = this.legendDataItem;
        var label = legendDataItem.label;
        var valueLabel = legendDataItem.valueLabel;
        if (dataItem && !dataItem.isDisposed() || notRange) {
          if (valueLabel) {
            if (legendSettings.itemValueText) {
              valueLabel.text = legendSettings.itemValueText;
            }
            valueLabel.dataItem = dataItem;
          }
          if (label) {
            if (legendSettings.itemLabelText) {
              label.text = legendSettings.itemLabelText;
            }
            label.dataItem = dataItem;
          }
        } else {
          if (label) {
            if (legendSettings.labelText || legendSettings.itemLabelText != void 0) {
              label.text = legendSettings.labelText;
            }
            label.dataItem = this.dataItem;
          }
          if (valueLabel) {
            if (legendSettings.valueText || legendSettings.itemValueText != void 0) {
              valueLabel.text = legendSettings.valueText;
            }
            valueLabel.dataItem = this.dataItem;
          }
        }
      }
    };
    Series2.prototype.copyFrom = function(source) {
      this.bullets.copyFrom(source.bullets);
      this.bulletsContainer.copyFrom(source.bulletsContainer);
      this.calculatePercent = source.calculatePercent;
      this.usePercentHack = source.usePercentHack;
      this.simplifiedProcessing = source.simplifiedProcessing;
      _super.prototype.copyFrom.call(this, source);
    };
    Series2.prototype.raiseCriticalError = function(e) {
      if (this._chart && this._chart.modal) {
        this._chart.modal.content = this._chart.adapter.apply("criticalError", e).message;
        this._chart.modal.closable = false;
        if (!options.suppressErrors) {
          this._chart.modal.open();
        }
        this._chart.disabled = true;
      }
      if (options.verbose) {
        console.log(e);
      }
    };
    Series2.prototype.applyFilters = function() {
      var _this = this;
      _super.prototype.applyFilters.call(this);
      this.bulletsContainer.filters.clear();
      each3(this.filters.iterator(), function(filter) {
        _this.bulletsContainer.filters.push(filter.clone());
      });
    };
    Object.defineProperty(Series2.prototype, "heatRules", {
      /**
       * A list of heat rules to apply to series' elements based on the value
       * of the data item.
       *
       * Heat rules can be any "numeric" (including `Color`) property, and can also
       * be applied to child objects of series, like columns, bullets, etc.
       *
       * E.g.:
       *
       * ```TypeScript
       * series.heatRules.push({
       *  "target": series.columns.template,
       *  "property": "fill",
       *  "min": am4core.color("#F5DBCB"),
       *  "max": am4core.color("#ED7B84"),
       *  "dataField": "valueY"
       *});
       *```
       * ```Javacript
       * series.heatRules.push({
       *  "target": series.columns.template,
       *  "property": "fill",
       *  "min": am4core.color("#F5DBCB"),
       *  "max": am4core.color("#ED7B84"),
       *  "dataField": "valueY"
       *});
       *```
       *```JSON
       *{
       *  // ...
       *  "series": [{
       *    "type": "ColumnSeries",
       *    "heatRules": [{
       *      "target": "columns.template",
       *      "property": "fill",
       *      "min": "#F5DBCB",
       *      "max": "#ED7B84",
       *      "dataField": "valueY"
       *    }]
       *  }]
       *}
       *```
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/series/#Heat_maps} for more about heat rules
       * @return  Heat rules
       */
      get: function() {
        var _this = this;
        if (!this._heatRules) {
          this._heatRules = new List();
          this._heatRules.events.on("inserted", function(event) {
            var heatRule = event.newValue;
            var target = heatRule.target;
            if (target) {
              var dataField_1 = heatRule.dataField;
              if (!hasValue(dataField_1)) {
                dataField_1 = "value";
              }
              var seriesDataItem_1 = _this.dataItem;
              var property_1 = heatRule.property;
              var minValue = toNumber(heatRule.minValue);
              var maxValue = toNumber(heatRule.maxValue);
              if (!isNumber(minValue) && !isNumber(maxValue)) {
                _this.dataItem.events.on("calculatedvaluechanged", function(event2) {
                  if (event2.property == dataField_1) {
                    each3(_this.dataItems.iterator(), function(dataItem) {
                      var foundSprite = false;
                      each(dataItem.sprites, function(sprite) {
                        if (sprite.clonedFrom == target) {
                          var anySprite = sprite;
                          anySprite[property_1] = anySprite[property_1];
                          foundSprite = true;
                        }
                      });
                      if (!foundSprite) {
                        each(dataItem.sprites, function(sprite) {
                          if (sprite instanceof Container) {
                            each3(sprite.children.iterator(), function(child) {
                              if (child.className == target.className) {
                                var anyChild = child;
                                anyChild[property_1] = anyChild[property_1];
                              } else if (child instanceof Container) {
                                child.deepInvalidate();
                              }
                            });
                          }
                        });
                      }
                    });
                  }
                });
              }
              _this.dataItems.template.events.on("workingvaluechanged", function(event2) {
                if (event2.property == dataField_1) {
                  var dataItem = event2.target;
                  var foundSprite_1 = false;
                  each(dataItem.sprites, function(sprite) {
                    if (sprite.clonedFrom == target) {
                      var anySprite = sprite;
                      anySprite[property_1] = anySprite[property_1];
                      foundSprite_1 = true;
                    }
                  });
                  if (!foundSprite_1) {
                    each(dataItem.sprites, function(sprite) {
                      if (sprite instanceof Container) {
                        each3(sprite.children.iterator(), function(child) {
                          if (child.className == target.className) {
                            var anyChild = child;
                            anyChild[property_1] = anyChild[property_1];
                          } else if (child instanceof Container) {
                            child.deepInvalidate();
                          }
                        });
                      }
                    });
                  }
                }
              });
              target.adapter.add(property_1, function(value, ruleTarget, property) {
                var minValue2 = toNumber(heatRule.minValue);
                var maxValue2 = toNumber(heatRule.maxValue);
                var min2 = heatRule.min;
                var max2 = heatRule.max;
                if (ruleTarget instanceof Sprite) {
                  var anySprite = ruleTarget;
                  var propertyField = anySprite.propertyFields[property];
                  if (propertyField && ruleTarget.dataItem) {
                    var dataContext = ruleTarget.dataItem.dataContext;
                    if (dataContext && hasValue(dataContext[propertyField])) {
                      return value;
                    }
                  }
                }
                var dataItem = ruleTarget.dataItem;
                if (!isNumber(minValue2)) {
                  minValue2 = seriesDataItem_1.values[dataField_1].low;
                }
                if (!isNumber(maxValue2)) {
                  maxValue2 = seriesDataItem_1.values[dataField_1].high;
                }
                if (dataItem) {
                  var fieldValues = dataItem.values[dataField_1];
                  if (fieldValues) {
                    var workingValue = dataItem.getActualWorkingValue(dataField_1);
                    if (hasValue(min2) && hasValue(max2) && isNumber(minValue2) && isNumber(maxValue2) && isNumber(workingValue)) {
                      var percent2 = void 0;
                      if (heatRule.logarithmic) {
                        percent2 = (Math.log(workingValue) * Math.LOG10E - Math.log(minValue2) * Math.LOG10E) / (Math.log(maxValue2) * Math.LOG10E - Math.log(minValue2) * Math.LOG10E);
                      } else {
                        percent2 = (workingValue - minValue2) / (maxValue2 - minValue2);
                      }
                      if (isNumber(workingValue) && (!isNumber(percent2) || Math.abs(percent2) == Infinity)) {
                        percent2 = 0.5;
                      }
                      if (isNumber(min2)) {
                        return min2 + (max2 - min2) * percent2;
                      } else if (min2 instanceof Color) {
                        return new Color(interpolate(min2.rgb, max2.rgb, percent2));
                      }
                    }
                  }
                }
                return value;
              });
            }
          });
        }
        return this._heatRules;
      },
      enumerable: true,
      configurable: true
    });
    Series2.prototype.processConfig = function(config) {
      var heatRules;
      if (config) {
        if (hasValue(config.bullets) && isArray(config.bullets)) {
          for (var i = 0, len = config.bullets.length; i < len; i++) {
            var bullets = config.bullets[i];
            if (!hasValue(bullets.type)) {
              bullets.type = "Bullet";
            }
          }
        }
        if (hasValue(config.heatRules) && isArray(config.heatRules)) {
          heatRules = config.heatRules;
          delete config.heatRules;
        }
      }
      _super.prototype.processConfig.call(this, config);
      if (heatRules) {
        for (var i = 0, len = heatRules.length; i < len; i++) {
          var rule = heatRules[i];
          var target = this;
          if (hasValue(rule.target) && isString(rule.target)) {
            if (this.map.hasKey(rule.target)) {
              target = this.map.getKey(rule.target);
            } else {
              var parts = rule.target.split(".");
              for (var x = 0; x < parts.length; x++) {
                if (target instanceof List) {
                  var listitem = target.getIndex(toNumber(parts[x]));
                  if (!listitem) {
                    target = target[parts[x]];
                  } else {
                    target = listitem;
                  }
                } else {
                  var maybeIndex = parts[x].match(/^(.*)\[([0-9]+)\]/);
                  if (maybeIndex) {
                    if (target[maybeIndex[1]] instanceof List) {
                      target = target[maybeIndex[1]].getIndex(toNumber(maybeIndex[2]));
                    } else {
                      target = target[maybeIndex[1]][toNumber(maybeIndex[2])];
                    }
                  } else {
                    target = target[parts[x]];
                  }
                }
              }
            }
          }
          rule.target = target;
          if (hasValue(rule.min)) {
            rule.min = this.maybeColorOrPercent(rule.min);
          }
          if (hasValue(rule.max)) {
            rule.max = this.maybeColorOrPercent(rule.max);
          }
        }
        _super.prototype.processConfig.call(this, {
          heatRules
        });
      }
    };
    Series2.prototype.configOrder = function(a, b) {
      if (a == b) {
        return 0;
      } else if (a == "heatRules") {
        return 1;
      } else if (b == "heatRules") {
        return -1;
      } else {
        return _super.prototype.configOrder.call(this, a, b);
      }
    };
    Series2.prototype.setVisibility = function(value) {
      _super.prototype.setVisibility.call(this, value);
      this.bulletsContainer.visible = value;
    };
    return Series2;
  }(Component)
);
registry.registeredClasses["Series"] = Series;
registry.registeredClasses["SeriesDataItem"] = SeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/types/SerialChart.js
var SerialChartDataItem = (
  /** @class */
  function(_super) {
    __extends(SerialChartDataItem2, _super);
    function SerialChartDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "SerialChartDataItem";
      _this.applyTheme();
      return _this;
    }
    return SerialChartDataItem2;
  }(ChartDataItem)
);
var SerialChart = (
  /** @class */
  function(_super) {
    __extends(SerialChart2, _super);
    function SerialChart2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._exitDP = {};
      _this.className = "SerialChart";
      _this.colors = new ColorSet();
      _this._usesData = false;
      var seriesContainer = _this.chartContainer.createChild(Container);
      seriesContainer.shouldClone = false;
      seriesContainer.width = percent(100);
      seriesContainer.height = percent(100);
      seriesContainer.isMeasured = false;
      seriesContainer.layout = "none";
      seriesContainer.zIndex = 2;
      _this.seriesContainer = seriesContainer;
      var bulletsContainer = _this.chartContainer.createChild(Container);
      bulletsContainer.shouldClone = false;
      bulletsContainer.width = percent(100);
      bulletsContainer.height = percent(100);
      bulletsContainer.isMeasured = false;
      bulletsContainer.zIndex = 3;
      bulletsContainer.layout = "none";
      _this.bulletsContainer = bulletsContainer;
      _this.applyTheme();
      return _this;
    }
    SerialChart2.prototype.dispose = function() {
      _super.prototype.dispose.call(this);
      if (this.colors) {
        this.colors.dispose();
      }
      if (this.patterns) {
        this.patterns.dispose();
      }
    };
    SerialChart2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Serial chart");
      }
    };
    Object.defineProperty(SerialChart2.prototype, "series", {
      /**
       * A list of chart's series.
       *
       * @return Chart's series
       */
      get: function() {
        if (!this._series) {
          this._series = new ListTemplate(this.createSeries());
          this._series.events.on("inserted", this.handleSeriesAdded, this, false);
          this._series.events.on("removed", this.handleSeriesRemoved, this, false);
          this._disposers.push(new ListDisposer(this._series, false));
          this._disposers.push(this._series.template);
        }
        return this._series;
      },
      enumerable: true,
      configurable: true
    });
    SerialChart2.prototype.handleSeriesRemoved = function(event) {
      var series = event.oldValue;
      this.dataUsers.removeValue(series);
      this.dataUsers.each(function(dataUser) {
        dataUser.invalidateDataItems();
      });
      if (this._exitDP[series.uid]) {
        this._exitDP[series.uid].dispose();
        delete this._exitDP[series.uid];
      }
      if (series.autoDispose) {
        series.dispose();
      } else {
        series.parent = void 0;
        series.bulletsContainer.parent = void 0;
      }
      var legend = this.legend;
      if (legend) {
        var dataItems = this.legend.dataItems;
        for (var i = dataItems.length - 1; i >= 0; i--) {
          var dataItem = dataItems.getIndex(i);
          if (dataItem && dataItem.dataContext == series) {
            legend.dataItems.remove(dataItem);
          }
        }
        for (var i = legend.data.length - 1; i >= 0; i--) {
          var di = legend.data[i];
          if (di && di == series) {
            remove(legend.data, di);
          }
        }
      }
    };
    SerialChart2.prototype.handleSeriesAdded = function(event) {
      var _this = this;
      var series = event.newValue;
      if (series.isDisposed()) {
        return;
      }
      series.chart = this;
      series.parent = this.seriesContainer;
      series.bulletsContainer.parent = this.bulletsContainer;
      this._dataUsers.moveValue(series);
      series.addDisposer(new Disposer(function() {
        _this.dataUsers.removeValue(series);
      }));
      this.handleSeriesAdded2(series);
      this.handleLegendSeriesAdded(series);
    };
    SerialChart2.prototype.handleLegendSeriesAdded = function(series) {
      if (!series.hiddenInLegend) {
        if (this.legend) {
          this.legend.addData(series);
        }
      }
    };
    SerialChart2.prototype.handleSeriesAdded2 = function(series) {
      var _this = this;
      if (!this.dataInvalid) {
        this._exitDP[series.uid] = registry.events.once("exitframe", function() {
          if (!series.data || series.data.length == 0) {
            series.data = _this.data;
            if (series.showOnInit) {
              series.reinit();
              series.setPropertyValue("showOnInit", false);
              series.showOnInit = true;
            }
            if (!series.isDisposed()) {
              series.events.once("datavalidated", function() {
                if (series.data == _this.data) {
                  series._data = [];
                }
              });
            }
          }
        });
        this._disposers.push(this._exitDP[series.uid]);
      }
    };
    SerialChart2.prototype.feedLegend = function() {
      var legend = this.legend;
      if (legend) {
        var legendData_1 = [];
        each3(this.series.iterator(), function(series) {
          if (!series.hiddenInLegend) {
            legendData_1.push(series);
          }
        });
        legend.dataFields.name = "name";
        legend.data = legendData_1;
      }
    };
    SerialChart2.prototype.createSeries = function() {
      return new Series();
    };
    Object.defineProperty(SerialChart2.prototype, "colors", {
      /**
       * @return Color list
       */
      get: function() {
        return this.getPropertyValue("colors");
      },
      /**
       * Chart's color list.
       *
       * This list can be used by a number of serial items, like applying a new
       * color for each Series added. Or, applying a new color for each slice
       * of a Pie chart.
       *
       * Please see [[ColorSet]] for information on how you can set up to generate
       * unique colors.
       *
       * A theme you are using may override default pre-defined colors.
       *
       * @param value Color list
       */
      set: function(value) {
        this.setPropertyValue("colors", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(SerialChart2.prototype, "patterns", {
      /**
       * @return Pattern set
       */
      get: function() {
        return this.getPropertyValue("patterns");
      },
      /**
       * A [[PatternSet]] to use when creating patterned fills for slices.
       *
       * @since 4.7.5
       * @param value  Pattern set
       */
      set: function(value) {
        this.setPropertyValue("patterns", value, true);
      },
      enumerable: true,
      configurable: true
    });
    SerialChart2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.series.copyFrom(source.series);
    };
    SerialChart2.prototype.appear = function() {
      _super.prototype.appear.call(this);
      this.series.each(function(series) {
        if (series.showOnInit && series.inited) {
          series.appear();
        }
      });
    };
    return SerialChart2;
  }(Chart)
);
registry.registeredClasses["SerialChart"] = SerialChart;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisBreak.js
var AxisBreak = (
  /** @class */
  function(_super) {
    __extends(AxisBreak2, _super);
    function AxisBreak2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._axis = new MutableValueDisposer();
      _this.dataItems = new List();
      _this.className = "AxisBreak";
      _this.breakSize = 0.01;
      _this.marginLeft = -5;
      _this.marginRight = -5;
      _this.marginTop = -5;
      _this.marginBottom = -5;
      var interfaceColors = new InterfaceColorSet();
      var fillShape = new WavedLine();
      fillShape.fill = interfaceColors.getFor("background");
      fillShape.stroke = color();
      fillShape.fillOpacity = 0.9;
      fillShape.zIndex = 0;
      _this._fillShape = fillShape;
      var startLine = new WavedLine();
      startLine.fill = color();
      startLine.stroke = interfaceColors.getFor("grid");
      startLine.strokeOpacity = 0.3;
      startLine.zIndex = 1;
      _this._startLine = startLine;
      var endLine = new WavedLine();
      endLine.fill = color();
      endLine.stroke = color("#000000");
      endLine.strokeOpacity = 0.3;
      endLine.zIndex = 2;
      _this._endLine = endLine;
      _this._disposers.push(_this._axis);
      _this.applyTheme();
      return _this;
    }
    AxisBreak2.prototype.dispose = function() {
      _super.prototype.dispose.call(this);
      if (this._fillShape) {
        this._fillShape.dispose();
      }
      if (this._startLine) {
        this._startLine.dispose();
      }
      if (this._endLine) {
        this._endLine.dispose();
      }
    };
    Object.defineProperty(AxisBreak2.prototype, "startLine", {
      /**
       * @return Element
       */
      get: function() {
        return this._startLine;
      },
      /**
       * An element used for the starting line of the break.
       *
       * @param sprite  Element
       */
      set: function(sprite) {
        if (this._startLine) {
          this._startLine.dispose();
        }
        this._startLine = sprite;
        this.addBreakSprite(sprite);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisBreak2.prototype, "endLine", {
      /**
       * @return Element
       */
      get: function() {
        return this._endLine;
      },
      /**
       * An element used for the end line of the break.
       *
       * @param sprite Element
       */
      set: function(sprite) {
        if (this._endLine) {
          this._endLine.dispose();
        }
        this._endLine = sprite;
        this.addBreakSprite(sprite);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisBreak2.prototype, "fillShape", {
      /**
       * @return Element
       */
      get: function() {
        return this._fillShape;
      },
      /**
       * An element used for fill of the break.
       *
       * @param sprite Element
       */
      set: function(sprite) {
        if (this._fillShape) {
          this._fillShape.dispose();
        }
        this._fillShape = sprite;
        this.addBreakSprite(sprite);
      },
      enumerable: true,
      configurable: true
    });
    AxisBreak2.prototype.addBreakSprite = function(sprite) {
      sprite.parent = this;
      sprite.isMeasured = false;
      this._disposers.push(sprite);
    };
    Object.defineProperty(AxisBreak2.prototype, "axis", {
      /**
       * @return Axis
       */
      get: function() {
        return this._axis.get();
      },
      /**
       * An Axis this Break is associated with.
       *
       * @param axis  Axis
       */
      set: function(axis) {
        if (this._axis.get() !== axis) {
          this._axis.set(axis, axis.renderer.gridContainer.events.on("transformed", this.invalidate, this, false));
          axis.renderer.createBreakSprites(this);
          var breakTemplate = axis.axisBreaks.template;
          this.startLine.copyFrom(breakTemplate.startLine);
          this.endLine.copyFrom(breakTemplate.endLine);
          this.fillShape.copyFrom(breakTemplate.fillShape);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisBreak2.prototype, "breakSize", {
      /**
       * @return Relative axis break
       */
      get: function() {
        return this.getPropertyValue("breakSize");
      },
      /**
       * A size of the break relative to the actual size of the scope break spans.
       *
       * For example, if `breakSize = 0.1` and unbroken scope of values it spans
       * would be 100 pixels, the break would be 10 pixels wide.
       *
       * 0 means the break will completely collapse and hide the values.
       * 1 means break would be not collapse at all, which would make it
       * effectively useless.
       *
       * @default 0.01
       * @param value  Relative axis break
       */
      set: function(value) {
        if (this.setPropertyValue("breakSize", value)) {
          if (this.axis) {
            this.axis.invalidate();
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisBreak2.prototype, "startPoint", {
      /**
       * Returns pixel coordinates of axis break's start.
       *
       * @return Start point
       */
      get: function() {
        var renderer = this.axis.renderer;
        if (renderer) {
          return renderer.positionToPoint(this.startPosition);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisBreak2.prototype, "endPoint", {
      /**
       * Returns pixel coordinates of axis break's end.
       *
       * @return End point
       */
      get: function() {
        var renderer = this.axis.renderer;
        if (renderer) {
          return renderer.positionToPoint(this.endPosition);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisBreak2.prototype, "startPosition", {
      /**
       * Returns a relative position at which axis break starts.
       *
       * This is a calculated position, meaning it shows relative position of the
       * break after break is applied.
       *
       * @return Start position
       */
      get: function() {
        return;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisBreak2.prototype, "endPosition", {
      /**
       * Returns a relative position at which axis break ends.
       *
       * This is a calculated position, meaning it shows relative position of the
       * break after break is applied.
       *
       * @return End position
       */
      get: function() {
        return;
      },
      enumerable: true,
      configurable: true
    });
    AxisBreak2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      if (this.axis) {
        var renderer = this.axis.renderer;
        renderer.updateBreakElement(this);
      }
    };
    Object.defineProperty(AxisBreak2.prototype, "startValue", {
      /**
       * @return Starting value
       */
      get: function() {
        return this.getPropertyValue("startValue");
      },
      /**
       * A starting value for the break.
       *
       * @param value  Starting value
       */
      set: function(value) {
        if (this.setPropertyValue("startValue", value)) {
          if (this.axis) {
            this.axis.invalidate();
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisBreak2.prototype, "endValue", {
      /**
       * @return End value
       */
      get: function() {
        return this.getPropertyValue("endValue");
      },
      /**
       * An end value for the break.
       *
       * @param value  End value
       */
      set: function(value) {
        if (this.setPropertyValue("endValue", value)) {
          if (this.axis) {
            this.axis.invalidate();
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    return AxisBreak2;
  }(Container)
);
registry.registeredClasses["AxisBreak"] = AxisBreak;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/Axis.js
var AxisDataItem = (
  /** @class */
  function(_super) {
    __extends(AxisDataItem2, _super);
    function AxisDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "AxisDataItem";
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(AxisDataItem2.prototype, "grid", {
      /**
       * @return Grid element
       */
      get: function() {
        if (!this._grid) {
          var component_1 = this.component;
          if (component_1) {
            var template = void 0;
            var grid_1;
            if (this.isRange) {
              template = component_1.axisRanges.template.grid;
              if (template.disabled) {
                return;
              } else {
                grid_1 = template.clone();
              }
            } else {
              template = component_1.renderer.grid.template;
              if (template.disabled) {
                return;
              } else {
                grid_1 = component_1.renderer.grid.create();
                this._disposers.push(new Disposer(function() {
                  component_1.renderer.grid.removeValue(grid_1);
                }));
              }
            }
            this.grid = grid_1;
            grid_1.shouldClone = false;
            this._disposers.push(grid_1);
            grid_1.axis = this.component;
          }
        }
        return this._grid;
      },
      /**
       * A [[Grid]] element associated with this data item.
       *
       * If there is no grid element associated with data item, a new one is
       * created and returned.
       *
       * @param grid  Grid element
       */
      set: function(grid) {
        if (this._grid && this._grid != grid) {
          remove(this.sprites, this._grid);
          this._grid.dataItem = void 0;
        }
        if (grid) {
          if (grid.dataItem && grid.dataItem != this) {
            remove(grid.dataItem.sprites, grid);
            grid.dataItem.grid = void 0;
          }
          this.addSprite(grid);
        }
        this._grid = grid;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisDataItem2.prototype, "tick", {
      /**
       * @return Tick element
       */
      get: function() {
        if (!this._tick) {
          var component_2 = this.component;
          if (component_2) {
            var template = void 0;
            var tick_1;
            if (this.isRange) {
              template = component_2.axisRanges.template.tick;
              if (template.disabled) {
                return;
              } else {
                tick_1 = template.clone();
              }
            } else {
              template = component_2.renderer.ticks.template;
              if (template.disabled) {
                return;
              } else {
                tick_1 = component_2.renderer.ticks.create();
                this._disposers.push(new Disposer(function() {
                  component_2.renderer.ticks.removeValue(tick_1);
                }));
              }
            }
            this.tick = tick_1;
            tick_1.axis = this.component;
            tick_1.shouldClone = false;
            this._disposers.push(tick_1);
          }
        }
        return this._tick;
      },
      /**
       * An [[AxisTick]] element associated with this data item.
       *
       * If there is no tick element associated with data item, a new one is
       * created and returned.
       *
       * @param tick  Tick element
       */
      set: function(tick) {
        if (this._tick && this._tick != tick) {
          remove(this.sprites, this._tick);
          this._tick.dataItem = void 0;
        }
        if (tick) {
          if (tick.dataItem && tick.dataItem != this) {
            remove(tick.dataItem.sprites, tick);
            tick.dataItem.tick = void 0;
          }
          this.addSprite(tick);
        }
        this._tick = tick;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisDataItem2.prototype, "label", {
      /**
       * @return Label element
       */
      get: function() {
        if (!this._label) {
          var component_3 = this.component;
          if (component_3) {
            var template = void 0;
            var label_1;
            if (this.isRange) {
              template = component_3.axisRanges.template.label;
              if (template.disabled) {
                return;
              } else {
                label_1 = template.clone();
              }
            } else {
              template = component_3.renderer.labels.template;
              if (template.disabled) {
                return;
              } else {
                label_1 = component_3.renderer.labels.create();
                this._disposers.push(new Disposer(function() {
                  component_3.renderer.labels.removeValue(label_1);
                }));
              }
            }
            this._disposers.push(label_1);
            this.label = label_1;
            label_1.shouldClone = false;
            label_1.axis = this.component;
            label_1.virtualParent = component_3;
          }
        }
        return this._label;
      },
      /**
       * An [[AxisLabel]] element associated with this data item.
       *
       * If there is no label element associated with data item, a new one is
       * created and returned.
       *
       * @param label Label element
       */
      set: function(label) {
        if (this._label && this._label != label) {
          remove(this.sprites, this._label);
          this._label.dataItem = void 0;
        }
        if (label) {
          if (label.dataItem && label.dataItem != this) {
            remove(label.dataItem.sprites, label);
            label.dataItem.label = void 0;
          }
          this.addSprite(label);
        }
        this._label = label;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisDataItem2.prototype, "axisFill", {
      /**
       * @return Label element
       */
      get: function() {
        if (!this._axisFill) {
          var component_4 = this.component;
          if (component_4) {
            var template = void 0;
            var axisFill_1;
            if (this.isRange) {
              template = component_4.axisRanges.template.axisFill;
              if (!this.isTemplate && template.disabled) {
                return;
              } else {
                axisFill_1 = template.clone();
              }
            } else {
              template = component_4.renderer.axisFills.template;
              if (template.disabled) {
                return;
              } else {
                axisFill_1 = component_4.renderer.axisFills.create();
                this._disposers.push(new Disposer(function() {
                  component_4.renderer.axisFills.removeValue(axisFill_1);
                }));
              }
            }
            this.axisFill = axisFill_1;
            axisFill_1.shouldClone = false;
            this._disposers.push(axisFill_1);
          }
        }
        return this._axisFill;
      },
      /**
       * An [[AxisFill]] associated element with this data item.
       *
       * If there is no fill element associated with data item, a new one is
       * created and returned.
       *
       * @param label Label element
       */
      set: function(axisFill) {
        if (this._axisFill && this._axisFill != axisFill) {
          remove(this.sprites, this._axisFill);
          this._axisFill.dataItem = void 0;
        }
        if (axisFill) {
          if (axisFill.dataItem && axisFill.dataItem != this) {
            remove(axisFill.dataItem.sprites, axisFill);
            axisFill.dataItem.axisFill = void 0;
          }
          axisFill.axis = this.component;
          this.addSprite(axisFill);
        }
        this._axisFill = axisFill;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisDataItem2.prototype, "text", {
      /**
       * @return Text label
       */
      get: function() {
        return this._text;
      },
      /**
       * Text to be used as data item's label.
       *
       * @param text Text label
       */
      set: function(text) {
        this._text = text;
        if (this._label) {
          this._label.text = text;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisDataItem2.prototype, "mask", {
      /**
       * Data item's mask.
       *
       * @return Mask
       */
      get: function() {
        return this._mask;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisDataItem2.prototype, "contents", {
      /**
       * Returns a [[Container]] to place all visual elements, related to data item
       * in.
       *
       * If there is no Container, a new one is created.
       *
       * @return Contents container
       */
      get: function() {
        if (!this._contents) {
          var contents = new Container();
          this.addSprite(contents);
          contents.isMeasured = false;
          this._contents = contents;
          var component = this.component;
          if (component) {
            var mask = component.renderer.createFill(this.component);
            mask.disabled = false;
            mask.axis = component;
            this.addSprite(mask);
            this._mask = mask;
            contents.mask = mask;
          }
        }
        return this._contents;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisDataItem2.prototype, "axisBreak", {
      /**
       * @return Axis break
       */
      get: function() {
        return this._axisBreak;
      },
      /**
       * An [[AxisBreak]] this data item falls within.
       *
       * @param axisBreak Axis break
       */
      set: function(axisBreak) {
        if (this._axisBreak) {
          this._axisBreak.dataItems.removeValue(this);
        }
        if (axisBreak) {
          axisBreak.dataItems.push(this);
        }
        this._axisBreak = axisBreak;
      },
      enumerable: true,
      configurable: true
    });
    AxisDataItem2.prototype.validate = function() {
      if (this.component) {
        this.component.validateDataElement(this);
      }
    };
    AxisDataItem2.prototype.appendChildren = function() {
      if (this.component) {
        this.component.appendDataItem(this);
      }
    };
    AxisDataItem2.prototype.hasProperty = function(prop) {
      return prop == "component" ? true : _super.prototype.hasProperty.call(this, prop);
    };
    AxisDataItem2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.text = source.text;
      if (source.bullet) {
        this.bullet = source.bullet.clone();
      }
      this.minPosition = source.minPosition;
      this.maxPosition = source.maxPosition;
    };
    AxisDataItem2.prototype.setVisibility = function(value, noChangeValues) {
      _super.prototype.setVisibility.call(this, value, noChangeValues);
      if (this._contents) {
        this._contents.visible = value;
      }
    };
    Object.defineProperty(AxisDataItem2.prototype, "bullet", {
      /**
       * @return Bullet
       */
      get: function() {
        return this._bullet;
      },
      /**
       * Set it to an instance of any [[Sprite]]. It will be displayed as an axis
       * bullet in the middle of the cell, or specific value.
       *
       * If you need position bullet relatively to the cell, use [[AxisBullet]]
       * instead. It has a `location` property which can be used to indicate
       * precise relative location within cell/range.
       *
       * Also, [[AxisBullet]] is a [[Container]] so you can push any other element
       * into it.
       *
       * NOTE: `location` is relative to the parent axis range's scope, i.e.
       * between its `date` and `endDate` for [[DateAxis]], or `value`/`endValue`
       * ([[ValueAxis]]), or `category`/`endCategory` ([[categoryAxis]]).
       *
       * ```TypeScript
       * let range = dateAxis.axisRanges.create();
       * range.date = new Date(2018, 0, 5);
       *
       * let flag = new am4plugins_bullets.FlagBullet();
       * flag.label.text = "Hello";
       *
       * range.bullet = flag;
       * ```
       * ```JavaScript
       * var range = dateAxis.axisRanges.create();
       * range.date = new Date(2018, 0, 5);
       *
       * var flag = new am4plugins_bullets.FlagBullet();
       * flag.label.text = "Hello";
       *
       * range.bullet = flag;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "xAxes": [{
       *     "type": "DateAxis",
       *     // ...
       *     "axisRanges": [{
       *       "date": new Date(2018, 0, 5),
       *       "bullet: {
       *         "type": "FlagBullet",
       *         "label": {
       *           "text": "Hello"
       *         }
       *       }
       *     }]
       *   }]
       * }
       * ```
       *
       * @since 4.5.9
       * @param  value  Bullet
       */
      set: function(value) {
        if (this._bullet && this._bullet != value) {
          remove(this.sprites, this._bullet);
          this._bullet.dataItem = void 0;
        }
        this._bullet = value;
        if (value) {
          this.addSprite(value);
        }
      },
      enumerable: true,
      configurable: true
    });
    return AxisDataItem2;
  }(DataItem)
);
var AxisItemLocation;
(function(AxisItemLocation2) {
  AxisItemLocation2[AxisItemLocation2["Start"] = 0] = "Start";
  AxisItemLocation2[AxisItemLocation2["Middle"] = 0.5] = "Middle";
  AxisItemLocation2[AxisItemLocation2["End"] = 1] = "End";
})(AxisItemLocation || (AxisItemLocation = {}));
var Axis = (
  /** @class */
  function(_super) {
    __extends(Axis2, _super);
    function Axis2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._gridCount = 10;
      _this._series = new List();
      _this.autoDispose = true;
      _this._axisItemCount = 0;
      if (_this.constructor === Axis2) {
        throw new Error("'Axis' cannot be instantiated directly. Please use a specific axis type.");
      }
      _this.hideTooltipWhileZooming = true;
      _this.minWidth = 1e-4;
      _this.minHeight = 1e-4;
      _this.className = "Axis";
      _this.shouldClone = false;
      _this.setPropertyValue("cursorTooltipEnabled", true);
      _this.toggleZoomOutButton = true;
      _this.zoomable = true;
      var interfaceColors = new InterfaceColorSet();
      _this.title = new Label();
      _this.title.shouldClone = false;
      _this._disposers.push(_this.title);
      _this.setPropertyValue("startLocation", 0);
      _this.setPropertyValue("endLocation", 1);
      _this._dataItemsIterator = new ListIterator(_this.dataItems, function() {
        return _this.dataItems.create();
      });
      _this._dataItemsIterator.createNewItems = true;
      var tooltip = new Tooltip();
      _this._disposers.push(tooltip);
      tooltip.label.padding(5, 10, 5, 10);
      tooltip.background.pointerLength = 5;
      tooltip.fitPointerToBounds = true;
      tooltip.background.filters.clear();
      tooltip.virtualParent = _this;
      var background = tooltip.background;
      background.cornerRadius = 0;
      background.fill = interfaceColors.getFor("alternativeBackground");
      background.stroke = background.fill;
      background.strokeWidth = 1;
      background.fillOpacity = 1;
      tooltip.label.fill = interfaceColors.getFor("alternativeText");
      _this.tooltip = tooltip;
      _this.readerHidden = true;
      _this.events.on("rangechangestarted", function() {
        _this.series.each(function(series) {
          if (series.hideTooltipWhileZooming) {
            series.tooltip.hide();
            series.tooltip.preventShow = true;
          }
        });
        if (_this.hideTooltipWhileZooming) {
          _this.tooltip.hide();
          _this.tooltip.preventShow = true;
        }
      }, void 0, false);
      _this.events.on("rangechangeended", function() {
        _this.series.each(function(series) {
          if (series.hideTooltipWhileZooming) {
            series.tooltip.hide();
            series.tooltip.preventShow = false;
          }
        });
        if (_this.hideTooltipWhileZooming) {
          _this.tooltip.hide();
          _this.tooltip.preventShow = false;
        }
      }, void 0, false);
      _this.applyTheme();
      return _this;
    }
    Axis2.prototype.fillRule = function(dataItem, index) {
      if (!isNumber(index)) {
        index = dataItem.index;
      }
      if (index / 2 == Math.round(index / 2)) {
        dataItem.axisFill.__disabled = true;
        dataItem.axisFill.opacity = 0;
      } else {
        dataItem.axisFill.opacity = 1;
        dataItem.axisFill.__disabled = false;
      }
    };
    Axis2.prototype.createDataItem = function() {
      return new AxisDataItem();
    };
    Axis2.prototype.invalidateLayout = function() {
      _super.prototype.invalidateLayout.call(this);
      each3(this.series.iterator(), function(series) {
        series.invalidateLayout();
      });
    };
    Axis2.prototype.invalidateSeries = function() {
      each3(this.series.iterator(), function(series) {
        series.invalidate();
      });
    };
    Axis2.prototype.validateDataElements = function() {
      this._axisItemCount = 0;
      if (this.ghostLabel) {
        this.renderer.updateLabelElement(this.ghostLabel, this.start, this.end);
        this.ghostLabel.validate();
      }
    };
    Axis2.prototype.updateGridCount = function() {
      if (this.renderer) {
        var gridCount = this.axisLength / this.renderer.minGridDistance;
        if (gridCount != this._gridCount) {
          this._gridCount = gridCount;
          this.clearCache();
        }
      }
    };
    Axis2.prototype.validateLayout = function() {
      this.axisFullLength = this.axisLength / (this.end - this.start);
      _super.prototype.validateLayout.call(this);
      this.updateGridCount();
      var renderer = this.renderer;
      if (renderer) {
        renderer.updateAxisLine();
        renderer.updateTooltip();
        renderer.updateBaseGridElement();
      }
      if (this._prevLength != this.axisLength) {
        this.dispatchImmediately("lengthchanged");
        this._prevLength = this.axisLength;
      }
    };
    Axis2.prototype.initRenderer = function() {
    };
    Axis2.prototype.appendDataItem = function(dataItem) {
      var renderer = this.renderer;
      var tick = dataItem.tick;
      if (tick) {
        if (tick.above) {
          tick.parent = renderer.bulletsContainer;
        } else {
          tick.parent = renderer.gridContainer;
        }
      }
      if (dataItem.label) {
        dataItem.label.parent = renderer;
      }
      var axisFill = dataItem.axisFill;
      if (axisFill) {
        if (axisFill.above) {
          axisFill.parent = renderer.bulletsContainer;
        } else {
          axisFill.parent = renderer.gridContainer;
        }
      }
      var grid = dataItem.grid;
      if (grid) {
        if (grid.above) {
          grid.parent = renderer.bulletsContainer;
        } else {
          grid.parent = renderer.gridContainer;
        }
      }
      if (dataItem.bullet) {
        dataItem.bullet.parent = renderer.bulletsContainer;
      }
    };
    Axis2.prototype.validate = function() {
      _super.prototype.validate.call(this);
      this.validateLayout();
      this.renderer.updateGridContainer();
    };
    Axis2.prototype.validateAxisRanges = function() {
      var _this = this;
      each3(this.axisRanges.iterator(), function(axisRange) {
        _this.appendDataItem(axisRange);
        _this.validateDataElement(axisRange);
        if (axisRange.grid) {
          axisRange.grid.validate();
        }
        if (axisRange.tick) {
          axisRange.tick.validate();
        }
        if (axisRange.axisFill) {
          axisRange.axisFill.validate();
        }
        if (axisRange.label) {
          axisRange.label.validate();
        }
      });
    };
    Axis2.prototype.validateBreaks = function() {
      if (this._axisBreaks) {
        each3(this._axisBreaks.iterator(), function(axisBreak) {
          axisBreak.invalidate();
        });
      }
    };
    Axis2.prototype.processBreak = function(event) {
      var axisBreak = event.newValue;
      axisBreak.parent = this.renderer.breakContainer;
      axisBreak.axis = this;
    };
    Axis2.prototype.registerSeries = function(series) {
      var _this = this;
      this.series.moveValue(series);
      return new MultiDisposer([
        new Disposer(function() {
          _this.series.removeValue(series);
        }),
        this.events.on("lengthchanged", series.invalidate, series, false),
        this.events.on("lengthchanged", series.createMask, series, false),
        this.events.on("startchanged", series.invalidate, series, false),
        this.events.on("endchanged", series.invalidate, series, false)
      ]);
    };
    Object.defineProperty(Axis2.prototype, "renderer", {
      /**
       * @return Renderer
       */
      get: function() {
        return this._renderer;
      },
      /**
       * An [[AxisRenderer]] to be used to render this Axis.
       *
       * Please note that most of the settings, related to Axis' appearance are set
       * via its renderer. Not directly on the Axis.
       *
       * E.g.:
       *
       * ```TypeScript
       * axis.renderer.inside = true;
       * axis.renderer.minLabelPosition = 0.1;
       * axis.renderer.maxLabelPosition = 0.9;
       * ```
       * ```JavaScript
       * axis.renderer.inside = true;
       * axis.renderer.minLabelPosition = 0.1;
       * axis.renderer.maxLabelPosition = 0.9;
       * ```
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/} for more info
       * @param renderer  Renderer
       */
      set: function(renderer) {
        if (renderer != this._renderer) {
          this._renderer = renderer;
          renderer.chart = this.chart;
          renderer.axis = this;
          renderer.parent = this;
          this.title.parent = this;
          this.initRenderer();
          this._disposers.push(renderer.gridContainer.events.on("maxsizechanged", this.invalidate, this, false));
          var ghostLabel_1 = this.renderer.labels.create();
          this._disposers.push(ghostLabel_1);
          ghostLabel_1.dataItem = this.dataItems.template.clone();
          ghostLabel_1.text = "L";
          ghostLabel_1.parent = this.renderer;
          ghostLabel_1.shouldClone = false;
          ghostLabel_1.fillOpacity = 0;
          ghostLabel_1.opacity = 0;
          ghostLabel_1.strokeOpacity = 0;
          ghostLabel_1.interactionsEnabled = false;
          ghostLabel_1.validate();
          this.ghostLabel = ghostLabel_1;
          this.events.on("beforedatavalidated", function() {
            ghostLabel_1.text = "L";
          }, void 0, false);
        }
      },
      enumerable: true,
      configurable: true
    });
    Axis2.prototype.positionToAngle = function(position) {
      return this.renderer.positionToAngle(position);
    };
    Axis2.prototype.pointToPosition = function(point) {
      return this.renderer.pointToPosition(point);
    };
    Axis2.prototype.positionToCoordinate = function(position) {
      return this.renderer.positionToCoordinate(position);
    };
    Axis2.prototype.getAnyRangePath = function(start, end) {
      return this.renderer.getPositionRangePath(start, end);
    };
    Axis2.prototype.anyToPosition = function(value) {
      return 0;
    };
    Axis2.prototype.anyToPoint = function(value) {
      return { x: 0, y: 0, angle: 0 };
    };
    Axis2.prototype.getPositionRangePath = function(startPosition, endPosition) {
      if (this.renderer) {
        return this.renderer.getPositionRangePath(startPosition, endPosition);
      }
      return "";
    };
    Object.defineProperty(Axis2.prototype, "axisLength", {
      /**
       * Actual axis length in pixels.
       *
       * @return Axis length (px)
       */
      get: function() {
        if (this.renderer) {
          return this.renderer.axisLength;
        }
        return 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Axis2.prototype, "cursorTooltipEnabled", {
      /**
       * @return Display tooltip?
       */
      get: function() {
        return this.getPropertyValue("cursorTooltipEnabled");
      },
      /**
       * Indicates if axis should display a tooltip for chart's cursor.
       *
       * @param value Display tooltip?
       */
      set: function(value) {
        if (this.setPropertyValue("cursorTooltipEnabled", value)) {
          if (value && this.renderer) {
            this.renderer.updateTooltip();
          } else if (this.tooltip) {
            this.tooltip.hide(0);
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Axis2.prototype, "toggleZoomOutButton", {
      /**
       * @return Toggle zoom out button?
       */
      get: function() {
        return this.getPropertyValue("toggleZoomOutButton");
      },
      /**
       * Normally, when axis is zoomed in, a zoom out button is shown by a chart,
       * and vice versa: when axis is zoomed out completely, zoom out button is
       * hidden.
       *
       * Setting this to `false` will disable this behavior. Zooming in our out
       * this axis will not reveal or hide zoom out button.
       *
       * @default true
       * @since 4.6.2
       * @param  value  Toggle zoom out button?
       */
      set: function(value) {
        this.setPropertyValue("toggleZoomOutButton", value);
      },
      enumerable: true,
      configurable: true
    });
    Axis2.prototype.hideTooltip = function(duration) {
      _super.prototype.hideTooltip.call(this, duration);
      this._tooltipPosition = void 0;
    };
    Axis2.prototype.showTooltipAtPosition = function(position, local) {
      var tooltip = this._tooltip;
      if (!tooltip || this.dataItems.length <= 0) {
        this._tooltipPosition = void 0;
      } else {
        if (!local) {
          position = this.toAxisPosition(position);
        }
        if (!isNumber(position) || position < this.start || position > this.end) {
          tooltip.hide(0);
          this._tooltipPosition = void 0;
          return;
        }
        var renderer = this.renderer;
        if (!tooltip.parent) {
          tooltip.parent = this.tooltipContainer;
        }
        var tooltipLocation = renderer.tooltipLocation;
        var startPosition = this.getCellStartPosition(position);
        var endPosition = this.getCellEndPosition(position);
        if (this.tooltipPosition == "fixed") {
          position = startPosition + (endPosition - startPosition) * tooltipLocation;
        }
        position = fitToRange(position, this.start, this.end);
        if (this._tooltipPosition != position) {
          this._tooltipPosition = position;
          var tooltipLocation2 = renderer.tooltipLocation2;
          var startPoint = renderer.positionToPoint(startPosition, tooltipLocation2);
          var endPoint = renderer.positionToPoint(endPosition, tooltipLocation2);
          this.currentItemStartPoint = startPoint;
          this.currentItemEndPoint = endPoint;
          if (renderer.fullWidthTooltip) {
            tooltip.width = endPoint.x - startPoint.x;
            tooltip.height = endPoint.y - startPoint.y;
          }
          var point = renderer.positionToPoint(position, tooltipLocation2);
          var globalPoint = spritePointToSvg(point, this.renderer.line);
          tooltip.text = this.getTooltipText(position);
          if (tooltip.text) {
            tooltip.delayedPointTo(globalPoint);
            tooltip.show();
          }
        }
        if (!this.cursorTooltipEnabled || this.tooltip.disabled) {
          tooltip.hide(0);
        }
      }
    };
    Axis2.prototype.toAxisPosition = function(position) {
      position = this.renderer.toAxisPosition(position);
      if (position == void 0) {
        return;
      }
      position = position * (this.end - this.start);
      if (this.renderer.inversed) {
        position = this.end - position;
      } else {
        position = this.start + position;
      }
      return position;
    };
    Axis2.prototype.toGlobalPosition = function(position) {
      if (this.renderer.inversed) {
        position = this.end - position;
      } else {
        position = position - this.start;
      }
      return position / (this.end - this.start);
    };
    Axis2.prototype.getTooltipText = function(position) {
      return;
    };
    Axis2.prototype.updateTooltip = function(pointerOrientation, boundingRectangle) {
      var tooltip = this._tooltip;
      if (tooltip) {
        tooltip.fixDoc = false;
        tooltip.pointerOrientation = pointerOrientation;
        tooltip.setBounds(spriteRectToSvg(boundingRectangle, this.renderer.line));
      }
    };
    Axis2.prototype.roundPosition = function(position, location, axisLocation) {
      return position;
    };
    Axis2.prototype.getCellStartPosition = function(position) {
      return position;
    };
    Axis2.prototype.getCellEndPosition = function(position) {
      return position;
    };
    Object.defineProperty(Axis2.prototype, "axisRanges", {
      /**
       * A list of axis ranges for this Axis.
       *
       * @return Axis ranges
       */
      get: function() {
        if (!this._axisRanges) {
          var dataItem = this.createDataItem();
          dataItem.isRange = true;
          dataItem.axisFill = this.renderer.axisFills.template.clone();
          dataItem.grid = this.renderer.grid.template.clone();
          dataItem.tick = this.renderer.ticks.template.clone();
          dataItem.label = this.renderer.labels.template.clone();
          dataItem.isTemplate = true;
          dataItem.component = this;
          dataItem.axisFill.disabled = false;
          dataItem.tick.disabled = false;
          dataItem.grid.disabled = false;
          dataItem.label.disabled = false;
          this._axisRanges = new ListTemplate(dataItem);
          this._axisRanges.events.on("inserted", this.processAxisRange, this, false);
          this._disposers.push(new ListDisposer(this._axisRanges));
          this._disposers.push(this._axisRanges.template);
        }
        return this._axisRanges;
      },
      enumerable: true,
      configurable: true
    });
    Axis2.prototype.processAxisRange = function(event) {
      var axisRange = event.newValue;
      axisRange.component = this;
      axisRange.isRange = true;
    };
    Object.defineProperty(Axis2.prototype, "axisBreaks", {
      /**
       * A list of axis breaks on this Axis.
       *
       * @return Axis breaks.
       */
      get: function() {
        if (!this._axisBreaks) {
          this._axisBreaks = new SortedListTemplate(this.createAxisBreak(), function(a, b) {
            return order2(a.adjustedStartValue, b.adjustedStartValue);
          });
          this._axisBreaks.events.on("inserted", this.processBreak, this, false);
          this._disposers.push(new ListDisposer(this._axisBreaks));
          this._disposers.push(this._axisBreaks.template);
        }
        return this._axisBreaks;
      },
      enumerable: true,
      configurable: true
    });
    Axis2.prototype.createAxisBreak = function() {
      return new AxisBreak();
    };
    Object.defineProperty(Axis2.prototype, "series", {
      /**
       * A list of Series currently associated with this Axis.
       *
       * @return Series
       */
      get: function() {
        if (!this._series) {
          this._series = new List();
        }
        return this._series;
      },
      enumerable: true,
      configurable: true
    });
    Axis2.prototype.processSeriesDataItems = function() {
    };
    Axis2.prototype.processSeriesDataItem = function(dataItem, axisLetter) {
    };
    Axis2.prototype.postProcessSeriesDataItems = function(series) {
    };
    Axis2.prototype.postProcessSeriesDataItem = function(dataItem) {
    };
    Axis2.prototype.updateAxisBySeries = function() {
    };
    Axis2.prototype.hideUnusedDataItems = function() {
      var _this = this;
      var dataItemsIterator = this._dataItemsIterator;
      dataItemsIterator.createNewItems = false;
      each3(dataItemsIterator.iterator(), function(dataItem) {
        _this.validateDataElement(dataItem);
        dataItem.__disabled = true;
      });
      dataItemsIterator.clear();
      dataItemsIterator.createNewItems = true;
    };
    Axis2.prototype.getSeriesDataItem = function(series, position, findNearest) {
      return;
    };
    Axis2.prototype.getAngle = function(dataItem, key, location, stackKey, range) {
      return;
    };
    Axis2.prototype.getX = function(dataItem, key, location, stackKey, range) {
      return;
    };
    Axis2.prototype.getPositionX = function(dataItem, key, location, stackKey, range) {
      return;
    };
    Axis2.prototype.getY = function(dataItem, key, location, stackKey, range) {
      return;
    };
    Axis2.prototype.getPositionY = function(dataItem, key, location, stackKey, range) {
      return;
    };
    Object.defineProperty(Axis2.prototype, "basePoint", {
      /**
       * Coordinates of the actual axis start.
       *
       * @ignore Exclude from docs
       * @return Base point coordinates
       */
      get: function() {
        return { x: 0, y: 0 };
      },
      enumerable: true,
      configurable: true
    });
    Axis2.prototype.dataChangeUpdate = function() {
    };
    Axis2.prototype.seriesDataChangeUpdate = function(series) {
    };
    Axis2.prototype.adjustDifference = function(min2, max2) {
      var difference = max2 - min2;
      if (isNumber(difference)) {
        if (this._axisBreaks) {
          eachContinue2(this._axisBreaks.iterator(), function(axisBreak) {
            var startValue = axisBreak.adjustedStartValue;
            var endValue = axisBreak.adjustedEndValue;
            if (isNumber(startValue) && isNumber(endValue)) {
              if (startValue > max2) {
                return false;
              }
              if (endValue >= min2) {
                if (isNumber(startValue) && isNumber(endValue)) {
                  var breakSize = axisBreak.breakSize;
                  var intersection2 = intersection({ start: startValue, end: endValue }, { start: min2, end: max2 });
                  if (intersection2) {
                    difference -= (intersection2.end - intersection2.start) * (1 - breakSize);
                  }
                }
              }
              return true;
            }
          });
        }
        return difference;
      }
    };
    Axis2.prototype.isInBreak = function(value) {
      if (this._axisBreaks) {
        return find(this._axisBreaks.iterator(), function(axisBreak) {
          return value >= axisBreak.adjustedStartValue && value <= axisBreak.adjustedEndValue;
        });
      }
    };
    Axis2.prototype.fixAxisBreaks = function() {
      var _this = this;
      if (this._axisBreaks) {
        var axisBreaks = this._axisBreaks;
        if (axisBreaks.length > 0) {
          each(toArray(axisBreaks.iterator()), function(axisBreak) {
            var startValue = min(axisBreak.startValue, axisBreak.endValue);
            var endValue = max(axisBreak.startValue, axisBreak.endValue);
            axisBreak.adjustedStartValue = startValue;
            axisBreak.adjustedEndValue = endValue;
            _this._axisBreaks.update(axisBreak);
          });
          var firstAxisBreak = axisBreaks.first;
          var previousEndValue_1 = Math.min(firstAxisBreak.startValue, firstAxisBreak.endValue);
          each3(axisBreaks.iterator(), function(axisBreak) {
            var startValue = axisBreak.adjustedStartValue;
            var endValue = axisBreak.adjustedEndValue;
            if (startValue < previousEndValue_1) {
              startValue = previousEndValue_1;
              if (endValue < previousEndValue_1) {
                endValue = previousEndValue_1;
              }
            }
            axisBreak.adjustedStartValue = startValue;
            axisBreak.adjustedEndValue = endValue;
          });
        }
      }
    };
    Object.defineProperty(Axis2.prototype, "startIndex", {
      /**
       * @ignore Exclude from docs
       * @return [description]
       */
      get: function() {
        return 0;
      },
      /**
       * We need start/end indexes of axes to be 0 - `dataItems.length`.
       *
       * Yes, also for category axis, this helps to avoid jumping of categories
       * while scrolling and does not do a lot of extra work as we use
       * protected `_startIndex` and `_endIndex` when working with items.
       *
       * @hidden
       */
      /**
       * [startIndex description]
       *
       * @ignore Exclude from docs
       * @todo Description
       * @param value [description]
       */
      set: function(value) {
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Axis2.prototype, "endIndex", {
      /**
       * @ignore Exclude from docs
       * @return [description]
       */
      get: function() {
        return this.dataItems.length;
      },
      /**
       * [endIndex description]
       *
       * @ignore Exclude from docs
       * @todo Description
       * @param value [description]
       */
      set: function(value) {
      },
      enumerable: true,
      configurable: true
    });
    Axis2.prototype.getPositionLabel = function(position) {
      return Math.round(position * 100) + "%x";
    };
    Object.defineProperty(Axis2.prototype, "chart", {
      /**
       * @return Chart
       */
      get: function() {
        return this._chart;
      },
      /**
       * A Chart this Axis belongs to.
       *
       * @param value  Chart
       */
      set: function(value) {
        this._chart = value;
      },
      enumerable: true,
      configurable: true
    });
    Axis2.prototype.createSeriesRange = function(series) {
      var range = this.axisRanges.create();
      range.component = this;
      range.axisFill = this.renderer.axisFills.template.clone();
      range.axisFill.disabled = false;
      range.axisFill.fillOpacity = 0;
      range.grid = this.renderer.grid.template.clone();
      range.grid.disabled = true;
      range.tick = this.renderer.ticks.template.clone();
      range.tick.disabled = true;
      range.label = this.renderer.labels.template.clone();
      range.label.disabled = true;
      range.addDisposer(new Disposer(function() {
        series.axisRanges.removeValue(range);
      }));
      series.axisRanges.push(range);
      return range;
    };
    Axis2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      if (this.renderer) {
        this.renderer.copyFrom(source.renderer);
      } else {
        if (source.renderer) {
          this.renderer = source.renderer.clone();
          this._disposers.push(this.renderer);
        }
      }
      if (source.title) {
        if (!this.title) {
          this.title = source.title.clone();
          this.title.parent = this;
        } else {
          this.title.copyFrom(source.title);
        }
        this._disposers.push(this.title);
      }
    };
    Axis2.prototype.resetIterators = function() {
      this._dataItemsIterator.reset();
    };
    Axis2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config.axisRanges) && isArray(config.axisRanges)) {
          for (var i = 0, len = config.axisRanges.length; i < len; i++) {
            var range = config.axisRanges[i];
            if (hasValue(range["series"])) {
              if (isString(range["series"])) {
                if (this.map.hasKey(range["series"])) {
                  config.axisRanges[i] = this.createSeriesRange(this.map.getKey(range["series"]));
                  delete range["series"];
                  config.axisRanges[i].config = range;
                }
              }
            }
          }
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    Axis2.prototype.configOrder = function(a, b) {
      if (a == b) {
        return 0;
      } else if (a == "title") {
        return 1;
      } else if (b == "title") {
        return -1;
      } else if (a == "component") {
        return -1;
      } else if (b == "component") {
        return 1;
      } else {
        return _super.prototype.configOrder.call(this, a, b);
      }
    };
    Object.defineProperty(Axis2.prototype, "startLocation", {
      /**
       * @return Location (0-1)
       */
      get: function() {
        return this.getPropertyValue("startLocation");
      },
      /**
       * Axis start location. Works on Date/Category axis, doesn't work on Value axis.
       *
       * * 0 - Full first cell is shown.
       * * 0.5 - Half of first cell is shown.
       * * 1 - None of the first cell is visible. (you probably don't want that)
       *
       * @param value Location (0-1)
       */
      set: function(value) {
        this.setPropertyValue("startLocation", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Axis2.prototype, "endLocation", {
      /**
       * @return Location (0-1)
       */
      get: function() {
        return this.getPropertyValue("endLocation");
      },
      /**
       * Axis end location. Works on Date/Category axis, doesn't work on Value axis.
       *
       * * 0 - None of the last cell is shown. (don't do that)
       * * 0.5 - Half of the last cell is shown.
       * * 1 - Full last cell is shown.
       *
       * @param value Location (0-1)
       */
      set: function(value) {
        this.setPropertyValue("endLocation", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Axis2.prototype.setDisabled = function(value) {
      var changed = _super.prototype.setDisabled.call(this, value);
      if (this.renderer) {
        this.renderer.gridContainer.disabled = value;
      }
      return changed;
    };
    Object.defineProperty(Axis2.prototype, "title", {
      /**
       * @return Title label
       */
      get: function() {
        return this._title;
      },
      /**
       * A reference to a [[Label]] element which serves as a title to the axis.
       *
       * When axis is created it aleready has an element, so you can just modify
       * it.
       *
       * Or you can replace it with your own instance of `Label`.
       *
       * @param  value  Title label
       */
      set: function(value) {
        if (this._title && this._title != value) {
          this._title.dispose();
        }
        if (value) {
          this._title = value;
          value.parent = this;
          value.shouldClone = false;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Axis2.prototype, "hideTooltipWhileZooming", {
      /**
       * @return Hide tooltip while zooming?
       */
      get: function() {
        return this.getPropertyValue("hideTooltipWhileZooming");
      },
      /**
       * Indicates if axis' tooltip should be hidden while axis range is animating
       * (zooming)
       *
       * @default true
       * @since 4.7.16
       * @param  value  Hide tooltip while zooming?
       */
      set: function(value) {
        this.setPropertyValue("hideTooltipWhileZooming", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Axis2.prototype, "zoomable", {
      /**
       * @return Zoomable?
       */
      get: function() {
        return this.getPropertyValue("zoomable");
      },
      /**
       * Should the axis be zoomed with scrollbar/cursor?
       *
       * @default true
       * @since 4.9.28
       * @param  value  Zoomable?
       */
      set: function(value) {
        this.setPropertyValue("zoomable", value);
      },
      enumerable: true,
      configurable: true
    });
    return Axis2;
  }(Component)
);
registry.registeredClasses["Axis"] = Axis;
registry.registeredClasses["AxisDataItem"] = AxisDataItem;
defaultRules.push({
  relevant: ResponsiveBreakpoints.maybeXS,
  state: function(target, stateId) {
    if (target instanceof Axis && target.tooltip) {
      var state = target.states.create(stateId);
      state.properties.cursorTooltipEnabled = false;
      return state;
    }
    return null;
  }
});

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisLine.js
var AxisLine = (
  /** @class */
  function(_super) {
    __extends(AxisLine2, _super);
    function AxisLine2() {
      var _this = _super.call(this) || this;
      _this.className = "AxisLine";
      _this.element = _this.paper.add("path");
      var interfaceColors = new InterfaceColorSet();
      _this.stroke = interfaceColors.getFor("grid");
      _this.strokeOpacity = 0.15;
      _this.pixelPerfect = true;
      _this.fill = color();
      _this.applyTheme();
      _this.interactionsEnabled = false;
      return _this;
    }
    return AxisLine2;
  }(Sprite)
);
registry.registeredClasses["AxisLine"] = AxisLine;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisFill.js
var AxisFill = (
  /** @class */
  function(_super) {
    __extends(AxisFill2, _super);
    function AxisFill2(axis) {
      var _this = _super.call(this) || this;
      _this.axis = axis;
      _this.element = _this.paper.add("path");
      _this.className = "AxisFill";
      _this.isMeasured = false;
      _this.location = 0;
      _this.above = false;
      var interfaceColors = new InterfaceColorSet();
      _this.fill = interfaceColors.getFor("alternativeBackground");
      _this.fillOpacity = 0;
      _this.applyTheme();
      return _this;
    }
    AxisFill2.prototype.setDisabled = function(value) {
      var changed = _super.prototype.setDisabled.call(this, value);
      if (this.axis) {
        this.axis.invalidateDataItems();
      }
      return changed;
    };
    AxisFill2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      if (this.__disabled || this.disabled) {
        return;
      }
      if (this.axis && isNumber(this.startPosition) && isNumber(this.endPosition)) {
        this.fillPath = this.axis.getPositionRangePath(this.startPosition, this.endPosition);
        this.path = this.fillPath;
        if (this.isMeasured) {
          this.measure();
        }
      }
    };
    Object.defineProperty(AxisFill2.prototype, "startPosition", {
      /**
       * @return Start position
       */
      get: function() {
        return this.getPropertyValue("startPosition");
      },
      /**
       * An actual starting position of the fill.
       *
       * @param value  Starting position
       */
      set: function(value) {
        this.setPropertyValue("startPosition", value);
        this.invalidate();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisFill2.prototype, "endPosition", {
      /**
       * @return End position
       */
      get: function() {
        return this.getPropertyValue("endPosition");
      },
      /**
       * An actual end position of the fill.
       *
       * @param value End position
       */
      set: function(value) {
        this.setPropertyValue("endPosition", value);
        this.invalidate();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisFill2.prototype, "location", {
      /**
       * @return Location (0-1)
       */
      get: function() {
        return this.getPropertyValue("location");
      },
      /**
       * Relative location of the fill. (0-1)
       *
       * @param value Location (0-1)
       */
      set: function(value) {
        this.setPropertyValue("location", value, true);
      },
      enumerable: true,
      configurable: true
    });
    AxisFill2.prototype.setPath = function(value) {
      if (this.setPropertyValue("path", value)) {
        this.element.attr({ "d": value });
        return true;
      }
      return false;
    };
    Object.defineProperty(AxisFill2.prototype, "above", {
      /**
       * @return Draw above series?
       */
      get: function() {
        return this.getPropertyValue("above");
      },
      /**
       * Normally fill goes below series. Set this to `true` to go above.
       *
       * @default false
       * @since 4.5.9
       * @param  value  Draw above series?
       */
      set: function(value) {
        this.setPropertyValue("above", value, true);
      },
      enumerable: true,
      configurable: true
    });
    return AxisFill2;
  }(Sprite)
);
registry.registeredClasses["AxisFill"] = AxisFill;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/Grid.js
var Grid = (
  /** @class */
  function(_super) {
    __extends(Grid2, _super);
    function Grid2() {
      var _this = _super.call(this) || this;
      _this.className = "Grid";
      _this.element = _this.paper.add("path");
      _this.location = 0.5;
      _this.isMeasured = false;
      _this.above = false;
      var interfaceColors = new InterfaceColorSet();
      _this.stroke = interfaceColors.getFor("grid");
      _this.pixelPerfect = true;
      _this.strokeOpacity = 0.15;
      _this.fill = color();
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(Grid2.prototype, "location", {
      /**
       * @return Location (0-1)
       */
      get: function() {
        return this.getPropertyValue("location");
      },
      /**
       * Location within axis cell to place grid line on.
       *
       * * 0 - start
       * * 0.5 - middle
       * * 1 - end
       *
       * @param value  Location (0-1)
       */
      set: function(value) {
        this.setPropertyValue("location", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Grid2.prototype, "above", {
      /**
       * @return Draw above series?
       */
      get: function() {
        return this.getPropertyValue("above");
      },
      /**
       * Normally fill goes below series. Set this to `true` to go above.
       *
       * @default false
       * @since 4.5.9
       * @param  value  Draw above series?
       */
      set: function(value) {
        this.setPropertyValue("above", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Grid2.prototype.setDisabled = function(value) {
      var changed = _super.prototype.setDisabled.call(this, value);
      if (this.axis) {
        this.axis.invalidateDataItems();
      }
      return changed;
    };
    return Grid2;
  }(Sprite)
);
registry.registeredClasses["Grid"] = Grid;
defaultRules.push({
  relevant: ResponsiveBreakpoints.maybeXS,
  state: function(target, stateId) {
    if (target instanceof Grid) {
      var state = target.states.create(stateId);
      state.properties.disabled = true;
      return state;
    }
    return null;
  }
});

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisLabel.js
var AxisLabel = (
  /** @class */
  function(_super) {
    __extends(AxisLabel2, _super);
    function AxisLabel2() {
      var _this = _super.call(this) || this;
      _this.className = "AxisLabel";
      _this.isMeasured = false;
      _this.padding(10, 10, 10, 10);
      _this.location = 0.5;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(AxisLabel2.prototype, "location", {
      /**
       * @return Location (0-1)
       */
      get: function() {
        return this.getPropertyValue("location");
      },
      /**
       * Relative location of the label. (0-1)
       *
       * @param value  Location (0-1)
       */
      set: function(value) {
        this.setPropertyValue("location", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisLabel2.prototype, "inside", {
      /**
       * Returns if label is set to be drawn inside axis.
       *
       * @return Inside?
       */
      get: function() {
        return this.getPropertyValue("inside");
      },
      /**
       * Sets if label should be drawn inside axis.
       *
       * @param value  Inside?
       */
      set: function(value) {
        this.setPropertyValue("inside", value, true);
      },
      enumerable: true,
      configurable: true
    });
    AxisLabel2.prototype.setDisabled = function(value) {
      var changed = _super.prototype.setDisabled.call(this, value);
      if (this.axis) {
        this.axis.invalidateDataItems();
      }
      return changed;
    };
    return AxisLabel2;
  }(Label)
);
registry.registeredClasses["AxisLabel"] = AxisLabel;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/Tick.js
var Tick = (
  /** @class */
  function(_super) {
    __extends(Tick2, _super);
    function Tick2() {
      var _this = _super.call(this) || this;
      _this.className = "Tick";
      var interfaceColors = new InterfaceColorSet();
      _this.fillOpacity = 0;
      _this.length = 6;
      _this.strokeOpacity = 0.2;
      _this.stroke = interfaceColors.getFor("grid");
      _this.isMeasured = false;
      _this.nonScalingStroke = true;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(Tick2.prototype, "length", {
      /**
       * @return Length (px)
       */
      get: function() {
        if (this.disabled) {
          return 0;
        }
        return this.getPropertyValue("length");
      },
      /**
       * Length of the tick in pixels.
       *
       * @param value  Length (px)
       */
      set: function(value) {
        this.setPropertyValue("length", value, true);
      },
      enumerable: true,
      configurable: true
    });
    return Tick2;
  }(Sprite)
);
registry.registeredClasses["Tick"] = Tick;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisTick.js
var AxisTick = (
  /** @class */
  function(_super) {
    __extends(AxisTick2, _super);
    function AxisTick2() {
      var _this = _super.call(this) || this;
      _this.className = "AxisTick";
      _this.element = _this.paper.add("path");
      _this.location = 0.5;
      _this.above = false;
      _this.isMeasured = false;
      _this.pixelPerfect = true;
      _this.strokeOpacity = 0;
      _this.length = 5;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(AxisTick2.prototype, "location", {
      /**
       * @return Location (0-1)
       */
      get: function() {
        return this.getPropertyValue("location");
      },
      /**
       * Relative location of the tick. (0-1)
       *
       * @param value  Location (0-1)
       */
      set: function(value) {
        this.setPropertyValue("location", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisTick2.prototype, "inside", {
      /**
       * Returns if label is set to be drawn inside axis.
       *
       * @return Inside?
       */
      get: function() {
        return this.getPropertyValue("inside");
      },
      /**
       * Sets if tick should be drawn inside axis.
       *
       * @param value  Inside?
       */
      set: function(value) {
        this.setPropertyValue("inside", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisTick2.prototype, "above", {
      /**
       * @return Draw above series?
       */
      get: function() {
        return this.getPropertyValue("above");
      },
      /**
       * Normally tick goes below series. Set this to `true` to go above.
       *
       * @default false
       * @since 4.5.9
       * @param  value  Draw above series?
       */
      set: function(value) {
        this.setPropertyValue("above", value, true);
      },
      enumerable: true,
      configurable: true
    });
    AxisTick2.prototype.setDisabled = function(value) {
      var changed = _super.prototype.setDisabled.call(this, value);
      if (this.axis) {
        this.axis.invalidateDataItems();
      }
      return changed;
    };
    return AxisTick2;
  }(Tick)
);
registry.registeredClasses["AxisTick"] = AxisTick;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRenderer.js
var AxisRenderer = (
  /** @class */
  function(_super) {
    __extends(AxisRenderer2, _super);
    function AxisRenderer2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._chart = new MutableValueDisposer();
      _this.className = "AxisRenderer";
      _this.minGridDistance = 50;
      _this.inside = false;
      _this.inversed = false;
      _this.tooltipLocation = 0.5;
      _this.fullWidthTooltip = false;
      _this.cellStartLocation = 0;
      _this.cellEndLocation = 1;
      _this.minLabelPosition = 0;
      _this.maxLabelPosition = 1;
      _this.shouldClone = false;
      var gridContainer = _this.createChild(Container);
      gridContainer.shouldClone = false;
      gridContainer.layout = "none";
      gridContainer.virtualParent = _this;
      gridContainer.width = percent(100);
      gridContainer.height = percent(100);
      _this.gridContainer = gridContainer;
      gridContainer.events.on("maxsizechanged", function() {
        if (_this.inited) {
          _this.invalidateAxisItems();
        }
      }, _this, false);
      var breakContainer = _this.createChild(Container);
      breakContainer.shouldClone = false;
      breakContainer.isMeasured = false;
      breakContainer.layout = "none";
      breakContainer.width = percent(100);
      breakContainer.height = percent(100);
      _this.breakContainer = breakContainer;
      var bulletsContainer = _this.createChild(Container);
      bulletsContainer.shouldClone = false;
      bulletsContainer.isMeasured = false;
      bulletsContainer.layout = "none";
      bulletsContainer.width = percent(100);
      bulletsContainer.height = percent(100);
      _this.bulletsContainer = bulletsContainer;
      _this.line = _this.createChild(AxisLine);
      _this.line.shouldClone = false;
      _this.line.strokeOpacity = 0;
      var baseGrid = _this.createChild(Grid);
      baseGrid.shouldClone = false;
      _this.baseGrid = baseGrid;
      var disposers = _this._disposers;
      disposers.push(baseGrid);
      disposers.push(_this.line);
      disposers.push(gridContainer);
      disposers.push(breakContainer);
      disposers.push(bulletsContainer);
      disposers.push(_this._chart);
      _this.ticks.template.disabled = true;
      _this.axisFills.template.disabled = true;
      _this.axisFills.template.interactionsEnabled = false;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(AxisRenderer2.prototype, "axis", {
      /**
       * Axis of a renderer
       * @return axis Axis
       */
      get: function() {
        return this._axis;
      },
      /**
       * Axis of a renderer
       * @param axis Axis
       */
      set: function(axis) {
        this.setAxis(axis);
      },
      enumerable: true,
      configurable: true
    });
    AxisRenderer2.prototype.setAxis = function(axis) {
      this._axis = axis;
      this.baseGrid.parent = axis;
      this.line.parent = axis;
      this.gridContainer.bind("opacity", axis);
    };
    AxisRenderer2.prototype.processRenderer = function() {
      this.events.on("sizechanged", this.updateTooltip, this, false);
      this.events.on("positionchanged", this.updateTooltip, this, false);
      this.labels.template.inside = this.inside;
      this.ticks.template.inside = this.inside;
    };
    AxisRenderer2.prototype.updateTooltip = function() {
    };
    Object.defineProperty(AxisRenderer2.prototype, "axisLength", {
      /**
       * Returns actual length of the Axis, in pixels.
       *
       * @return Length (px)
       */
      get: function() {
        return 0;
      },
      enumerable: true,
      configurable: true
    });
    AxisRenderer2.prototype.positionItem = function(item, point) {
      if (item) {
        item.moveTo(point);
      }
    };
    AxisRenderer2.prototype.positionToPoint = function(position, position2) {
      return { x: 0, y: 0 };
    };
    AxisRenderer2.prototype.positionToAngle = function(position) {
      return 0;
    };
    AxisRenderer2.prototype.positionToCoordinate = function(position) {
      var coordinate;
      var axis = this.axis;
      var axisFullLength = axis.axisFullLength;
      if (axis.renderer.inversed) {
        coordinate = (axis.end - position) * axisFullLength;
      } else {
        coordinate = (position - axis.start) * axisFullLength;
      }
      return coordinate;
    };
    AxisRenderer2.prototype.updateGridContainer = function() {
    };
    AxisRenderer2.prototype.getHeight = function() {
      var gridContainer = this.gridContainer;
      if (gridContainer.parent) {
        return gridContainer.parent.pixelHeight;
      }
      return this.gridContainer.pixelHeight || 0;
    };
    AxisRenderer2.prototype.getWidth = function() {
      var gridContainer = this.gridContainer;
      if (gridContainer.parent) {
        return gridContainer.parent.pixelWidth;
      }
      return this.gridContainer.pixelWidth || 0;
    };
    AxisRenderer2.prototype.coordinateToPosition = function(coordinate, coordinate2) {
      var position;
      var axis = this.axis;
      var axisFullLength = axis.axisFullLength;
      if (axis.renderer.inversed) {
        position = axis.end - coordinate / axisFullLength;
      } else {
        position = coordinate / axisFullLength + axis.start;
      }
      return round(position, 5);
    };
    AxisRenderer2.prototype.pointToPosition = function(point) {
      return 0;
    };
    AxisRenderer2.prototype.getPositionRangePath = function(startPosition, endPosition) {
      return "";
    };
    AxisRenderer2.prototype.invalidateAxisItems = function() {
      var axis = this.axis;
      if (axis) {
        axis.invalidateDataItems();
      }
    };
    AxisRenderer2.prototype.updateGridElement = function(grid, position, endPosition) {
    };
    AxisRenderer2.prototype.updateTickElement = function(tick, position, endPosition) {
    };
    AxisRenderer2.prototype.updateBullet = function(bullet, position, endPosition) {
    };
    AxisRenderer2.prototype.updateLabelElement = function(label, position, endPosition, location) {
    };
    AxisRenderer2.prototype.updateFillElement = function(fill, position, endPosition) {
      fill.startPosition = position;
      fill.endPosition = endPosition;
    };
    AxisRenderer2.prototype.updateAxisLine = function() {
    };
    AxisRenderer2.prototype.updateBaseGridElement = function() {
    };
    AxisRenderer2.prototype.updateBreakElement = function(axisBreak) {
      this.positionItem(axisBreak.startLine, axisBreak.startPoint);
      this.toggleVisibility(axisBreak.startLine, axisBreak.startPosition, 0, 1);
      this.positionItem(axisBreak.endLine, axisBreak.endPoint);
      this.toggleVisibility(axisBreak.endLine, axisBreak.endPosition, 0, 1);
    };
    Object.defineProperty(AxisRenderer2.prototype, "minGridDistance", {
      /**
       * @return Min distance (px)
       */
      get: function() {
        return this.getPropertyValue("minGridDistance");
      },
      /**
       * Minimum distance in pixels between grid elements.
       *
       * Use it to control density of the grid/labels on the axis.element.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/positioning-axis-elements/#Setting_the_density_of_the_the_grid_labels} for more info
       * @param value  Min distance (px)
       */
      set: function(value) {
        if (this.setPropertyValue("minGridDistance", value)) {
          if (this.axis) {
            this.axis.invalidateDataItems();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRenderer2.prototype, "chart", {
      /**
       * @ignore Exclude from docs
       * @return Chart
       */
      get: function() {
        return this._chart.get();
      },
      /**
       * A chart, associated with the Axis.
       *
       * @ignore Exclude from docs
       * @param value  Chart
       */
      set: function(value) {
        this._chart.set(value, null);
      },
      enumerable: true,
      configurable: true
    });
    AxisRenderer2.prototype.toggleVisibility = function(sprite, position, minPosition, maxPosition) {
      var axis = this.axis;
      var dataItem = sprite.dataItem;
      if (dataItem && dataItem instanceof AxisDataItem) {
        if (isNumber(dataItem.minPosition)) {
          minPosition = dataItem.minPosition;
        }
        if (isNumber(dataItem.maxPosition)) {
          maxPosition = dataItem.maxPosition;
        }
      }
      var updatedStart = axis.start + (axis.end - axis.start) * (minPosition - 1e-4);
      var updatedEnd = axis.start + (axis.end - axis.start) * (maxPosition + 1e-4);
      if (!sprite.disabled) {
        if (position < updatedStart || position > updatedEnd) {
          sprite.__disabled = true;
        } else {
          sprite.__disabled = false;
        }
      }
    };
    AxisRenderer2.prototype.createBreakSprites = function(axisBreak) {
    };
    Object.defineProperty(AxisRenderer2.prototype, "axisFills", {
      /**
       * A list of Axis' Fill elements.
       *
       * Those are fill elements that cover the space between every second set
       * of grid lines, and can be configured to create striped charts.
       *
       * Please note that these are disabled by default. To enable them, set
       * template to true.
       *
       * ```TypeScript
       * categoryAxis.renderer.axisFills.template.disabled = false;
       * ```
       * ```JavaScript
       * categoryAxis.renderer.axisFills.template.disabled = false;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "xAxes": [{
       *     // ...
       *     "renderer": {
       *       "axisFills": {
       *         "disabled": false
       *       }
       *     }
       *   }]
       * }
       * ```
       *
       * @see {@link https://www.amcharts.com/docs/v4/tutorials/alternated-axis-fills/} this tutorial for more info.
       * @return Fill elements
       */
      get: function() {
        if (!this._axisFills) {
          var fill = this.createFill(this.axis);
          this._axisFills = new ListTemplate(fill);
          fill.applyOnClones = true;
          fill.events.on("enabled", this.invalidateAxisItems, this, false);
          this._disposers.push(new ListDisposer(this._axisFills));
          this._disposers.push(this._axisFills.template);
        }
        return this._axisFills;
      },
      enumerable: true,
      configurable: true
    });
    AxisRenderer2.prototype.createFill = function(axis) {
      return new AxisFill(axis);
    };
    Object.defineProperty(AxisRenderer2.prototype, "grid", {
      /**
       * A list of Axis' Grid elements.
       *
       * @return Grid elements
       */
      get: function() {
        if (!this._grid) {
          var grid = this.createGrid();
          this._grid = new ListTemplate(grid);
          grid.applyOnClones = true;
          grid.events.on("enabled", this.invalidateAxisItems, this, false);
          this._disposers.push(new ListDisposer(this._grid));
          this._disposers.push(this._grid.template);
        }
        return this._grid;
      },
      enumerable: true,
      configurable: true
    });
    AxisRenderer2.prototype.createGrid = function() {
      return new Grid();
    };
    Object.defineProperty(AxisRenderer2.prototype, "ticks", {
      /**
       * A list of Axis' Tick elements.
       *
       * Please note that these are disabled by default. To enable ticks, you'll
       * need to set `disabled` and `strokeOpacity` properties of the tick template.
       *
       * ```TypeScript
       * categoryAxis.renderer.ticks.template.disabled = false;
       * categoryAxis.renderer.ticks.template.strokeOpacity = 0.5;
       * ```
       * ```JavaScript
       * categoryAxis.renderer.ticks.template.disabled = false;
       * categoryAxis.renderer.ticks.template.strokeOpacity = 0.5;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "xAxes": [{
       *     // ...
       *     "renderer": {
       *       "ticks": {
       *         "disabled": false,
       *         "strokeOpacity": 0.5
       *       }
       *     }
       *   }]
       * }
       * ```
       *
       * @return Tick elements
       */
      get: function() {
        if (!this._ticks) {
          var tick = this.createTick();
          tick.applyOnClones = true;
          tick.isMeasured = false;
          tick.events.on("enabled", this.invalidateAxisItems, this, false);
          this._ticks = new ListTemplate(tick);
          this._disposers.push(new ListDisposer(this._ticks));
          this._disposers.push(this._ticks.template);
        }
        return this._ticks;
      },
      enumerable: true,
      configurable: true
    });
    AxisRenderer2.prototype.createTick = function() {
      return new AxisTick();
    };
    Object.defineProperty(AxisRenderer2.prototype, "labels", {
      /**
       * A list of Axis' Label elements.
       *
       * @return Label elements
       */
      get: function() {
        if (!this._labels) {
          var label = this.createLabel();
          this._labels = new ListTemplate(label);
          label.applyOnClones = true;
          label.events.on("enabled", this.invalidateAxisItems, this, false);
          this._disposers.push(new ListDisposer(this._labels));
          this._disposers.push(this._labels.template);
        }
        return this._labels;
      },
      enumerable: true,
      configurable: true
    });
    AxisRenderer2.prototype.createLabel = function() {
      return new AxisLabel();
    };
    Object.defineProperty(AxisRenderer2.prototype, "inside", {
      /**
       * @return Labels inside?
       */
      get: function() {
        return this.getPropertyValue("inside");
      },
      /**
       * Indicates whether Axis' labels and ticks should be drawn inside Plot area.
       *
       * Does not work with all renderers, like AxisRendererRadial.
       *
       * @param value  Labels inside?
       */
      set: function(value) {
        if (this.setPropertyValue("inside", value)) {
          if (this.axis) {
            this.axis.invalidate();
          }
        }
        if (value) {
          this.width = 0;
          this.height = 0;
        } else {
          this.width = void 0;
          this.height = void 0;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRenderer2.prototype, "opposite", {
      /**
       * @return Draw axis on opposite side?
       */
      get: function() {
        return this.getPropertyValue("opposite");
      },
      /**
       * Indicates whether Axis should be drawn on the opposite side of the plot
       * area than it would normally be drawn based on chart's settings.
       *
       * Does not work with all renderers, like [[AxisRendererRadial]] and
       * [[AxisRenderer Circular].
       *
       * @param value  Draw axis on opposite side?
       */
      set: function(value) {
        this.setPropertyValue("opposite", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRenderer2.prototype, "fullWidthTooltip", {
      /**
       * @return Full width tooltip?
       */
      get: function() {
        return this.getPropertyValue("fullWidthTooltip");
      },
      /**
       * Indicates if Axis tooltip should take the whole width of the axis cell.
       * (between two grid lines)
       *
       * NOTE: this setting is ignored on circular axis types.
       *
       * @param value Full width tooltip?
       */
      set: function(value) {
        this.setPropertyValue("fullWidthTooltip", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRenderer2.prototype, "tooltipLocation", {
      /**
       * @return Tooltip location
       */
      get: function() {
        return this.getPropertyValue("tooltipLocation");
      },
      /**
       * Location within axis cell to show tooltip on. (0-1)
       *
       * 0 - show at the start
       * 0.5 - show right in the middle
       * 1 - show at the end
       *
       * @param value Tooltip location
       */
      set: function(value) {
        this.setPropertyValue("tooltipLocation", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRenderer2.prototype, "tooltipLocation2", {
      /**
       * @return Tooltip location
       */
      get: function() {
        return this.getPropertyValue("tooltipLocation2");
      },
      /**
       * Location within secondary axis cell to show tooltip on. (0-1)
       *
       * 0 - show at the start
       * 0.5 - show right in the middle
       * 1 - show at the end
       *
       * @param value Tooltip location
       */
      set: function(value) {
        this.setPropertyValue("tooltipLocation2", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRenderer2.prototype, "cellStartLocation", {
      /**
       * @return Cell start (0-1)
       */
      get: function() {
        return this.getPropertyValue("cellStartLocation");
      },
      /**
       * Location for the cell start.
       *
       * Normally a "cell" is the whole available width in a category.
       *
       * If there are several clustered column-like series available, the whole
       * space is divided between each clustered column, or column stacks.
       *
       * `cellStartLocation` identifies where, within available space, the actual
       * cell starts.
       *
       * This, together with column series' `width` will affect actual width of
       * columns, and thus gaps between them.
       *
       * This will affect category-like axes only, like [[DateAxis]], or
       * [[CategoryAxis]].
       *
       * This is used to limit a space occupied by series like column.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/positioning-axis-elements/} for more info.
       * @param value Cell start (0-1)
       */
      set: function(value) {
        if (this.setPropertyValue("cellStartLocation", value)) {
          if (this.axis) {
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRenderer2.prototype, "cellEndLocation", {
      /**
       * @return Cell end (0-1)
       */
      get: function() {
        return this.getPropertyValue("cellEndLocation");
      },
      /**
       * Location for the cell end.
       *
       * Normally a "cell" is the whole available width in a category.
       *
       * If there are several clustered column-like series available, the whole
       * space is divided between each clustered column, or column stacks.
       *
       * `cellEndLocation` identifies where, within available space, the actual
       * cell ends.
       *
       * This, together with column series' `width` will affect actual width of
       * columns, and thus gaps between them.
       *
       * This will affect category-like axes only, like [[DateAxis]], or
       * [[CategoryAxis]].
       *
       * This is used to limit a space occupied by series like column.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/positioning-axis-elements/} for more info.
       * @param value Cell end (0-1)
       */
      set: function(value) {
        if (this.setPropertyValue("cellEndLocation", value)) {
          if (this.axis) {
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRenderer2.prototype, "inversed", {
      /**
       * @return Flip axis?
       */
      get: function() {
        return this.getPropertyValue("inversed");
      },
      /**
       * Indicates if the scale of the axis should be flipped.
       *
       * @param value Flip axis?
       */
      set: function(value) {
        this.setPropertyValue("inversed", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRenderer2.prototype, "minLabelPosition", {
      /**
       * @return Min label position (0-1)
       */
      get: function() {
        return this.getPropertyValue("minLabelPosition");
      },
      /**
       * Minimum position along the Axis, for labels.
       *
       * Labels, which have their position closer to the start of the Axis, will be
       * automatically hidden.
       *
       * E.g., setting this to 0.05 (5% of total axis length) would hide labels,
       * that would otherwise be drawn very near start of the Axis.
       *
       * This is especially usefull with `inside = true`, or if the chart hasn't
       * got any extra margins.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/positioning-axis-elements/} for more info.
       * @param value  Min label position (0-1)
       */
      set: function(value) {
        this.setPropertyValue("minLabelPosition", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRenderer2.prototype, "maxLabelPosition", {
      /**
       * @return Max label position (0-1)
       */
      get: function() {
        return this.getPropertyValue("maxLabelPosition");
      },
      /**
       * Maximum position along the Axis, for labels.
       *
       * Labels, which have their position closer to the and of the Axis, will be
       * automatically hidden.
       *
       * E.g., setting this to 0.95 (95% of total axis length) would hide labels,
       * that would otherwise be drawn very near end of the Axis.
       *
       * This is especially usefull with `inside = true`, or if the chart hasn't
       * got any extra margins.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/positioning-axis-elements/} for more info.
       * @param value  Max label position (0-1)
       */
      set: function(value) {
        this.setPropertyValue("maxLabelPosition", value, true);
      },
      enumerable: true,
      configurable: true
    });
    AxisRenderer2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.grid.template.copyFrom(source.grid.template);
      this.ticks.template.copyFrom(source.ticks.template);
      this.labels.template.copyFrom(source.labels.template);
      this.axisFills.template.copyFrom(source.axisFills.template);
      this.line.copyFrom(source.line);
      this.baseGrid.copyFrom(source.baseGrid);
    };
    AxisRenderer2.prototype.toAxisPosition = function(value) {
      return value;
    };
    AxisRenderer2.prototype.setVisibility = function(value) {
      _super.prototype.setVisibility.call(this, value);
      this.bulletsContainer.visible = value;
    };
    return AxisRenderer2;
  }(Container)
);
registry.registeredClasses["AxisRenderer"] = AxisRenderer;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisBullet.js
var AxisBullet = (
  /** @class */
  function(_super) {
    __extends(AxisBullet2, _super);
    function AxisBullet2() {
      var _this = _super.call(this) || this;
      _this.className = "AxisBullet";
      _this.location = 0.5;
      _this.isMeasured = false;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(AxisBullet2.prototype, "location", {
      /**
       * @return Location (0-1)
       */
      get: function() {
        return this.getPropertyValue("location");
      },
      /**
       * Relative position within cell/range.
       *
       * Value range is from from `0` (beginning) to `1` (end).
       *
       * NOTE: `location` is relative to the parent axis range's scope, i.e.
       * between its `date` and `endDate` for [[DateAxis]], or `value`/`endValue`
       * ([[ValueAxis]]), or `category`/`endCategory` ([[categoryAxis]]).
       *
       * ```TypeScript
       * let range = dateAxis.axisRanges.create();
       * range.date = new Date(2018, 0, 5);
       * range.endDate = new Date(2018, 0, 6);
       *
       * let bullet = new am4charts.AxisBullet();
       * bullet.location = 1;
       *
       * let flag = bullet.createChild(am4plugins_bullets.FlagBullet);
       * flag.label.text = "Hello";
       * ```
       * ```JavaScript
       * var range = dateAxis.axisRanges.create();
       * range.date = new Date(2018, 0, 5);
       * range.endDate = new Date(2018, 0, 6);
       *
       * var bullet = new am4charts.AxisBullet();
       * bullet.location = 1;
       *
       * var flag = bullet.createChild(am4plugins_bullets.FlagBullet);
       * flag.label.text = "Hello";
       * ```
       * ```JSON
       * {
       *   // ...
       *   "xAxes": [{
       *     "type": "DateAxis",
       *     // ...
       *     "axisRanges": [{
       *       "date": new Date(2018, 0, 5),
       *       "endDate": new Date(2018, 0, 6),
       *       "bullet: {
       *         "type": "AxisBullet",
       *         "location": 1,
       *         "children": [{
       *           "type": "FlagBullet",
       *           "label": {
       *             "text": "Hello"
       *           }
       *         }]
       *       }
       *     }]
       *   }]
       * }
       * ```
       *
       * @default 0.5
       * @param  value  Location (0-1)
       */
      set: function(value) {
        this.setPropertyValue("location", value, true);
      },
      enumerable: true,
      configurable: true
    });
    AxisBullet2.prototype.setDisabled = function(value) {
      var changed = _super.prototype.setDisabled.call(this, value);
      if (this.axis) {
        this.axis.invalidateDataItems();
      }
      return changed;
    };
    return AxisBullet2;
  }(Container)
);
registry.registeredClasses["AxisBullet"] = AxisBullet;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererY.js
var AxisRendererY = (
  /** @class */
  function(_super) {
    __extends(AxisRendererY2, _super);
    function AxisRendererY2() {
      var _this = _super.call(this) || this;
      _this.className = "AxisRendererY";
      _this.minGridDistance = 40;
      _this.opposite = false;
      _this.height = percent(100);
      _this.labels.template.verticalCenter = "middle";
      _this.applyTheme();
      return _this;
    }
    AxisRendererY2.prototype.setAxis = function(axis) {
      _super.prototype.setAxis.call(this, axis);
      axis.layout = "horizontal";
    };
    AxisRendererY2.prototype.updateGridContainer = function() {
      var axis = this.axis;
      if (axis) {
        var gridContainer = this.gridContainer;
        gridContainer.y = axis.pixelY;
        gridContainer.height = axis.axisLength;
      }
    };
    AxisRendererY2.prototype.toAxisPosition = function(value) {
      var axis = this.axis;
      if (axis) {
        var inversedPosition = 1 - value;
        var relativePositionSprite = axis.relativePositionSprite;
        var y = axis.pixelY;
        if (relativePositionSprite) {
          y = spritePointToSprite({ x: 0, y: this.pixelY }, this.parent, relativePositionSprite).y;
        } else {
          relativePositionSprite = axis.parent;
        }
        if (relativePositionSprite) {
          var relativeY = y / relativePositionSprite.innerHeight;
          var relativeHeight = axis.axisLength / relativePositionSprite.innerHeight;
          return 1 - (inversedPosition - relativeY) / relativeHeight;
        }
      }
      return value;
    };
    AxisRendererY2.prototype.processRenderer = function() {
      _super.prototype.processRenderer.call(this);
      var axis = this.axis;
      if (axis) {
        var title = axis.title;
        title.valign = "middle";
        if (!(axis.height instanceof Percent)) {
          axis.height = percent(100);
        }
        if (this.opposite) {
          title.rotation = 90;
          this.line.toBack();
          title.toFront();
        } else {
          title.rotation = -90;
          title.toBack();
          this.line.toFront();
        }
      }
    };
    AxisRendererY2.prototype.updateTooltip = function() {
      var axis = this.axis;
      if (axis) {
        var bigNum = 2e3;
        var bbx = 0;
        var bby = 0;
        var bbw = bigNum;
        var bbh = this.axisLength;
        if (this.opposite) {
          if (this.inside) {
            bbx = -bigNum;
            bbw = bigNum;
          }
        } else {
          if (!this.inside) {
            bbx = -bigNum;
            bbw = bigNum;
          }
        }
        this.axis.updateTooltip("horizontal", { x: bbx, y: bby, width: bbw, height: bbh });
      }
    };
    Object.defineProperty(AxisRendererY2.prototype, "axisLength", {
      /**
       * Returns actual length of the Axis, in pixels.
       *
       * @return Length (px)
       */
      get: function() {
        var axis = this.axis;
        return axis.measuredHeight - axis.pixelPaddingTop - axis.pixelPaddingBottom || 0;
      },
      enumerable: true,
      configurable: true
    });
    AxisRendererY2.prototype.positionToPoint = function(position, position2) {
      return { x: 0, y: this.positionToCoordinate(position) };
    };
    AxisRendererY2.prototype.pointToPosition = function(point) {
      return this.coordinateToPosition(point.y, point.x);
    };
    AxisRendererY2.prototype.coordinateToPosition = function(coordinate, coordinate2) {
      var position;
      var axis = this.axis;
      var axisFullLength = axis.axisFullLength;
      if (axis.renderer.inversed) {
        position = 1 - axis.start - coordinate / axisFullLength;
      } else {
        position = coordinate / axisFullLength + (1 - axis.end);
      }
      return round(position, 5);
    };
    AxisRendererY2.prototype.getPositionRangePath = function(startPosition, endPosition) {
      var y1 = fitToRange(this.positionToCoordinate(startPosition), 0, this.axisLength);
      var y2 = fitToRange(this.positionToCoordinate(endPosition), 0, this.axisLength);
      var h = Math.abs(y2 - y1);
      var w = this.getWidth();
      var y = Math.min(y1, y2);
      var x = 0;
      return rectToPath({
        x,
        y,
        width: w,
        height: h
      }, true);
    };
    AxisRendererY2.prototype.updateGridElement = function(grid, position, endPosition) {
      position = position + (endPosition - position) * grid.location;
      var point = this.positionToPoint(position);
      grid.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: this.getWidth(), y: 0 });
      this.positionItem(grid, point);
      this.toggleVisibility(grid, position, 0, 1);
    };
    AxisRendererY2.prototype.updateTickElement = function(tick, position, endPosition) {
      position = position + (endPosition - position) * tick.location;
      var point = this.positionToPoint(position);
      var tickLength = tick.length;
      try {
        used(this.axis.title.measuredWidth);
      } catch (_a) {
      }
      point.x = spritePointToSprite({ x: this.line.pixelX, y: 0 }, this.line.parent, this.gridContainer).x;
      if (!this.opposite) {
        tickLength *= tick.inside ? 1 : -1;
      } else {
        tickLength *= tick.inside ? -1 : 1;
      }
      tick.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: tickLength, y: 0 });
      this.positionItem(tick, point);
      this.toggleVisibility(tick, position, 0, 1);
    };
    AxisRendererY2.prototype.updateAxisLine = function() {
      this.line.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: 0, y: this.axisLength });
    };
    AxisRendererY2.prototype.updateBaseGridElement = function() {
      _super.prototype.updateBaseGridElement.call(this);
      var axis = this.axis;
      var w = this.getWidth();
      var h = this.axisLength;
      var y = axis.basePoint.y;
      var baseGrid = this.baseGrid;
      if (y < -0.2 || y > h + 0.2) {
        baseGrid.hide(0);
      } else {
        var x = spritePointToSprite({ x: 0, y: 0 }, this.gridContainer, baseGrid.parent).x;
        baseGrid.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: w, y: 0 });
        baseGrid.moveTo({ x, y });
        baseGrid.show(0);
      }
    };
    AxisRendererY2.prototype.updateLabelElement = function(label, position, endPosition, location) {
      if (!hasValue(location)) {
        location = label.location;
      }
      position = position + (endPosition - position) * location;
      label.isMeasured = !label.inside;
      var point = this.positionToPoint(position);
      var horizontalCenter;
      var deltaX = 0;
      var maxWidth = this.gridContainer.maxWidth;
      if (this.opposite) {
        if (label.inside) {
          horizontalCenter = "right";
          if (label.align == "left") {
            deltaX = -maxWidth;
            horizontalCenter = "left";
          }
          if (label.align == "center") {
            deltaX = -maxWidth / 2;
            horizontalCenter = "middle";
          }
        } else {
          horizontalCenter = "left";
        }
        point.x = 0 + deltaX;
      } else {
        if (label.inside) {
          horizontalCenter = "left";
          if (label.align == "right") {
            deltaX = maxWidth;
            horizontalCenter = "right";
          }
          if (label.align == "center") {
            deltaX = maxWidth / 2;
            horizontalCenter = "middle";
          }
        } else {
          horizontalCenter = "right";
        }
        point.x = this.measuredWidth + deltaX;
      }
      if (label.rotation == 0) {
        label.horizontalCenter = horizontalCenter;
      }
      this.positionItem(label, point);
      this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);
    };
    AxisRendererY2.prototype.updateBreakElement = function(axisBreak) {
      _super.prototype.updateBreakElement.call(this, axisBreak);
      var startLine = axisBreak.startLine;
      var endLine = axisBreak.endLine;
      var fillShape = axisBreak.fillShape;
      var startPoint = axisBreak.startPoint;
      var endPoint = axisBreak.endPoint;
      var x1 = axisBreak.pixelMarginLeft;
      var x2 = this.getWidth() - axisBreak.pixelMarginLeft - axisBreak.pixelMarginRight;
      startPoint.y = fitToRange(startPoint.y, -1, this.axisLength + 1);
      endPoint.y = fitToRange(endPoint.y, -1, this.axisLength + 1);
      if (startPoint.y == endPoint.y && (startPoint.y < 0 || startPoint.y > this.axisLength)) {
        axisBreak.fillShape.__disabled = true;
      } else {
        axisBreak.fillShape.__disabled = false;
      }
      var w = Math.abs(x2 - x1);
      startLine.x = x1;
      startLine.height = 0;
      startLine.width = w;
      endLine.x = x1;
      endLine.height = 0;
      endLine.width = w;
      fillShape.width = w;
      fillShape.height = Math.abs(endPoint.y - startPoint.y);
      fillShape.x = x1;
      fillShape.y = endPoint.y;
    };
    AxisRendererY2.prototype.createBreakSprites = function(axisBreak) {
      axisBreak.startLine = new WavedLine();
      axisBreak.endLine = new WavedLine();
      var wavedRectangle = new WavedRectangle();
      wavedRectangle.setWavedSides(true, false, true, false);
      axisBreak.fillShape = wavedRectangle;
    };
    AxisRendererY2.prototype.positionToCoordinate = function(position) {
      var coordinate;
      var axis = this.axis;
      var axisFullLength = axis.axisFullLength;
      if (!axis.renderer.inversed) {
        coordinate = (axis.end - position) * axisFullLength;
      } else {
        coordinate = (position - axis.start) * axisFullLength;
      }
      return coordinate;
    };
    AxisRendererY2.prototype.updateBullet = function(bullet, position, endPosition) {
      var location = 0.5;
      if (bullet instanceof AxisBullet) {
        location = bullet.location;
      }
      position = position + (endPosition - position) * location;
      var point = this.positionToPoint(position);
      point.x = spritePointToSprite({ x: this.line.pixelX, y: 0 }, this.line.parent, this.gridContainer).x;
      this.positionItem(bullet, point);
      this.toggleVisibility(bullet, position, 0, 1);
    };
    return AxisRendererY2;
  }(AxisRenderer)
);
registry.registeredClasses["AxisRendererY"] = AxisRendererY;
defaultRules.push({
  relevant: ResponsiveBreakpoints.widthS,
  state: function(target, stateId) {
    if (target instanceof AxisRendererY) {
      var state = target.states.create(stateId);
      state.properties.inside = true;
      state.properties.maxLabelPosition = 0.9;
      state.properties.minLabelPosition = 0.1;
      return state;
    }
    return null;
  }
});
defaultRules.push({
  relevant: ResponsiveBreakpoints.widthXS,
  state: function(target, stateId) {
    if (target instanceof AxisRendererY) {
      var state = target.states.create(stateId);
      state.properties.disabled = true;
      return state;
    }
    return null;
  }
});

// node_modules/@amcharts/amcharts4/.internal/charts/axes/ValueAxisBreak.js
var ValueAxisBreak = (
  /** @class */
  function(_super) {
    __extends(ValueAxisBreak2, _super);
    function ValueAxisBreak2() {
      var _this = _super.call(this) || this;
      _this.className = "ValueAxisBreak";
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(ValueAxisBreak2.prototype, "startPosition", {
      /**
       * Pixel position of the break's start.
       *
       * @return Position (px)
       * @readonly
       */
      get: function() {
        if (this.axis) {
          return this.axis.valueToPosition(this.adjustedStartValue);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxisBreak2.prototype, "endPosition", {
      /**
       * Pixel position of the break's end.
       *
       * @return Position (px)
       * @readonly
       */
      get: function() {
        if (this.axis) {
          return this.axis.valueToPosition(this.adjustedEndValue);
        }
      },
      enumerable: true,
      configurable: true
    });
    return ValueAxisBreak2;
  }(AxisBreak)
);
registry.registeredClasses["ValueAxisBreak"] = ValueAxisBreak;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/ValueAxis.js
var ValueAxisDataItem = (
  /** @class */
  function(_super) {
    __extends(ValueAxisDataItem2, _super);
    function ValueAxisDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "ValueAxisDataItem";
      _this.values.value = {};
      _this.values.endValue = {};
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(ValueAxisDataItem2.prototype, "value", {
      /**
       * @return Value
       */
      get: function() {
        return this.values["value"].value;
      },
      /**
       * A data point's numeric value.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("value", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxisDataItem2.prototype, "endValue", {
      /**
       * @return Value
       */
      get: function() {
        return this.values["endValue"].value;
      },
      /**
       * Data point's numeric end value.
       *
       * @param value  End value
       */
      set: function(value) {
        this.setValue("endValue", value);
      },
      enumerable: true,
      configurable: true
    });
    return ValueAxisDataItem2;
  }(AxisDataItem)
);
var ValueAxis = (
  /** @class */
  function(_super) {
    __extends(ValueAxis2, _super);
    function ValueAxis2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._stepDecimalPlaces = 0;
      _this._prevStepDecimalPlaces = 0;
      _this._adjustLabelPrecision = true;
      _this._baseValue = 0;
      _this._adjustedStart = 0;
      _this._adjustedEnd = 1;
      _this._extremesChanged = false;
      _this._deltaMinMax = 1;
      _this._dsc = false;
      _this.calculateTotals = false;
      _this.className = "ValueAxis";
      _this.axisFieldName = "value";
      _this.setPropertyValue("maxZoomFactor", 1e3);
      _this.setPropertyValue("extraMin", 0);
      _this.setPropertyValue("extraMax", 0);
      _this.setPropertyValue("strictMinMax", false);
      _this.setPropertyValue("maxPrecision", Number.MAX_VALUE);
      _this.setPropertyValue("adjustLabelPrecision", true);
      _this.setPropertyValue("extraTooltipPrecision", 0);
      _this.keepSelection = false;
      _this.includeRangesInMinMax = false;
      _this.applyTheme();
      return _this;
    }
    ValueAxis2.prototype.fillRule = function(dataItem) {
      var value = dataItem.value;
      var axis = dataItem.component;
      if (!dataItem.axisFill.disabled) {
        if (round(value / axis.step / 2, 5) == Math.round(value / axis.step / 2)) {
          dataItem.axisFill.__disabled = true;
        } else {
          dataItem.axisFill.__disabled = false;
        }
      }
    };
    ValueAxis2.prototype.createDataItem = function() {
      return new ValueAxisDataItem();
    };
    ValueAxis2.prototype.createAxisBreak = function() {
      return new ValueAxisBreak();
    };
    ValueAxis2.prototype.dataChangeUpdate = function() {
      this.clearCache();
      if (!this.keepSelection) {
        if (this._start != 0 || this._end != 1) {
          this._start = 0;
          this._end = 1;
          this.dispatchImmediately("startendchanged");
        }
      } else {
        if (this._start != 0) {
          this.dispatchImmediately("startchanged");
        }
        if (this._end != 1) {
          this.dispatchImmediately("endchanged");
        }
        if (this._start != 0 || this._end != 1) {
          this.dispatchImmediately("startendchanged");
        }
      }
      this._maxZoomed = this._maxDefined;
      this._minZoomed = this._minDefined;
      this._maxAdjusted = this._maxDefined;
      this._minAdjusted = this._minDefined;
    };
    ValueAxis2.prototype.processSeriesDataItems = function() {
      if (this.calculateTotals) {
        var series = this.series.getIndex(0);
        var startIndex = series.startIndex;
        if (series.dataItems.length > 0) {
          if (startIndex > 0) {
            startIndex--;
          }
          var endIndex = series.endIndex;
          if (endIndex < series.dataItems.length) {
            endIndex++;
          }
          var _loop_1 = function(i2) {
            var total = {};
            var sum = {};
            this_1.series.each(function(series2) {
              if (!series2.excludeFromTotal) {
                var dataItem_1 = series2.dataItems.getIndex(i2);
                if (dataItem_1) {
                  each2(dataItem_1.values, function(key) {
                    var value = dataItem_1.values[key].workingValue;
                    if (isNumber(value)) {
                      if (!isNumber(total[key])) {
                        total[key] = Math.abs(value);
                      } else {
                        total[key] += Math.abs(value);
                      }
                      if (!isNumber(sum[key])) {
                        sum[key] = value;
                      } else {
                        sum[key] += value;
                      }
                    }
                  });
                }
              }
            });
            this_1.series.each(function(series2) {
              if (!series2.excludeFromTotal) {
                var dataItem_2 = series2.dataItems.getIndex(i2);
                if (dataItem_2) {
                  each2(dataItem_2.values, function(key) {
                    var value = dataItem_2.values[key].workingValue;
                    if (isNumber(value)) {
                      dataItem_2.setCalculatedValue(key, total[key], "total");
                      dataItem_2.setCalculatedValue(key, 100 * value / total[key], "totalPercent");
                      dataItem_2.setCalculatedValue(key, sum[key], "sum");
                    }
                  });
                }
              }
            });
          };
          var this_1 = this;
          for (var i = startIndex; i < endIndex; ++i) {
            _loop_1(i);
          }
        }
      }
    };
    ValueAxis2.prototype.validate = function() {
      if (this.axisLength <= 0) {
        return;
      }
      _super.prototype.validate.call(this);
      this.getMinMax();
      if (!isNumber(this._minAdjusted)) {
        this.dataItems.each(function(dataItem) {
          dataItem.value = null;
        });
      }
      this.fixAxisBreaks();
      this.calculateZoom();
      this.validateAxisElements();
      this.validateAxisRanges();
      this.validateBreaks();
      this.hideUnusedDataItems();
      this.renderer.invalidateLayout();
    };
    ValueAxis2.prototype.calculateZoom = function() {
      if (isNumber(this.min) && isNumber(this.max)) {
        var min2 = this.positionToValue(this.start);
        var max2 = this.positionToValue(this.end);
        var differece = this.adjustDifference(min2, max2);
        var minMaxStep = this.adjustMinMax(min2, max2, differece, this._gridCount, true);
        var stepDecimalPlaces = decimalPlaces(minMaxStep.step);
        this._stepDecimalPlaces = stepDecimalPlaces;
        min2 = round(min2, stepDecimalPlaces);
        max2 = round(max2, stepDecimalPlaces);
        minMaxStep = this.adjustMinMax(min2, max2, differece, this._gridCount, true);
        var step = minMaxStep.step;
        if (this.syncWithAxis) {
          var calculated = this.getCache(min2 + "-" + max2);
          if (isNumber(calculated)) {
            step = calculated;
          }
        } else {
          min2 = minMaxStep.min;
          max2 = minMaxStep.max;
        }
        if (this._minZoomed != min2 || this._maxZoomed != max2 || this._step != step || this._dsc) {
          this._dsc = false;
          this._minZoomed = min2;
          this._maxZoomed = max2;
          this._step = step;
          this.dispatchImmediately("selectionextremeschanged");
        }
      }
    };
    ValueAxis2.prototype.fixSmallStep = function(step) {
      if (1 + step == 1) {
        step *= 2;
        return this.fixSmallStep(step);
      }
      return step;
    };
    ValueAxis2.prototype.validateAxisElements = function() {
      var _this = this;
      if (isNumber(this.max) && isNumber(this.min)) {
        var value_1 = this.minZoomed - this._step * 2;
        if (!this.logarithmic) {
          value_1 = Math.floor(value_1 / this._step) * this._step;
        } else {
          var differencePower = Math.log(this.max) * Math.LOG10E - Math.log(this.min) * Math.LOG10E;
          if (differencePower > 1) {
            value_1 = Math.pow(10, Math.log(this.min) * Math.LOG10E);
          } else {
            value_1 = Math.floor(this.minZoomed / this._step) * this._step;
            if (value_1 == 0) {
              value_1 = this.minZoomed;
            }
          }
        }
        var maxZoomed = this._maxZoomed + this._step;
        this.resetIterators();
        var dataItemsIterator_1 = this._dataItemsIterator;
        if (this._step == 0) {
          return;
        }
        this._step = this.fixSmallStep(this._step);
        var i = 0;
        var precisionChanged = this._prevStepDecimalPlaces != this._stepDecimalPlaces;
        this._prevStepDecimalPlaces = this._stepDecimalPlaces;
        while (value_1 <= maxZoomed) {
          var axisBreak = this.isInBreak(value_1);
          if (!axisBreak) {
            var dataItem = dataItemsIterator_1.find(function(x) {
              return x.value === value_1;
            });
            if (dataItem.__disabled) {
              dataItem.__disabled = false;
            }
            this.appendDataItem(dataItem);
            dataItem.axisBreak = void 0;
            if (dataItem.value != value_1 || precisionChanged) {
              dataItem.value = value_1;
              dataItem.text = this.formatLabel(value_1);
              if (dataItem.label && dataItem.label.invalid) {
                dataItem.label.validate();
              }
              if (dataItem.value >= this.min && dataItem.value <= this.max) {
                if (dataItem.label) {
                  if (this.axisLetter == "Y" && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth || this.axisLetter == "X" && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight) {
                    this.ghostLabel.text = dataItem.label.currentText;
                    this.ghostLabel.validate();
                  }
                }
              }
            }
            this.validateDataElement(dataItem);
          }
          i++;
          var oldValue = value_1;
          if (!this.logarithmic) {
            value_1 += this._step;
          } else {
            var differencePower = Math.log(this.max) * Math.LOG10E - Math.log(this.min) * Math.LOG10E;
            if (differencePower > 1) {
              value_1 = Math.pow(10, Math.log(this.min) * Math.LOG10E + i);
            } else {
              value_1 += this._step;
            }
          }
          var stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(this._step)) * Math.LOG10E));
          if (stepPower < 1) {
            var decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 2;
            decCount = Math.min(13, decCount);
            value_1 = round(value_1, decCount);
            if (oldValue == value_1) {
              value_1 = maxZoomed;
              break;
            }
          }
        }
        var axisBreaks = this._axisBreaks;
        if (axisBreaks) {
          var renderer_1 = this.renderer;
          each3(axisBreaks.iterator(), function(axisBreak2) {
            if (axisBreak2.breakSize > 0) {
              if (getDistance(axisBreak2.startPoint, axisBreak2.endPoint) > renderer_1.minGridDistance) {
                var breakValue_1 = axisBreak2.adjustedMin;
                while (breakValue_1 <= axisBreak2.adjustedMax) {
                  if (breakValue_1 >= axisBreak2.adjustedStartValue && breakValue_1 <= axisBreak2.adjustedEndValue) {
                    var dataItem2 = dataItemsIterator_1.find(function(x) {
                      return x.value === breakValue_1;
                    });
                    if (dataItem2.__disabled) {
                      dataItem2.__disabled = false;
                    }
                    _this.appendDataItem(dataItem2);
                    dataItem2.axisBreak = axisBreak2;
                    if (dataItem2.value != breakValue_1) {
                      dataItem2.value = breakValue_1;
                      dataItem2.text = _this.formatLabel(breakValue_1);
                      if (dataItem2.label && dataItem2.label.invalid) {
                        dataItem2.label.validate();
                      }
                    }
                    _this.validateDataElement(dataItem2);
                  }
                  breakValue_1 += axisBreak2.adjustedStep;
                }
              }
            }
          });
        }
      }
    };
    ValueAxis2.prototype.validateDataElement = function(dataItem) {
      _super.prototype.validateDataElement.call(this, dataItem);
      dataItem.itemIndex = this._axisItemCount;
      this._axisItemCount++;
      var renderer = this.renderer;
      var value = dataItem.value;
      var endValue = dataItem.endValue;
      var position = this.valueToPosition(value);
      dataItem.position = position;
      var endPosition = position;
      var fillEndPosition = this.valueToPosition(value + this._step);
      if (isNumber(endValue)) {
        endPosition = this.valueToPosition(endValue);
        fillEndPosition = endPosition;
      }
      dataItem.point = renderer.positionToPoint(position);
      var tick = dataItem.tick;
      if (tick && !tick.disabled) {
        renderer.updateTickElement(tick, position, endPosition);
      }
      var grid = dataItem.grid;
      if (grid && !grid.disabled) {
        renderer.updateGridElement(grid, position, endPosition);
      }
      var label = dataItem.label;
      if (label && !label.disabled) {
        renderer.updateLabelElement(label, position, endPosition);
      }
      var fill = dataItem.axisFill;
      if (fill && !fill.disabled) {
        renderer.updateFillElement(fill, position, fillEndPosition);
        if (!dataItem.isRange) {
          this.fillRule(dataItem);
        }
      }
      if (dataItem.bullet) {
        renderer.updateBullet(dataItem.bullet, position, endPosition);
      }
      var mask = dataItem.mask;
      if (mask) {
        renderer.updateFillElement(mask, position, fillEndPosition);
      }
    };
    ValueAxis2.prototype.formatLabel = function(value) {
      if (this.adjustLabelPrecision && value != 0) {
        return this.numberFormatter.format(value, void 0, this._stepDecimalPlaces);
      } else {
        return this.numberFormatter.format(value);
      }
    };
    Object.defineProperty(ValueAxis2.prototype, "basePoint", {
      /**
       * Coordinates of the actual axis start.
       *
       * @ignore Exclude from docs
       * @return Base point
       */
      get: function() {
        var baseValue = this.baseValue;
        var position = this.valueToPosition(baseValue);
        var basePoint = this.renderer.positionToPoint(position);
        return basePoint;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "baseValue", {
      /**
       * @return base value
       */
      get: function() {
        var baseValue = this._baseValue;
        if (this.logarithmic) {
          baseValue = this.min;
        }
        if (!this._adapterO) {
          return baseValue;
        } else {
          return this._adapterO.apply("baseValue", baseValue);
        }
      },
      /**
       * A base value.
       *
       * This is a threshold value that will divide "positive" and "negative"
       * value ranges.
       *
       * Other scale-related functionality also depend on base value. E.g. stacks,
       * value-dependent coloring, etc.
       *
       * @param value Base value
       */
      set: function(value) {
        this._baseValue = value;
        this.invalidateLayout();
        this.invalidateSeries();
      },
      enumerable: true,
      configurable: true
    });
    ValueAxis2.prototype.anyToPosition = function(value) {
      return this.valueToPosition(value);
    };
    ValueAxis2.prototype.valueToPoint = function(value) {
      var position = this.valueToPosition(value);
      var point = this.renderer.positionToPoint(position);
      var angle = this.renderer.positionToAngle(position);
      return { x: point.x, y: point.y, angle };
    };
    ValueAxis2.prototype.anyToPoint = function(value) {
      return this.valueToPoint(value);
    };
    ValueAxis2.prototype.valueToPosition = function(value) {
      if (isNumber(value)) {
        var min_1 = this.min;
        var max_1 = this.max;
        if (isNumber(min_1) && isNumber(max_1)) {
          var difference = this._difference;
          var axisBreaks = this._axisBreaks;
          if (axisBreaks && axisBreaks.length > 0) {
            eachContinue2(axisBreaks.iterator(), function(axisBreak) {
              var startValue = axisBreak.adjustedStartValue;
              var endValue = axisBreak.adjustedEndValue;
              if (isNumber(startValue) && isNumber(endValue)) {
                if (value < startValue) {
                  return false;
                }
                if (intersect({ start: startValue, end: endValue }, { start: min_1, end: max_1 })) {
                  startValue = Math.max(startValue, min_1);
                  endValue = Math.min(endValue, max_1);
                  var breakSize = axisBreak.breakSize;
                  if (value > endValue) {
                    min_1 += (endValue - startValue) * (1 - breakSize);
                  } else if (value < startValue) {
                  } else {
                    value = startValue + (value - startValue) * breakSize;
                  }
                }
              }
              return true;
            });
          }
          var position = void 0;
          if (!this.logarithmic) {
            position = (value - min_1) / difference;
          } else {
            var treatZeroAs = this.treatZeroAs;
            if (isNumber(treatZeroAs)) {
              if (value <= treatZeroAs) {
                value = treatZeroAs;
              }
            }
            position = (Math.log(value) * Math.LOG10E - Math.log(this.min) * Math.LOG10E) / (Math.log(this.max) * Math.LOG10E - Math.log(this.min) * Math.LOG10E);
          }
          return position;
        }
      }
      return 0;
    };
    ValueAxis2.prototype.invalidateLabels = function() {
      _super.prototype.invalidateLabels.call(this);
      if (this.dataItems) {
        this.dataItems.each(function(dataItem) {
          dataItem.value = void 0;
        });
        this.invalidate();
      }
    };
    ValueAxis2.prototype.positionToValue = function(position) {
      var min2 = this.min;
      var max2 = this.max;
      if (isNumber(min2) && isNumber(max2)) {
        var difference_1 = max2 - min2;
        var value_2 = null;
        var axisBreaks = this._axisBreaks;
        if (axisBreaks) {
          if (axisBreaks.length > 0) {
            eachContinue2(axisBreaks.iterator(), function(axisBreak) {
              var breakStartPosition = axisBreak.startPosition;
              var breakEndPosition = axisBreak.endPosition;
              var breakStartValue = axisBreak.adjustedStartValue;
              var breakEndValue = axisBreak.adjustedEndValue;
              if (isNumber(breakStartValue) && isNumber(breakEndValue)) {
                if (breakStartValue > max2) {
                  return false;
                }
                if (intersect({ start: breakStartValue, end: breakEndValue }, { start: min2, end: max2 })) {
                  breakStartValue = max(breakStartValue, min2);
                  breakEndValue = min(breakEndValue, max2);
                  var breakSize = axisBreak.breakSize;
                  difference_1 -= (breakEndValue - breakStartValue) * (1 - breakSize);
                  if (position > breakEndPosition) {
                    min2 += (breakEndValue - breakStartValue) * (1 - breakSize);
                  } else if (position < breakStartPosition) {
                  } else {
                    var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);
                    value_2 = breakStartValue + breakPosition * (breakEndValue - breakStartValue);
                    return false;
                  }
                }
                return true;
              }
            });
          }
        }
        if (!isNumber(value_2)) {
          if (this.logarithmic) {
            value_2 = Math.pow(Math.E, (position * (Math.log(this.max) * Math.LOG10E - Math.log(this.min) * Math.LOG10E) + Math.log(this.min) * Math.LOG10E) / Math.LOG10E);
          } else {
            value_2 = position * difference_1 + min2;
          }
        }
        return value_2;
      }
    };
    ValueAxis2.prototype.xToValue = function(x) {
      return this.positionToValue(this.pointToPosition({ x, y: 0 }));
    };
    ValueAxis2.prototype.yToValue = function(y) {
      return this.positionToValue(this.pointToPosition({ x: 0, y }));
    };
    ValueAxis2.prototype.pointToPosition = function(point) {
      if (this.renderer instanceof AxisRendererY) {
        return 1 - this.renderer.pointToPosition(point);
      } else {
        return this.renderer.pointToPosition(point);
      }
    };
    ValueAxis2.prototype.animateMinMax = function(min2, max2) {
      return this.animate([{ property: "_minAdjusted", from: this._minAdjusted, to: min2 }, { property: "_maxAdjusted", from: this._maxAdjusted, to: max2 }], this.rangeChangeDuration, this.rangeChangeEasing);
    };
    ValueAxis2.prototype.getMinMax = function() {
      var _this = this;
      this.updateGridCount();
      var min2 = Number.POSITIVE_INFINITY;
      var max2 = Number.NEGATIVE_INFINITY;
      if (!isNumber(this._minDefined) || !isNumber(this._maxDefined)) {
        this.series.each(function(series) {
          if (!series.ignoreMinMax) {
            var seriesMin = series.min(_this);
            if (isNumber(seriesMin) && seriesMin < min2) {
              min2 = seriesMin;
            }
            var seriesMax = series.max(_this);
            if (isNumber(seriesMax) && seriesMax > max2) {
              max2 = seriesMax;
            }
          }
        });
        if (this.includeRangesInMinMax) {
          this.axisRanges.each(function(range) {
            if (!range.ignoreMinMax) {
              var minValue = min(range.value, range.endValue);
              var maxValue = max(range.value, range.endValue);
              if (minValue < min2 || !isNumber(min2)) {
                min2 = minValue;
              }
              if (maxValue > max2 || !isNumber(max2)) {
                max2 = maxValue;
              }
            }
          });
        }
      }
      if (this.logarithmic) {
        var treatZeroAs = this.treatZeroAs;
        if (isNumber(treatZeroAs)) {
          if (min2 <= 0) {
            min2 = treatZeroAs;
          }
        }
        if (min2 <= 0) {
          this.raiseCriticalError(new Error("Logarithmic value axis can not have values <= 0."), true);
        }
      }
      if (min2 == 0 && max2 == 0) {
        max2 = 0.9;
        min2 = -0.9;
      }
      if (isNumber(this._minDefined)) {
        min2 = this._minDefined;
      }
      if (isNumber(this._maxDefined)) {
        max2 = this._maxDefined;
      }
      if (this._adapterO) {
        min2 = this._adapterO.apply("min", min2);
      }
      if (this._adapterO) {
        max2 = this._adapterO.apply("max", max2);
      }
      if (!isNumber(min2) || !isNumber(max2)) {
        return;
      }
      this._minReal = min2;
      this._maxReal = max2;
      if (min2 == Number.POSITIVE_INFINITY) {
        min2 = void 0;
      }
      if (max2 == Number.NEGATIVE_INFINITY) {
        max2 = void 0;
      }
      var dif = this.adjustDifference(min2, max2);
      min2 = this.fixMin(min2);
      max2 = this.fixMax(max2);
      if (max2 - min2 <= 1 / Math.pow(10, 15)) {
        if (max2 - min2 != 0) {
          this._deltaMinMax = (max2 - min2) / 2;
        } else {
          var exponent = Math.log(Math.abs(max2)) * Math.LOG10E;
          var power = Math.pow(10, Math.floor(exponent));
          power = power / 10;
          this._deltaMinMax = power;
        }
        min2 -= this._deltaMinMax;
        max2 += this._deltaMinMax;
      }
      min2 -= (max2 - min2) * this.extraMin;
      max2 += (max2 - min2) * this.extraMax;
      var strict = this.strictMinMax;
      if (isNumber(this._maxDefined)) {
        strict = true;
      }
      var minMaxStep = this.adjustMinMax(min2, max2, dif, this._gridCount, strict);
      min2 = minMaxStep.min;
      max2 = minMaxStep.max;
      dif = max2 - min2;
      minMaxStep = this.adjustMinMax(min2, max2, max2 - min2, this._gridCount, true);
      min2 = minMaxStep.min;
      max2 = minMaxStep.max;
      if (this.strictMinMax) {
        if (isNumber(this._minDefined)) {
          min2 = this._minDefined;
        } else {
          min2 = this._minReal;
        }
        if (isNumber(this._maxDefined)) {
          max2 = this._maxDefined;
        } else {
          max2 = this._maxReal;
        }
        if (max2 - min2 <= 1e-8) {
          min2 -= this._deltaMinMax;
          max2 += this._deltaMinMax;
        }
        min2 -= (max2 - min2) * this.extraMin;
        max2 += (max2 - min2) * this.extraMax;
      }
      if (this._adapterO) {
        min2 = this._adapterO.apply("min", min2);
      }
      if (this._adapterO) {
        max2 = this._adapterO.apply("max", max2);
      }
      this._step = minMaxStep.step;
      if (!isNumber(min2) && !isNumber(max2)) {
        this.start = 0;
        this.end = 1;
        this.renderer.labels.each(function(label) {
          label.dataItem.text = "";
        });
      }
      if ((this._minAdjusted != min2 || this._maxAdjusted != max2) && isNumber(min2) && isNumber(max2)) {
        var animation = this._minMaxAnimation;
        if (this._extremesChanged && isNumber(this._minAdjusted) && isNumber(this._maxAdjusted) && this.inited) {
          if (animation && !animation.isFinished() && this._finalMax == max2 && this._finalMin == min2) {
            return;
          } else {
            this._finalMin = min2;
            this._finalMax = max2;
            animation = this.animateMinMax(min2, max2);
            if (animation && !animation.isFinished()) {
              animation.events.on("animationprogress", this.validateDataItems, this);
              animation.events.on("animationended", function() {
                _this.series.each(function(series) {
                  series.validate();
                });
                _this.validateDataItems();
                _this.handleSelectionExtremesChange();
              });
              this._minMaxAnimation = animation;
            } else {
              this.series.each(function(series) {
                series.invalidate();
              });
            }
            this.validateDataItems();
            this.dispatchImmediately("extremeschanged");
            this.handleSelectionExtremesChange();
          }
        } else {
          if (animation && !animation.isFinished() && this._finalMax == max2 && this._finalMin == min2) {
            return;
          } else {
            this._minAdjusted = min2;
            this._maxAdjusted = max2;
            this._finalMin = min2;
            this._finalMax = max2;
            this.invalidateDataItems();
            this.dispatchImmediately("extremeschanged");
            this._saveMinMax(min2, max2);
          }
        }
      }
      this._extremesChanged = false;
      this._difference = this.adjustDifference(min2, max2);
    };
    ValueAxis2.prototype.fixMin = function(value) {
      return value;
    };
    ValueAxis2.prototype.fixMax = function(value) {
      return value;
    };
    ValueAxis2.prototype.adjustMinMax = function(min2, max2, difference, gridCount, strictMode) {
      if (gridCount <= 1) {
        gridCount = 1;
      }
      gridCount = Math.round(gridCount);
      var initialMin = min2;
      var initialMax = max2;
      if (difference === 0) {
        difference = Math.abs(max2);
      }
      var exponent = Math.log(Math.abs(difference)) * Math.LOG10E;
      var power = Math.pow(10, Math.floor(exponent));
      power = power / 10;
      var extra = power;
      if (strictMode) {
        extra = 0;
      }
      if (!this.logarithmic) {
        if (strictMode) {
          min2 = Math.floor(min2 / power) * power;
          max2 = Math.ceil(max2 / power) * power;
        } else {
          min2 = Math.ceil(min2 / power) * power - extra;
          max2 = Math.floor(max2 / power) * power + extra;
        }
        if (min2 < 0 && initialMin >= 0) {
          min2 = 0;
        }
        if (max2 > 0 && initialMax <= 0) {
          max2 = 0;
        }
      } else {
        if (min2 <= 0) {
          min2 = this.baseValue;
        }
        if (min2 == Infinity) {
          min2 = 1;
        }
        if (max2 == -Infinity) {
          max2 = 10;
        }
        if (this.strictMinMax) {
          if (this._minDefined > 0) {
            min2 = this._minDefined;
          } else {
            min2 = min2;
          }
          if (this._maxDefined > 0) {
            max2 = max2;
          }
        } else {
          min2 = Math.pow(10, Math.floor(Math.log(Math.abs(min2)) * Math.LOG10E));
          max2 = Math.pow(10, Math.ceil(Math.log(Math.abs(max2)) * Math.LOG10E));
        }
      }
      exponent = Math.log(Math.abs(difference)) * Math.LOG10E;
      power = Math.pow(10, Math.floor(exponent));
      power = power / 10;
      var step = Math.ceil(difference / gridCount / power) * power;
      var stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));
      var stepDivisor = Math.ceil(step / stepPower);
      if (stepDivisor > 5) {
        stepDivisor = 10;
      } else if (stepDivisor <= 5 && stepDivisor > 2) {
        stepDivisor = 5;
      }
      step = Math.ceil(step / (stepPower * stepDivisor)) * stepPower * stepDivisor;
      if (this.maxPrecision < Number.MAX_VALUE && step != ceil(step, this.maxPrecision)) {
        step = ceil(step, this.maxPrecision);
      }
      var decCount = 0;
      if (stepPower < 1) {
        decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 1;
        step = round(step, decCount);
      }
      if (!this.logarithmic) {
        var minCount = Math.floor(min2 / step);
        min2 = round(step * minCount, decCount);
        var maxCount = void 0;
        if (!strictMode) {
          maxCount = Math.ceil(max2 / step);
        } else {
          maxCount = Math.floor(max2 / step);
        }
        if (maxCount == minCount) {
          maxCount++;
        }
        max2 = round(step * maxCount, decCount);
        if (max2 < initialMax) {
          max2 = max2 + step;
        }
        if (min2 > initialMin) {
          min2 = min2 - step;
        }
      }
      return { min: min2, max: max2, step };
    };
    Object.defineProperty(ValueAxis2.prototype, "min", {
      /**
       * @return Min value
       */
      get: function() {
        var min2 = this._minAdjusted;
        if (!isNumber(min2)) {
          min2 = this._minDefined;
        }
        return min2;
      },
      /**
       * A minimum value for the axis scale.
       *
       * This value might be auto-adjusted by the Axis in order to accomodate the
       * grid nicely, i.e. plot area is divided by grid in nice equal cells.
       *
       * The above might be overridden by `strictMinMax` which will force exact
       * user-defined min and max values to be used for scale.
       *
       * @param value  Min value
       */
      set: function(value) {
        if (this._minDefined != value) {
          this._minDefined = value;
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "minDefined", {
      /**
       * Min value as defined by user's code, not auto-calculated.
       *
       * @readonly
       * @return Min value
       */
      get: function() {
        return this._minDefined;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "maxDefined", {
      /**
       * Max value as defined by user's code, not auto-calculated.
       *
       * @readonly
       * @return Man value
       */
      get: function() {
        return this._maxDefined;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "extraMin", {
      /**
       * @return {number}
       */
      get: function() {
        return this.getPropertyValue("extraMin");
      },
      /**
       * Allows relatively adjusting minimum value of the axis' scale.
       *
       * The value is relative to the actual range of values currently displayed
       * on the axis.
       *
       * E.g.: 0.5 will mean half of the current range. If we have axis displaying
       * from 100 to 200, we will now have axis displaying from 50 to 200 because
       * we asked to expand minimum value by 50% (0.5).
       *
       * NOTE: this setting is not compatible with `strictMinMax`.
       *
       * @param {number}
       */
      set: function(value) {
        if (this.setPropertyValue("extraMin", value)) {
          this.invalidateDataItems();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "extraMax", {
      /**
       * @return Min multiplier
       */
      get: function() {
        return this.getPropertyValue("extraMax");
      },
      /**
       * Allows relatively adjusting maximum value of the axis' scale.
       *
       * The value is relative to the actual range of values currently displayed
       * on the axis.
       *
       * E.g.: 0.5 will mean half of the current range. If we have axis displaying
       * from 100 to 200, we will now have axis displaying from 100 to 250 because
       * we asked to expand maximum value by 50% (0.5).
       *
       * NOTE: this setting is not compatible with `strictMinMax`.
       *
       * @param {number}
       */
      set: function(value) {
        if (this.setPropertyValue("extraMax", value)) {
          this.invalidateDataItems();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "step", {
      /**
       * Current calculated delta in values between two adjacent grid lines (step).
       *
       * This is a read-only value and cannot be used to set actual step.
       *
       * @readonly
       * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/positioning-axis-elements/#Setting_the_density_of_the_the_grid_labels} For more information about modifying density of labels
       * @return [description]
       */
      get: function() {
        return this._step;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "max", {
      /**
       * @return Max value
       */
      get: function() {
        var max2 = this._maxAdjusted;
        if (!isNumber(max2)) {
          max2 = this._maxDefined;
        }
        return max2;
      },
      /**
       * A maximum value for the axis scale.
       *
       * This value might be auto-adjusted by the Axis in order to accomodate the
       * grid nicely, i.e. plot area is divided by grid in nice equal cells.
       *
       * The above might be overridden by `strictMinMax` which will force exact
       * user-defined min and max values to be used for scale.
       *
       * @param value  Max value
       */
      set: function(value) {
        if (this._maxDefined != value) {
          this._maxDefined = value;
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "adjustLabelPrecision", {
      /**
       * @return Adjust precision
       */
      get: function() {
        return this.getPropertyValue("adjustLabelPrecision");
      },
      /**
       * By default the axis will adjust precision of all numbers to match number
       * of decimals in all its labels, e.g.: `1.0`, `1.5`, `2.0`.
       *
       * To disable set `adjustLabelPrecision` to `false`, to use whatever other
       * precision or number format settings are set.
       *
       * IMPORTANT: This setting will be ignored if your number format uses
       * modifiers, e.g. `"#a"`.
       *
       * @default true
       * @since 4.9.14
       * @param  value  Adjust precision
       */
      set: function(value) {
        if (this.setPropertyValue("adjustLabelPrecision", value)) {
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    ValueAxis2.prototype.registerSeries = function(series) {
      return new MultiDisposer([
        _super.prototype.registerSeries.call(this, series),
        series.events.on("extremeschanged", this.handleExtremesChange, this, false),
        series.events.on("selectionextremeschanged", this.handleSelectionExtremesChange, this, false),
        this.events.on("extremeschanged", series.invalidate, series, false)
      ]);
    };
    ValueAxis2.prototype.handleSelectionExtremesChange = function() {
      var _this = this;
      var selectionMin;
      var selectionMax;
      var allHidden = true;
      each3(this.series.iterator(), function(series) {
        if (!series.ignoreMinMax && !series.isHidden && !series.outOfRange) {
          if (series.visible && !series.isHiding) {
            allHidden = false;
          }
          var seriesSelectionMin = series.selectionMin(_this);
          var seriesSelectionMax = series.selectionMax(_this);
          if (isNumber(seriesSelectionMin)) {
            if (!isNumber(selectionMin) || seriesSelectionMin < selectionMin) {
              selectionMin = seriesSelectionMin;
            }
          }
          if (isNumber(seriesSelectionMax)) {
            if (!isNumber(selectionMax) || seriesSelectionMax > selectionMax) {
              selectionMax = seriesSelectionMax;
            }
          }
        }
      });
      if (this.includeRangesInMinMax) {
        this.axisRanges.each(function(range) {
          if (!range.ignoreMinMax) {
            var minValue = min(range.value, range.endValue);
            var maxValue = max(range.value, range.endValue);
            if (minValue < selectionMin) {
              selectionMin = minValue;
            }
            if (maxValue > selectionMax) {
              selectionMax = maxValue;
            }
          }
        });
      }
      if (isNumber(this._minDefined)) {
        if (this.strictMinMax) {
          selectionMin = this._minDefined;
        } else {
          selectionMin = this.min;
        }
      } else if (this.strictMinMax) {
        selectionMin = this._minReal;
      }
      if (isNumber(this._maxDefined)) {
        if (this.strictMinMax) {
          selectionMax = this._maxDefined;
        } else {
          selectionMax = this.max;
        }
      } else if (this.strictMinMax) {
        selectionMax = this._maxReal;
      }
      if (selectionMin == selectionMax) {
        selectionMin -= this._deltaMinMax;
        selectionMax += this._deltaMinMax;
        var minMaxStep2 = this.adjustMinMax(selectionMin, selectionMax, 0, this._gridCount, this.strictMinMax);
        selectionMin = minMaxStep2.min;
        selectionMax = minMaxStep2.max;
      }
      var dif = this.adjustDifference(selectionMin, selectionMax);
      var minMaxStep = this.adjustMinMax(selectionMin, selectionMax, dif, this._gridCount);
      selectionMin = minMaxStep.min;
      selectionMax = minMaxStep.max;
      selectionMin -= (selectionMax - selectionMin) * this.extraMin;
      selectionMax += (selectionMax - selectionMin) * this.extraMax;
      selectionMin = fitToRange(selectionMin, this.min, this.max);
      selectionMax = fitToRange(selectionMax, this.min, this.max);
      dif = this.adjustDifference(selectionMin, selectionMax);
      minMaxStep = this.adjustMinMax(selectionMin, selectionMax, dif, this._gridCount, true);
      selectionMin = minMaxStep.min;
      selectionMax = minMaxStep.max;
      if (this.strictMinMax) {
        selectionMin = max(selectionMin, this._minDefined);
        selectionMax = min(selectionMax, this._maxDefined);
      }
      var step = minMaxStep.step;
      if (this.syncWithAxis) {
        minMaxStep = this.syncAxes(selectionMin, selectionMax, step);
        selectionMin = minMaxStep.min;
        selectionMax = minMaxStep.max;
        this.invalidate();
      }
      step = minMaxStep.step;
      this._difference = this.adjustDifference(this.min, this.max);
      var start = this.valueToPosition(selectionMin);
      var end = this.valueToPosition(selectionMax);
      if (allHidden && !this.syncWithAxis) {
        start = 0;
        end = 1;
      }
      var declination = 0;
      if (this.syncWithAxis) {
        declination = 5;
        this.setCache(selectionMin + "-" + selectionMax, step);
      } else {
        if (this._step != step || this._minZoomed != selectionMin || this._maxZoomed != selectionMax) {
          this._dsc = true;
        }
        this._step = step;
        this._minZoomed = selectionMin;
        this._maxZoomed = selectionMax;
      }
      if (!this.keepSelection) {
        this.zoom({ start, end }, false, false, declination);
      }
    };
    Object.defineProperty(ValueAxis2.prototype, "strictMinMax", {
      /**
       * @return Use exact values?
       */
      get: function() {
        return this.getPropertyValue("strictMinMax");
      },
      /**
       * Indicates whether to blindly use exact `min` and `max` values set by user
       * when generating Axis scale.
       *
       * If not set, the Axis might slightly adjust those values to accomodate a
       * better looking grid.
       *
       * NOTE: if `min` and `max` are not set, setting `strictMinMax` to `true`
       * will result in fixing the scale of the axis to actual lowest and highest
       * values in the series within currently selected scope.
       *
       * @default false
       * @param value Use exact values?
       */
      set: function(value) {
        if (this.setPropertyValue("strictMinMax", value)) {
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "logarithmic", {
      /**
       * @return Logarithmic scale?
       */
      get: function() {
        return this.getPropertyValue("logarithmic");
      },
      /**
       * Indicates if this axis should use a logarithmic scale.
       *
       * Please note that logarithmic axis can **only** accommodate values bigger
       * than zero.
       *
       * Having zero or negative values will result in error and failure of the
       * whole chart.
       *
       * @param value Logarithmic scale?
       */
      set: function(value) {
        if (this.setPropertyValue("logarithmic", value)) {
          this.invalidate();
          this.series.each(function(series) {
            series.invalidateDataItems();
          });
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "keepSelection", {
      /**
       * @return Preseve zoom after data update?
       */
      get: function() {
        return this.getPropertyValue("keepSelection");
      },
      /**
       * Indicates if a current selection (zoom) should be kept across data updates.
       *
       * If your axis is zoomed while chart's data is updated, the axis will try
       * to retain the same start and end values.
       *
       * You can also use this to initially pre-zoom axis:
       *
       * ```TypeScript
       * axis.keepSelection = true;
       * axis.start = 0.5;
       * axis.end = 0.7;
       * ```
       * ```JavaScript
       * axis.keepSelection = true;
       * axis.start = 0.5;
       * axis.end = 0.7;
       * ```
       * ```JSON
       * {
       *   "xAxes": [{
       *     // ...
       *     "keepSelection": true,
       *     "start": 0.5,
       *     "end": 0.7
       *   }]
       * }
       * ```
       *
       * The above will start the chart zoomed from the middle of the actual scope
       * to 70%.
       *
       * @since 4.1.1
       * @default false
       * @param  value  Preseve zoom after data update?
       */
      set: function(value) {
        this.setPropertyValue("keepSelection", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "includeRangesInMinMax", {
      /**
       * @return Include ranges?
       */
      get: function() {
        return this.getPropertyValue("includeRangesInMinMax");
      },
      /**
       * If set to `true`, values of axis ranges will be included when calculating
       * range of values / scale of the [[ValueAxis]].
       *
       * @default false
       * @since 4.4.9
       * @param  value  Include ranges?
       */
      set: function(value) {
        this.setPropertyValue("includeRangesInMinMax", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "maxPrecision", {
      /**
       * @return max precision
       */
      get: function() {
        return this.getPropertyValue("maxPrecision");
      },
      /**
       * Maximum number of decimals to allow when placing grid lines and labels
       * on axis.
       *
       * Set it to `0` (zero) to force integer-only axis labels.
       *
       * @param {number}
       */
      set: function(value) {
        if (this.setPropertyValue("maxPrecision", value)) {
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "extraTooltipPrecision", {
      /**
       * @return Extra decimals
       */
      get: function() {
        return this.getPropertyValue("extraTooltipPrecision");
      },
      /**
       * This setting allows using bigger precision for numbers displayed in axis
       * tooltip.
       *
       * Please note that this setting indicates additional decimal places to
       * automatically-calculated axis number precision.
       *
       * So if your axis displays numbers like 0.1, 0.2, etc. (one decimal place),
       * and you set `extraTooltipPrecision = 1`, tooltips will display numbers
       * like 0.12, 0.25, etc. (two decimal places).
       *
       * @default 0
       * @since 4.8.3
       * @param  value  Extra decimals
       */
      set: function(value) {
        if (this.setPropertyValue("extraTooltipPrecision", value)) {
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    ValueAxis2.prototype.handleExtremesChange = function() {
      var _this = this;
      this._extremesChanged = true;
      this.getMinMax();
      if (this.ghostLabel) {
        var mw_1 = 0;
        this.dataItems.each(function(dataItem) {
          if (dataItem.label && dataItem.label.pixelWidth > mw_1) {
            _this.ghostLabel.text = dataItem.label.currentText;
          }
        });
      }
    };
    ValueAxis2.prototype.getX = function(dataItem, key, location, stackKey, range) {
      return this.renderer.positionToPoint(this.getPositionX(dataItem, key, location, stackKey, range)).x;
    };
    ValueAxis2.prototype.getPositionX = function(dataItem, key, location, stackKey, range) {
      var value = dataItem.getWorkingValue(key);
      if (!hasValue(stackKey)) {
        stackKey = "valueX";
      }
      var stack = dataItem.getValue(stackKey, "stack");
      if (!isNumber(value)) {
        value = this.baseValue;
        if (this.logarithmic) {
          if (stack > 0) {
            value = 0;
          }
        }
      }
      var position = this.valueToPosition(value + stack);
      if (range) {
        position = fitToRange(position, range.start, range.end);
      }
      return position;
    };
    ValueAxis2.prototype.getY = function(dataItem, key, location, stackKey, range) {
      return this.renderer.positionToPoint(this.getPositionY(dataItem, key, location, stackKey, range)).y;
    };
    ValueAxis2.prototype.getPositionY = function(dataItem, key, location, stackKey, range) {
      var value = dataItem.getWorkingValue(key);
      if (!hasValue(stackKey)) {
        stackKey = "valueY";
      }
      var stack = dataItem.getValue(stackKey, "stack");
      if (!isNumber(value)) {
        value = this.baseValue;
        if (this.logarithmic) {
          if (stack > 0) {
            value = 0;
          }
        }
      }
      var position = this.valueToPosition(value + stack);
      if (range) {
        position = fitToRange(position, range.start, range.end);
      }
      return position;
    };
    ValueAxis2.prototype.getAngle = function(dataItem, key, location, stackKey, range) {
      var value = dataItem.getWorkingValue(key);
      var stack = dataItem.getValue(stackKey, "stack");
      if (!isNumber(value)) {
        value = this.baseValue;
      }
      var position = this.valueToPosition(value + stack);
      if (range) {
        position = fitToRange(position, range.start, range.end);
      }
      return this.positionToAngle(position);
    };
    ValueAxis2.prototype.getAnyRangePath = function(start, end, location) {
      var startPosition = this.valueToPosition(start);
      var endPosition = this.valueToPosition(end);
      return this.getPositionRangePath(startPosition, endPosition);
    };
    ValueAxis2.prototype.getTooltipText = function(position) {
      var value = round(this.positionToValue(position), this._stepDecimalPlaces + this.extraTooltipPrecision);
      var valueStr = this.tooltip.numberFormatter.format(value);
      if (!this._adapterO) {
        return valueStr;
      } else {
        return this._adapterO.apply("getTooltipText", valueStr);
      }
    };
    ValueAxis2.prototype.zoomToValues = function(startValue, endValue, skipRangeEvent, instantly) {
      var start = (startValue - this.min) / (this.max - this.min);
      var end = (endValue - this.min) / (this.max - this.min);
      this.zoom({ start, end }, skipRangeEvent, instantly);
    };
    Object.defineProperty(ValueAxis2.prototype, "minZoomed", {
      /**
       * A smallest value in axis scale within current zoom.
       *
       * @return Min zoom value
       */
      get: function() {
        if (!this.syncWithAxis) {
          return max(this.min, this._minZoomed);
        } else {
          return this._minZoomed;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "maxZoomed", {
      /**
       * A biggest value in axis scale within current zoom.
       * @return [description]
       */
      get: function() {
        if (!this.syncWithAxis) {
          return min(this.max, this._maxZoomed);
        } else {
          return this._maxZoomed;
        }
      },
      enumerable: true,
      configurable: true
    });
    ValueAxis2.prototype.fixAxisBreaks = function() {
      var _this = this;
      _super.prototype.fixAxisBreaks.call(this);
      var axisBreaks = this._axisBreaks;
      if (axisBreaks && axisBreaks.length > 0) {
        axisBreaks.each(function(axisBreak) {
          var startValue = axisBreak.adjustedStartValue;
          var endValue = axisBreak.adjustedEndValue;
          var axisBreakDif = endValue - startValue;
          var axisBreakGridCount = Math.ceil(axisBreakDif * axisBreak.breakSize) * _this._gridCount / (_this.max - _this.min);
          var breakMinMaxStep = _this.adjustMinMax(startValue, endValue, axisBreakDif, axisBreakGridCount, true);
          axisBreak.adjustedStep = breakMinMaxStep.step;
          axisBreak.adjustedMin = breakMinMaxStep.min;
          axisBreak.adjustedMax = breakMinMaxStep.max;
        });
      }
      this._difference = this.adjustDifference(this.min, this.max);
    };
    ValueAxis2.prototype.getPositionLabel = function(position) {
      var value = this.positionToValue(position);
      return this.numberFormatter.format(value);
    };
    ValueAxis2.prototype.showTooltipAt = function(value) {
      this.showTooltipAtPosition(this.valueToPosition(value));
    };
    ValueAxis2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.min = source.min;
      this.max = source.max;
      this.calculateTotals = source.calculateTotals;
      this._baseValue = source.baseValue;
    };
    Object.defineProperty(ValueAxis2.prototype, "syncWithAxis", {
      /**
       * @return Target axis
       */
      get: function() {
        return this.getPropertyValue("syncWithAxis");
      },
      /**
       * Enables syncing of grid with another axis.
       *
       * To enable, set to a reference of the other `ValueAxis`. This axis will try
       * to maintain its scale in such way that its grid matches target axis grid.
       *
       * IMPORTANT #1: At this stage it's an experimental feature. Use it at your
       * own risk, as it may not work in 100% of the scenarios.
       *
       * IMPORTANT #2: `syncWithAxis` is not compatible with `strictMinMax` and
       * `sequencedInterpolation` settings.
       *
       * IMPORTANT #3: `syncWithAxis` is not compatible with scrollbars. Make sure
       * you do not add a scrollbar in the same direction as synced axes. For
       * example, if you have vertical synced axes, do not add `scrollbarY` on
       * your chart. It will create anomalies when used.
       *
       * IMPORTANT #4: `syncWithAxis` is not compatible with `XYCursor` if it has
       * its `behavior` set to either `zoomY` or `zoomXY`.
       *
       * @since 4.8.1
       * @param  axis  Target axis
       */
      set: function(axis) {
        var _this = this;
        if (this.setPropertyValue("syncWithAxis", axis, true)) {
          if (axis) {
            this._disposers.push(axis.events.on("extremeschanged", this.handleSelectionExtremesChange, this, false));
            this._disposers.push(axis.events.on("selectionextremeschanged", this.handleSelectionExtremesChange, this, false));
            this._disposers.push(axis.events.on("startendchanged", this.handleSelectionExtremesChange, this, false));
            this.events.on("shown", this.handleSelectionExtremesChange, this, false);
            this.events.on("maxsizechanged", function() {
              _this.clearCache();
              _this._disposers.push(registry.events.once("exitframe", function() {
                _this.handleSelectionExtremesChange();
              }));
            }, this, false);
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ValueAxis2.prototype, "treatZeroAs", {
      /**
       * @return Zero replacement value
       */
      get: function() {
        return this.getPropertyValue("treatZeroAs");
      },
      /**
       * If set, zero values will be treated as this value.
       *
       * It is useful if you need to use data with zero-values on a logarithmic
       * axis scale.
       *
       * @since 4.9.34
       * @param  value  Zero replacement value
       */
      set: function(value) {
        this.setPropertyValue("treatZeroAs", value, true);
      },
      enumerable: true,
      configurable: true
    });
    ValueAxis2.prototype.syncAxes = function(min2, max2, step) {
      var axis = this.syncWithAxis;
      if (axis) {
        if (!isNumber(min2)) {
          min2 = this.min;
        }
        if (!isNumber(max2)) {
          max2 = this.max;
        }
        if (!isNumber(step)) {
          step = this._step;
        }
        var count = Math.round((axis.maxZoomed - axis.minZoomed) / axis.step);
        var currentCount = Math.round((max2 - min2) / step);
        if (isNumber(count) && isNumber(currentCount)) {
          var synced = false;
          var c = 0;
          var diff = (max2 - min2) * 0.01;
          var omin = min2;
          var omax = max2;
          var ostep = step;
          while (synced != true) {
            synced = this.checkSync(omin, omax, ostep, count);
            c++;
            if (c > 1e3) {
              synced = true;
            }
            if (!synced) {
              if (c / 3 == Math.round(c / 3)) {
                omin = min2 - diff * c;
                if (min2 >= 0 && omin < 0) {
                  omin = 0;
                }
              } else {
                omax = max2 + diff * c;
                if (omax <= 0 && omax > 0) {
                  omax = 0;
                }
              }
              var minMaxStep = this.adjustMinMax(omin, omax, omax - omin, this._gridCount, true);
              omin = minMaxStep.min;
              omax = minMaxStep.max;
              ostep = minMaxStep.step;
            } else {
              min2 = omin;
              max2 = omax;
              step = ostep;
            }
          }
        }
      }
      return { min: min2, max: max2, step };
    };
    ValueAxis2.prototype.checkSync = function(min2, max2, step, count) {
      var currentCount = (max2 - min2) / step;
      for (var i = 1; i < count; i++) {
        if (round(currentCount / i, 1) == count || currentCount * i == count) {
          return true;
        }
      }
      return false;
    };
    ValueAxis2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config.syncWithAxis) && isString(config.syncWithAxis)) {
          if (this.map.hasKey(config.syncWithAxis)) {
            config.syncWithAxis = this.map.getKey(config.syncWithAxis);
          } else {
            this.processingErrors.push('[ValueAxis] No axis with id "' + config.syncWithAxis + '" found for `syncWithAxis`');
            delete config.xAxis;
          }
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    ValueAxis2.prototype._saveMinMax = function(_min, _max) {
    };
    return ValueAxis2;
  }(Axis)
);
registry.registeredClasses["ValueAxis"] = ValueAxis;
registry.registeredClasses["ValueAxisDataItem"] = ValueAxisDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/DateAxisBreak.js
var DateAxisBreak = (
  /** @class */
  function(_super) {
    __extends(DateAxisBreak2, _super);
    function DateAxisBreak2() {
      var _this = _super.call(this) || this;
      _this.className = "DateAxisBreak";
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(DateAxisBreak2.prototype, "startDate", {
      /**
       * @return Start date
       */
      get: function() {
        return this.getPropertyValue("startDate");
      },
      /**
       * Starting date for the break.
       *
       * @param value Start date
       */
      set: function(value) {
        if (this.setPropertyValue("startDate", value)) {
          this.startValue = value.getTime();
          if (this.axis) {
            this.axis.invalidate();
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateAxisBreak2.prototype, "endDate", {
      /**
       * @return End date
       */
      get: function() {
        return this.getPropertyValue("endDate");
      },
      /**
       * Ending date for the break.
       *
       * @param value End date
       */
      set: function(value) {
        if (this.setPropertyValue("endDate", value)) {
          this.endValue = value.getTime();
          if (this.axis) {
            this.axis.invalidate();
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    return DateAxisBreak2;
  }(ValueAxisBreak)
);
registry.registeredClasses["DateAxisBreak"] = DateAxisBreak;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/DateAxis.js
var DateAxisDataItem = (
  /** @class */
  function(_super) {
    __extends(DateAxisDataItem2, _super);
    function DateAxisDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "DateAxisDataItem";
      _this.applyTheme();
      _this.values.date = {};
      _this.values.endDate = {};
      return _this;
    }
    Object.defineProperty(DateAxisDataItem2.prototype, "date", {
      /**
       * @return Date
       */
      get: function() {
        return this.dates["date"];
      },
      /**
       * Date position of the data item.
       *
       * @param date  Date
       */
      set: function(date) {
        this.setDate("date", date);
        this.value = date.getTime();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateAxisDataItem2.prototype, "endDate", {
      /**
       * @return End date
       */
      get: function() {
        return this.dates["endDate"];
      },
      /**
       * End date for data item.
       *
       * @param date End date
       */
      set: function(date) {
        this.setDate("endDate", date);
        this.endValue = date.getTime();
      },
      enumerable: true,
      configurable: true
    });
    return DateAxisDataItem2;
  }(ValueAxisDataItem)
);
var DateAxis = (
  /** @class */
  function(_super) {
    __extends(DateAxis2, _super);
    function DateAxis2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._gapBreaks = false;
      _this.gridIntervals = new List();
      _this.groupIntervals = new List();
      _this.dateFormats = new Dictionary();
      _this.periodChangeDateFormats = new Dictionary();
      _this._baseIntervalReal = { timeUnit: "day", count: 1 };
      _this._prevSeriesTime = {};
      _this._minDifference = {};
      _this._firstWeekDay = 1;
      _this.groupMin = {};
      _this.groupMax = {};
      _this._intervalMax = {};
      _this._intervalMin = {};
      _this.className = "DateAxis";
      _this.setPropertyValue("markUnitChange", true);
      _this.snapTooltip = true;
      _this.tooltipPosition = "pointer";
      _this.setPropertyValue("groupData", false);
      _this.groupCount = 200;
      _this.events.on("parentset", _this.getDFFormatter, _this, false);
      _this.gridIntervals.pushAll([
        { timeUnit: "millisecond", count: 1 },
        { timeUnit: "millisecond", count: 5 },
        { timeUnit: "millisecond", count: 10 },
        { timeUnit: "millisecond", count: 50 },
        { timeUnit: "millisecond", count: 100 },
        { timeUnit: "millisecond", count: 500 },
        { timeUnit: "second", count: 1 },
        { timeUnit: "second", count: 5 },
        { timeUnit: "second", count: 10 },
        { timeUnit: "second", count: 30 },
        { timeUnit: "minute", count: 1 },
        { timeUnit: "minute", count: 5 },
        { timeUnit: "minute", count: 10 },
        { timeUnit: "minute", count: 15 },
        { timeUnit: "minute", count: 30 },
        { timeUnit: "hour", count: 1 },
        { timeUnit: "hour", count: 3 },
        { timeUnit: "hour", count: 6 },
        { timeUnit: "hour", count: 12 },
        { timeUnit: "day", count: 1 },
        { timeUnit: "day", count: 2 },
        { timeUnit: "day", count: 3 },
        { timeUnit: "day", count: 4 },
        { timeUnit: "day", count: 5 },
        { timeUnit: "week", count: 1 },
        { timeUnit: "month", count: 1 },
        { timeUnit: "month", count: 2 },
        { timeUnit: "month", count: 3 },
        { timeUnit: "month", count: 6 },
        { timeUnit: "year", count: 1 },
        { timeUnit: "year", count: 2 },
        { timeUnit: "year", count: 5 },
        { timeUnit: "year", count: 10 },
        { timeUnit: "year", count: 50 },
        { timeUnit: "year", count: 100 },
        { timeUnit: "year", count: 200 },
        { timeUnit: "year", count: 500 },
        { timeUnit: "year", count: 1e3 },
        { timeUnit: "year", count: 2e3 },
        { timeUnit: "year", count: 5e3 },
        { timeUnit: "year", count: 1e4 },
        { timeUnit: "year", count: 1e5 }
      ]);
      _this.groupIntervals.pushAll([
        { timeUnit: "millisecond", count: 1 },
        { timeUnit: "millisecond", count: 10 },
        { timeUnit: "millisecond", count: 100 },
        { timeUnit: "second", count: 1 },
        { timeUnit: "second", count: 10 },
        { timeUnit: "minute", count: 1 },
        { timeUnit: "minute", count: 10 },
        { timeUnit: "hour", count: 1 },
        { timeUnit: "day", count: 1 },
        { timeUnit: "week", count: 1 },
        { timeUnit: "month", count: 1 },
        { timeUnit: "year", count: 1 }
      ]);
      _this.axisFieldName = "date";
      _this.applyTheme();
      return _this;
    }
    DateAxis2.prototype.fillRule = function(dataItem) {
      var value = dataItem.value;
      var axis = dataItem.component;
      var gridInterval = axis._gridInterval;
      var gridDuration = getDuration(gridInterval.timeUnit, gridInterval.count);
      if (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {
        dataItem.axisFill.__disabled = true;
      } else {
        dataItem.axisFill.__disabled = false;
      }
    };
    DateAxis2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!this.dateFormats.hasKey("millisecond")) {
        this.dateFormats.setKey("millisecond", this.language.translate("_date_millisecond"));
      }
      if (!this.dateFormats.hasKey("second")) {
        this.dateFormats.setKey("second", this.language.translate("_date_second"));
      }
      if (!this.dateFormats.hasKey("minute")) {
        this.dateFormats.setKey("minute", this.language.translate("_date_minute"));
      }
      if (!this.dateFormats.hasKey("hour")) {
        this.dateFormats.setKey("hour", this.language.translate("_date_hour"));
      }
      if (!this.dateFormats.hasKey("day")) {
        this.dateFormats.setKey("day", this.language.translate("_date_day"));
      }
      if (!this.dateFormats.hasKey("week")) {
        this.dateFormats.setKey("week", this.language.translate("_date_day"));
      }
      if (!this.dateFormats.hasKey("month")) {
        this.dateFormats.setKey("month", this.language.translate("_date_month"));
      }
      if (!this.dateFormats.hasKey("year")) {
        this.dateFormats.setKey("year", this.language.translate("_date_year"));
      }
      if (!this.periodChangeDateFormats.hasKey("millisecond")) {
        this.periodChangeDateFormats.setKey("millisecond", this.language.translate("_date_millisecond"));
      }
      if (!this.periodChangeDateFormats.hasKey("second")) {
        this.periodChangeDateFormats.setKey("second", this.language.translate("_date_second"));
      }
      if (!this.periodChangeDateFormats.hasKey("minute")) {
        this.periodChangeDateFormats.setKey("minute", this.language.translate("_date_minute"));
      }
      if (!this.periodChangeDateFormats.hasKey("hour")) {
        this.periodChangeDateFormats.setKey("hour", this.language.translate("_date_day"));
      }
      if (!this.periodChangeDateFormats.hasKey("day")) {
        this.periodChangeDateFormats.setKey("day", this.language.translate("_date_day"));
      }
      if (!this.periodChangeDateFormats.hasKey("week")) {
        this.periodChangeDateFormats.setKey("week", this.language.translate("_date_day"));
      }
      if (!this.periodChangeDateFormats.hasKey("month")) {
        this.periodChangeDateFormats.setKey("month", this.language.translate("_date_month") + " " + this.language.translate("_date_year"));
      }
    };
    DateAxis2.prototype.createDataItem = function() {
      return new DateAxisDataItem();
    };
    DateAxis2.prototype.createAxisBreak = function() {
      return new DateAxisBreak();
    };
    DateAxis2.prototype.validateDataItems = function() {
      var start = this.start;
      var end = this.end;
      var baseDuration = this.baseDuration;
      var periodCount = (this.max - this.min) / baseDuration;
      this._firstWeekDay = this.getFirstWeekDay();
      this.getDFFormatter();
      _super.prototype.validateDataItems.call(this);
      var mainBaseDuration = getDuration(this.mainBaseInterval.timeUnit, this.mainBaseInterval.count);
      this.maxZoomFactor = Math.max(1, (this.max - this.min) / mainBaseDuration);
      this._deltaMinMax = this.baseDuration / 2;
      var newPeriodCount = (this.max - this.min) / baseDuration;
      start = start + (end - start) * (1 - periodCount / newPeriodCount);
      this.zoom({ start, end }, false, true);
    };
    DateAxis2.prototype.handleSelectionExtremesChange = function() {
    };
    DateAxis2.prototype.getIntervalMax = function(interval) {
      return this._intervalMax[interval.timeUnit + interval.count];
    };
    DateAxis2.prototype.getIntervalMin = function(interval) {
      return this._intervalMin[interval.timeUnit + interval.count];
    };
    DateAxis2.prototype.calculateZoom = function() {
      var _this = this;
      _super.prototype.calculateZoom.call(this);
      var difference = this.adjustDifference(this._minZoomed, this._maxZoomed);
      var dataSetChanged = false;
      if (this.groupData && hasValue(difference)) {
        var mainBaseInterval = this.mainBaseInterval;
        var min2 = this.getIntervalMin(mainBaseInterval);
        var max2 = this.getIntervalMax(mainBaseInterval);
        var selectionMin = min2 + (max2 - min2) * this.start;
        var selectionMax = min2 + (max2 - min2) * this.end;
        var diff = this.adjustDifference(selectionMin, selectionMax);
        var modifiedDifference = diff + (this.startLocation + (1 - this.endLocation)) * this.baseDuration;
        var groupInterval = void 0;
        if (this.groupInterval) {
          groupInterval = __assign({}, this.groupInterval);
        } else {
          groupInterval = this.chooseInterval(0, modifiedDifference, this.groupCount, this.groupIntervals);
          if (getDuration(groupInterval.timeUnit, groupInterval.count) < getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count)) {
            groupInterval = __assign({}, mainBaseInterval);
          }
        }
        this._groupInterval = groupInterval;
        var newId = groupInterval.timeUnit + groupInterval.count;
        if (this._currentDataSetId != newId) {
          this._currentDataSetId = newId;
          this.dispatch("groupperiodchanged");
        }
        this.series.each(function(series) {
          if (series.baseAxis == _this) {
            if (series.setDataSet(_this._currentDataSetId)) {
              dataSetChanged = true;
            }
          }
        });
      }
      var gridInterval = this.chooseInterval(0, difference, this._gridCount);
      if (getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {
        gridInterval = __assign({}, this.baseInterval);
      }
      this._gridInterval = gridInterval;
      this._nextGridUnit = getNextUnit(gridInterval.timeUnit);
      this._intervalDuration = getDuration(gridInterval.timeUnit, gridInterval.count);
      this._gridDate = round2(new Date(this.minZoomed - getDuration(gridInterval.timeUnit, gridInterval.count)), gridInterval.timeUnit, gridInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);
      each3(this.series.iterator(), function(series) {
        if (series.baseAxis == _this) {
          var field_1 = series.getAxisField(_this);
          var minZoomed = round2(new Date(_this._minZoomed + _this.baseDuration * 0.05), _this.baseInterval.timeUnit, _this.baseInterval.count, _this._firstWeekDay, _this._df.utc, void 0, _this._df.timezoneMinutes, _this._df.timezone).getTime();
          var minZoomedStr = minZoomed.toString();
          var startDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(minZoomedStr + series.currentDataSetId);
          var startIndex = 0;
          if (_this.start != 0) {
            if (startDataItem) {
              startDataItem = _this.findFirst(startDataItem, minZoomed, field_1);
              startIndex = startDataItem.index;
            } else {
              startIndex = series.dataItems.findClosestIndex(_this._minZoomed, function(x) {
                return x[field_1];
              }, "left");
            }
          }
          var baseInterval = _this.baseInterval;
          var maxZoomed = add(round2(new Date(_this._maxZoomed), baseInterval.timeUnit, baseInterval.count, _this._firstWeekDay, _this._df.utc, void 0, _this._df.timezoneMinutes, _this._df.timezone), baseInterval.timeUnit, baseInterval.count, _this._df.utc).getTime();
          var maxZoomedStr = maxZoomed.toString();
          var endDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(maxZoomedStr + series.currentDataSetId);
          var endIndex = series.dataItems.length;
          if (_this.end != 1) {
            if (endDataItem) {
              endIndex = endDataItem.index;
            } else {
              maxZoomed -= 1;
              endIndex = series.dataItems.findClosestIndex(maxZoomed, function(x) {
                return x[field_1];
              }, "right");
              endIndex++;
            }
          }
          if (series.max(_this) < minZoomed) {
            series.startIndex = series.dataItems.length;
            series.endIndex = series.dataItems.length;
            series.outOfRange = true;
          } else if (series.min(_this) > maxZoomed) {
            series.startIndex = 0;
            series.endIndex = 0;
            series.outOfRange = true;
          } else {
            series.outOfRange = false;
            series.startIndex = startIndex;
            series.endIndex = endIndex;
          }
          if (!dataSetChanged && series.dataRangeInvalid) {
            series.validateDataRange();
          }
        }
      });
    };
    DateAxis2.prototype.findFirst = function(dataItem, time, key) {
      var index = dataItem.index;
      if (index > 0) {
        var series = dataItem.component;
        var previousDataItem = series.dataItems.getIndex(index - 1);
        var previousDate = previousDataItem[key];
        if (!previousDate || previousDate.getTime() < time) {
          return dataItem;
        } else {
          return this.findFirst(previousDataItem, time, key);
        }
      } else {
        return dataItem;
      }
    };
    DateAxis2.prototype.validateData = function() {
      _super.prototype.validateData.call(this);
      if (!isNumber(this.baseInterval.count)) {
        this.baseInterval.count = 1;
      }
    };
    Object.defineProperty(DateAxis2.prototype, "minDifference", {
      /**
       * @ignore
       */
      get: function() {
        var _this = this;
        var minDifference = Number.MAX_VALUE;
        this.series.each(function(series) {
          if (minDifference > _this._minDifference[series.uid]) {
            minDifference = _this._minDifference[series.uid];
          }
        });
        if (minDifference == Number.MAX_VALUE || minDifference == 0) {
          minDifference = getDuration("day");
        }
        return minDifference;
      },
      enumerable: true,
      configurable: true
    });
    DateAxis2.prototype.seriesDataChangeUpdate = function(series) {
      this._minDifference[series.uid] = Number.MAX_VALUE;
    };
    DateAxis2.prototype.postProcessSeriesDataItems = function(series) {
      var _this = this;
      this._firstWeekDay = this.getFirstWeekDay();
      if (series) {
        this.seriesGroupUpdate(series);
      } else {
        this.series.each(function(series2) {
          _this.seriesGroupUpdate(series2);
        });
      }
      this.addEmptyUnitsBreaks();
    };
    DateAxis2.prototype.seriesGroupUpdate = function(series) {
      var _this = this;
      if (JSON.stringify(series._baseInterval[this.uid]) != JSON.stringify(this.mainBaseInterval)) {
        series._baseInterval[this.uid] = this.mainBaseInterval;
        series.mainDataSet.each(function(dataItem) {
          _this.postProcessSeriesDataItem(dataItem);
        });
        if (this.groupData) {
          this.groupSeriesData(series);
        }
      }
    };
    DateAxis2.prototype.groupSeriesData = function(series) {
      var _this = this;
      if (series.baseAxis == this && series.dataItems.length > 0 && !series.dataGrouped) {
        series.bulletsContainer.removeChildren();
        var intervals_1 = [];
        var mainBaseInterval = this.mainBaseInterval;
        var mainIntervalDuration_1 = getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count);
        this.groupIntervals.each(function(interval) {
          var intervalDuration = getDuration(interval.timeUnit, interval.count);
          if (intervalDuration > mainIntervalDuration_1 && intervalDuration < _this.max - _this.min || _this.groupInterval) {
            intervals_1.push(interval);
          }
        });
        if (series._dataSets) {
          series._dataSets.each(function(key, dataItems) {
            dataItems.each(function(dataItem) {
              dataItem.dispose();
            });
            dataItems.clear();
          });
          series._dataSets.clear();
        }
        series.dataGrouped = true;
        each(intervals_1, function(interval) {
          var key = "date" + _this.axisLetter;
          var dataSetId = interval.timeUnit + interval.count;
          var dataSet = new OrderedListTemplate(series.mainDataSet.template.clone());
          series.dataSets.setKey(dataSetId, dataSet);
          var dataItems = series.mainDataSet;
          var previousTime = Number.NEGATIVE_INFINITY;
          var i = 0;
          var newDataItem;
          var dataFields = [];
          each2(series.dataFields, function(dfkey, df) {
            var dfk = dfkey;
            if (dfk != key && dfk.indexOf("Show") == -1) {
              dataFields.push(dfk);
            }
          });
          var roundedDate;
          dataItems.each(function(dataItem) {
            var date = dataItem.getDate(key);
            if (date) {
              var time = date.getTime();
              roundedDate = round2(new Date(time), interval.timeUnit, interval.count, _this._df.firstDayOfWeek, _this._df.utc, void 0, _this._df.timezoneMinutes, _this._df.timezone);
              var currentTime = roundedDate.getTime();
              if (previousTime < currentTime) {
                if (newDataItem && series._adapterO) {
                  each(dataFields, function(vkey) {
                    newDataItem.values[vkey].value = series._adapterO.apply("groupDataItem", {
                      dataItem: newDataItem,
                      interval,
                      dataField: vkey,
                      date: roundedDate,
                      value: newDataItem.values[vkey].value
                    }).value;
                    newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;
                  });
                }
                newDataItem = dataSet.create();
                newDataItem.dataContext = {};
                newDataItem.setWorkingLocation("dateX", series.dataItems.template.locations.dateX, 0);
                newDataItem.setWorkingLocation("openDateX", series.dataItems.template.locations.openDateX, 0);
                newDataItem.setWorkingLocation("dateY", series.dataItems.template.locations.dateY, 0);
                newDataItem.setWorkingLocation("openDateY", series.dataItems.template.locations.openDateY, 0);
                newDataItem.component = series;
                newDataItem.setDate(key, roundedDate);
                newDataItem._index = i;
                i++;
                each(dataFields, function(vkey) {
                  var dvalues = dataItem.values[vkey];
                  if (dvalues) {
                    var value = dvalues.value;
                    if (series._adapterO) {
                      value = series._adapterO.apply("groupValue", {
                        dataItem,
                        interval,
                        dataField: vkey,
                        date: roundedDate,
                        value
                      }).value;
                    }
                    var values = newDataItem.values[vkey];
                    if (isNumber(value)) {
                      values.value = value;
                      values.workingValue = value;
                      values.open = value;
                      values.close = value;
                      values.low = value;
                      values.high = value;
                      values.sum = value;
                      values.average = value;
                      values.count = 1;
                    } else {
                      values.count = 0;
                    }
                  }
                });
                _this.postProcessSeriesDataItem(newDataItem, interval);
                each2(series.propertyFields, function(key2, fieldValue) {
                  var f = key2;
                  var value = dataItem.properties[key2];
                  if (hasValue(value)) {
                    newDataItem.hasProperties = true;
                    newDataItem.setProperty(f, value);
                  }
                });
                newDataItem.groupDataItems = [dataItem];
                previousTime = currentTime;
              } else {
                if (newDataItem) {
                  each(dataFields, function(vkey) {
                    var groupFieldName = series.groupFields[vkey];
                    var dvalues = dataItem.values[vkey];
                    if (dvalues) {
                      var value = dvalues.value;
                      if (series._adapterO) {
                        value = series._adapterO.apply("groupValue", {
                          dataItem,
                          interval,
                          dataField: vkey,
                          date: roundedDate,
                          value
                        }).value;
                      }
                      if (isNumber(value)) {
                        var values = newDataItem.values[vkey];
                        if (!isNumber(values.open)) {
                          values.open = value;
                        }
                        values.close = value;
                        if (values.low > value || !isNumber(values.low)) {
                          values.low = value;
                        }
                        if (values.high < value || !isNumber(values.high)) {
                          values.high = value;
                        }
                        if (isNumber(values.sum)) {
                          values.sum += value;
                        } else {
                          values.sum = value;
                        }
                        values.count++;
                        values.average = values.sum / values.count;
                        if (isNumber(values[groupFieldName])) {
                          values.value = values[groupFieldName];
                          values.workingValue = values.value;
                        }
                      }
                    }
                  });
                  copyProperties2(dataItem.properties, newDataItem.properties);
                  each2(series.propertyFields, function(key2, fieldValue) {
                    var f = key2;
                    var value = dataItem.properties[key2];
                    if (hasValue(value)) {
                      newDataItem.hasProperties = true;
                      newDataItem.setProperty(f, value);
                    }
                  });
                  newDataItem.groupDataItems.push(dataItem);
                }
              }
            }
            if (newDataItem) {
              copyProperties2(dataItem.dataContext, newDataItem.dataContext);
            }
          });
          if (newDataItem && series._adapterO) {
            each(dataFields, function(vkey) {
              newDataItem.values[vkey].value = series._adapterO.apply("groupDataItem", {
                dataItem: newDataItem,
                interval,
                dataField: vkey,
                date: roundedDate,
                value: newDataItem.values[vkey].value
              }).value;
              newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;
            });
          }
        });
        this.calculateZoom();
      }
    };
    DateAxis2.prototype.getDFFormatter = function() {
      this._df = this.dateFormatter;
    };
    DateAxis2.prototype.postProcessSeriesDataItem = function(dataItem, interval) {
      var _this = this;
      var intervalID = "";
      if (interval) {
        intervalID = interval.timeUnit + interval.count;
      } else {
        interval = this.mainBaseInterval;
      }
      var series = dataItem.component;
      var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);
      each2(dataItem.dates, function(key) {
        var date = dataItem.getDate(key);
        var time = date.getTime();
        var startDate = round2(new Date(time), interval.timeUnit, interval.count, _this._firstWeekDay, _this._df.utc, void 0, _this._df.timezoneMinutes, _this._df.timezone);
        var startTime = startDate.getTime();
        var endDate = add(new Date(startTime), interval.timeUnit, interval.count, _this._df.utc);
        dataItem.setCalculatedValue(key, startTime, "open");
        dataItem.setCalculatedValue(key, endDate.getTime(), "close");
        dataItemsByAxis.setKey(startTime + intervalID, dataItem);
      });
    };
    DateAxis2.prototype.addEmptyUnitsBreaks = function() {
      var _this = this;
      if (this.skipEmptyPeriods && isNumber(this.min) && isNumber(this.max)) {
        var timeUnit = this.baseInterval.timeUnit;
        var count = this.baseInterval.count;
        if (this._axisBreaks) {
          this._axisBreaks.clear();
        }
        var date = round2(new Date(this.min), timeUnit, count, this._firstWeekDay, this._df.utc, void 0, this._df.timezoneMinutes, this._df.timezone);
        var axisBreak = void 0;
        var _loop_1 = function() {
          add(date, timeUnit, count, this_1._df.utc);
          var startTime = date.getTime();
          var startTimeStr = startTime.toString();
          var hasData = contains(this_1.series.iterator(), function(series) {
            return !!series.dataItemsByAxis.getKey(_this.uid).getKey(startTimeStr + series.currentDataSetId);
          });
          if (!hasData) {
            if (!axisBreak) {
              axisBreak = this_1.axisBreaks.create();
              axisBreak.startDate = new Date(startTime);
              this_1._gapBreaks = true;
            }
          } else {
            if (axisBreak) {
              axisBreak.endDate = new Date(startTime - 1);
              axisBreak = void 0;
            }
          }
        };
        var this_1 = this;
        while (date.getTime() < this.max - this.baseDuration) {
          _loop_1();
        }
      }
    };
    DateAxis2.prototype.fixAxisBreaks = function() {
      var _this = this;
      _super.prototype.fixAxisBreaks.call(this);
      var axisBreaks = this._axisBreaks;
      if (axisBreaks) {
        if (axisBreaks.length > 0) {
          axisBreaks.each(function(axisBreak) {
            var breakGridCount = Math.ceil(_this._gridCount * (Math.min(_this.end, axisBreak.endPosition) - Math.max(_this.start, axisBreak.startPosition)) / (_this.end - _this.start));
            axisBreak.gridInterval = _this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);
            var gridDate = round2(new Date(axisBreak.adjustedStartValue), axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._firstWeekDay, _this._df.utc, void 0, _this._df.timezoneMinutes, _this._df.timezone);
            if (gridDate.getTime() > axisBreak.startDate.getTime()) {
              add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._df.utc);
            }
            axisBreak.gridDate = gridDate;
          });
        }
      }
    };
    DateAxis2.prototype.getFirstWeekDay = function() {
      if (this._df) {
        return this._df.firstDayOfWeek;
      }
      return 1;
    };
    DateAxis2.prototype.getGridDate = function(date, intervalCount) {
      var timeUnit = this._gridInterval.timeUnit;
      var realIntervalCount = this._gridInterval.count;
      round2(date, timeUnit, 1, this._firstWeekDay, this._df.utc, void 0, this._df.timezoneMinutes, this._df.timezone);
      var prevTimestamp = date.getTime();
      var newDate = copy(date);
      var timestamp = add(newDate, timeUnit, intervalCount, this._df.utc).getTime();
      var axisBreak = this.isInBreak(timestamp);
      if (axisBreak && axisBreak.endDate) {
        newDate = new Date(axisBreak.endDate.getTime());
        round2(newDate, timeUnit, realIntervalCount, this._firstWeekDay, this._df.utc, void 0, this._df.timezoneMinutes, this._df.timezone);
        if (newDate.getTime() < axisBreak.endDate.getTime()) {
          add(newDate, timeUnit, realIntervalCount, this._df.utc);
        }
        timestamp = newDate.getTime();
      }
      var durationBreaksRemoved = this.adjustDifference(prevTimestamp, timestamp);
      var countBreaksRemoved = Math.round(durationBreaksRemoved / getDuration(timeUnit));
      if (countBreaksRemoved < realIntervalCount) {
        return this.getGridDate(date, intervalCount + realIntervalCount);
      }
      return newDate;
    };
    DateAxis2.prototype.getBreaklessDate = function(axisBreak, timeUnit, count) {
      var date = new Date(axisBreak.endValue);
      round2(date, timeUnit, count, this._firstWeekDay, this._df.utc, void 0, this._df.timezoneMinutes, this._df.timezone);
      add(date, timeUnit, count, this._df.utc);
      var timestamp = date.getTime();
      axisBreak = this.isInBreak(timestamp);
      if (axisBreak) {
        return this.getBreaklessDate(axisBreak, timeUnit, count);
      }
      return date;
    };
    DateAxis2.prototype.validateAxisElements = function() {
      var _this = this;
      if (isNumber(this.max) && isNumber(this.min)) {
        this.calculateZoom();
        var timestamp = this._gridDate.getTime();
        var timeUnit = this._gridInterval.timeUnit;
        var intervalCount = this._gridInterval.count;
        var prevGridDate = copy(this._gridDate);
        var dataItemsIterator_1 = this._dataItemsIterator;
        this.resetIterators();
        var _loop_2 = function() {
          var date = this_2.getGridDate(copy(prevGridDate), intervalCount);
          timestamp = date.getTime();
          var endDate = copy(date);
          endDate = add(endDate, timeUnit, intervalCount, this_2._df.utc);
          var format = this_2.dateFormats.getKey(timeUnit);
          if (this_2.markUnitChange && prevGridDate) {
            if (checkChange(date, prevGridDate, this_2._nextGridUnit, this_2._df.utc)) {
              if (timeUnit !== "year") {
                format = this_2.periodChangeDateFormats.getKey(timeUnit);
              }
            }
          }
          var text = this_2._df.format(date, format);
          var dataItem = dataItemsIterator_1.find(function(x) {
            return x.text === text;
          });
          if (dataItem.__disabled) {
            dataItem.__disabled = false;
          }
          this_2.appendDataItem(dataItem);
          dataItem.axisBreak = void 0;
          dataItem.date = date;
          dataItem.endDate = endDate;
          dataItem.text = text;
          this_2.validateDataElement(dataItem);
          prevGridDate = date;
        };
        var this_2 = this;
        while (timestamp <= this._maxZoomed) {
          _loop_2();
        }
        var renderer_1 = this.renderer;
        if (this._axisBreaks) {
          each3(this._axisBreaks.iterator(), function(axisBreak) {
            if (axisBreak.breakSize > 0) {
              var timeUnit_1 = axisBreak.gridInterval.timeUnit;
              var intervalCount_1 = axisBreak.gridInterval.count;
              if (getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer_1.minGridDistance * 4) {
                var timestamp_1 = axisBreak.gridDate.getTime();
                var prevGridDate_1;
                var count = 0;
                var _loop_3 = function() {
                  var date = copy(axisBreak.gridDate);
                  timestamp_1 = add(date, timeUnit_1, intervalCount_1 * count, _this._df.utc).getTime();
                  count++;
                  if (timestamp_1 > axisBreak.adjustedStartValue && timestamp_1 < axisBreak.adjustedEndValue) {
                    var endDate = copy(date);
                    endDate = add(endDate, timeUnit_1, intervalCount_1, _this._df.utc);
                    var format = _this.dateFormats.getKey(timeUnit_1);
                    if (_this.markUnitChange && prevGridDate_1) {
                      if (checkChange(date, prevGridDate_1, _this._nextGridUnit, _this._df.utc)) {
                        if (timeUnit_1 !== "year") {
                          format = _this.periodChangeDateFormats.getKey(timeUnit_1);
                        }
                      }
                    }
                    var text_1 = _this._df.format(date, format);
                    var dataItem = dataItemsIterator_1.find(function(x) {
                      return x.text === text_1;
                    });
                    if (dataItem.__disabled) {
                      dataItem.__disabled = false;
                    }
                    _this.appendDataItem(dataItem);
                    dataItem.axisBreak = axisBreak;
                    axisBreak.dataItems.moveValue(dataItem);
                    dataItem.date = date;
                    dataItem.endDate = endDate;
                    dataItem.text = text_1;
                    prevGridDate_1 = date;
                    _this.validateDataElement(dataItem);
                  }
                };
                while (timestamp_1 <= axisBreak.adjustedMax) {
                  _loop_3();
                }
              }
            }
          });
        }
      }
    };
    DateAxis2.prototype.validateDataElement = function(dataItem) {
      dataItem.itemIndex = this._axisItemCount;
      this._axisItemCount++;
      if (isNumber(this.max) && isNumber(this.min)) {
        var renderer = this.renderer;
        var timestamp = dataItem.value;
        var endTimestamp = dataItem.endValue;
        if (!isNumber(endTimestamp)) {
          endTimestamp = timestamp;
        }
        var position = this.valueToPosition(timestamp);
        var endPosition = this.valueToPosition(endTimestamp);
        var fillEndPosition = endPosition;
        if (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {
          endPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);
        }
        dataItem.position = position;
        var tick = dataItem.tick;
        if (tick && !tick.disabled) {
          renderer.updateTickElement(tick, position, endPosition);
        }
        var grid = dataItem.grid;
        if (grid && !grid.disabled) {
          renderer.updateGridElement(grid, position, endPosition);
        }
        var fill = dataItem.axisFill;
        if (fill && !fill.disabled) {
          renderer.updateFillElement(fill, position, fillEndPosition);
          if (!dataItem.isRange) {
            this.fillRule(dataItem);
          }
        }
        var mask = dataItem.mask;
        if (mask) {
          renderer.updateFillElement(mask, position, endPosition);
        }
        if (dataItem.bullet) {
          renderer.updateBullet(dataItem.bullet, position, endPosition);
        }
        var label = dataItem.label;
        if (label && !label.disabled) {
          var location_1 = label.location;
          if (location_1 == 0) {
            if (this._gridInterval.count == 1 && this._gridInterval.timeUnit != "week" && !dataItem.isRange) {
              location_1 = 0.5;
            } else {
              location_1 = 0;
            }
          }
          renderer.updateLabelElement(label, position, endPosition, location_1);
        }
      }
    };
    Object.defineProperty(DateAxis2.prototype, "baseDuration", {
      /**
       * A duration in milliseconds of the `baseInterval`.
       *
       * @return Duration (ms)
       */
      get: function() {
        return getDuration(this.baseInterval.timeUnit, this.baseInterval.count);
      },
      enumerable: true,
      configurable: true
    });
    DateAxis2.prototype.adjustMinMax = function(min2, max2) {
      return { min: min2, max: max2, step: this.baseDuration };
    };
    DateAxis2.prototype.fixMin = function(value) {
      var interval = this.baseInterval;
      var startTime = round2(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, void 0, this._df.timezoneMinutes, this._df.timezone).getTime();
      var endTime = add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();
      return startTime + (endTime - startTime) * this.startLocation;
    };
    DateAxis2.prototype.fixMax = function(value) {
      var interval = this.baseInterval;
      var startTime = round2(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, void 0, this._df.timezoneMinutes, this._df.timezone).getTime();
      var endTime = add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();
      return startTime + (endTime - startTime) * this.endLocation;
    };
    DateAxis2.prototype.chooseInterval = function(index, duration, gridCount, intervals) {
      if (!intervals) {
        intervals = this.gridIntervals;
      }
      var gridInterval = intervals.getIndex(index);
      var intervalDuration = getDuration(gridInterval.timeUnit, gridInterval.count);
      var lastIndex = intervals.length - 1;
      if (index >= lastIndex) {
        return __assign({}, intervals.getIndex(lastIndex));
      }
      var count = Math.ceil(duration / intervalDuration);
      if (duration < intervalDuration && index > 0) {
        return __assign({}, intervals.getIndex(index - 1));
      }
      if (count <= gridCount) {
        return __assign({}, intervals.getIndex(index));
      } else {
        if (index + 1 < intervals.length) {
          return this.chooseInterval(index + 1, duration, gridCount, intervals);
        } else {
          return __assign({}, intervals.getIndex(index));
        }
      }
    };
    DateAxis2.prototype.formatLabel = function(value) {
      return this._df.format(value);
    };
    DateAxis2.prototype.dateToPosition = function(date) {
      return this.valueToPosition(date.getTime());
    };
    DateAxis2.prototype.anyToPosition = function(date) {
      if (date instanceof Date) {
        return this.dateToPosition(date);
      } else {
        return this.valueToPosition(date);
      }
    };
    DateAxis2.prototype.dateToPoint = function(date) {
      var position = this.dateToPosition(date);
      var point = this.renderer.positionToPoint(position);
      var angle = this.renderer.positionToAngle(position);
      return { x: point.x, y: point.y, angle };
    };
    DateAxis2.prototype.anyToPoint = function(date) {
      if (date instanceof Date) {
        return this.dateToPoint(date);
      } else {
        return this.valueToPoint(date);
      }
    };
    DateAxis2.prototype.positionToDate = function(position) {
      return new Date(this.positionToValue(position));
    };
    DateAxis2.prototype.getPositionX = function(dataItem, key, location, stackKey, range) {
      var value = this.getTimeByLocation(dataItem, key, location);
      if (!isNumber(value)) {
        value = this.baseValue;
      }
      var position = this.valueToPosition(value);
      if (range) {
        position = fitToRange(position, range.start, range.end);
      }
      return position;
    };
    DateAxis2.prototype.getPositionY = function(dataItem, key, location, stackKey, range) {
      var value = this.getTimeByLocation(dataItem, key, location);
      var stack = dataItem.getValue("valueX", "stack");
      if (!isNumber(value)) {
        value = this.baseValue;
      }
      var position = this.valueToPosition(value + stack);
      if (range) {
        position = fitToRange(position, range.start, range.end);
      }
      return position;
    };
    DateAxis2.prototype.getAngle = function(dataItem, key, location, stackKey, range) {
      var value = this.getTimeByLocation(dataItem, key, location);
      var stack = dataItem.getValue(stackKey, "stack");
      if (!isNumber(value)) {
        value = this.baseValue;
      }
      var position = this.valueToPosition(value + stack);
      if (range) {
        position = fitToRange(position, range.start, range.end);
      }
      return this.positionToAngle(position);
    };
    DateAxis2.prototype.getTimeByLocation = function(dataItem, key, location) {
      if (!hasValue(key)) {
        return;
      }
      if (!isNumber(location)) {
        location = dataItem.workingLocations[key];
        if (!isNumber(location)) {
          location = 0;
        }
      }
      var startTime = dataItem.values[key]["open"];
      var endTime = dataItem.values[key]["close"];
      var workingValue = dataItem.values[key].workingValue;
      var value = dataItem.values[key].value;
      var difference = value - workingValue;
      startTime -= difference;
      endTime -= difference;
      if (isNumber(startTime) && isNumber(endTime)) {
        return startTime + (endTime - startTime) * location;
      }
    };
    DateAxis2.prototype.processSeriesDataItem = function(dataItem, axisLetter) {
      var series = dataItem.component;
      var time;
      var date = dataItem["date" + axisLetter];
      if (isNumber(this.timezoneOffset)) {
        date.setTime(date.getTime() + (date.getTimezoneOffset() - this.timezoneOffset) * 6e4);
        dataItem.setValue("date" + axisLetter, date.getTime(), 0);
      } else if (hasValue(this.timezone)) {
        date = setTimezone(date, this.timezone);
        dataItem.setValue("date" + axisLetter, date.getTime(), 0);
        dataItem["date" + axisLetter] = date;
      }
      if (date) {
        time = date.getTime();
      } else {
        return;
      }
      var openDate = dataItem["openDate" + axisLetter];
      var prevSeriesTime = this._prevSeriesTime[series.uid];
      var openTime;
      if (openDate) {
        openTime = openDate.getTime();
      }
      if (isNumber(openTime)) {
        var difference = Math.abs(time - openTime);
        if (this._minDifference[series.uid] > difference) {
          this._minDifference[series.uid] = difference;
        }
      }
      var differece = time - prevSeriesTime;
      if (differece > 0) {
        if (this._minDifference[series.uid] > differece) {
          this._minDifference[series.uid] = differece;
        }
      }
      this._prevSeriesTime[series.uid] = time;
      if (series._baseInterval[this.uid]) {
        this.postProcessSeriesDataItem(dataItem);
      }
    };
    DateAxis2.prototype.updateAxisBySeries = function() {
      _super.prototype.updateAxisBySeries.call(this);
      var baseInterval = this.chooseInterval(0, this.minDifference, 1);
      if (this.minDifference >= getDuration("day", 27) && baseInterval.timeUnit == "week") {
        baseInterval.timeUnit = "month";
        baseInterval.count = 1;
      }
      if (baseInterval.timeUnit == "month") {
        if (this.minDifference >= getDuration("day", 29 * 2) && baseInterval.count == 1) {
          baseInterval.count = 2;
        }
        if (this.minDifference >= getDuration("day", 29 * 3) && baseInterval.count == 2) {
          baseInterval.count = 3;
        }
        if (this.minDifference >= getDuration("day", 29 * 6) && baseInterval.count == 5) {
          baseInterval.count = 6;
        }
      }
      if (this.minDifference >= getDuration("hour", 23) && baseInterval.timeUnit == "hour") {
        baseInterval.timeUnit = "day";
        baseInterval.count = 1;
      }
      if (this.minDifference >= getDuration("week", 1) - getDuration("hour", 1) && baseInterval.timeUnit == "day") {
        baseInterval.timeUnit = "week";
        baseInterval.count = 1;
      }
      if (this.minDifference >= getDuration("year", 1) - getDuration("day", 1.01) && baseInterval.timeUnit == "month") {
        baseInterval.timeUnit = "year";
        baseInterval.count = 1;
      }
      this._baseIntervalReal = baseInterval;
      this._mainBaseInterval = baseInterval;
    };
    Object.defineProperty(DateAxis2.prototype, "baseInterval", {
      /**
       * @return Base interval
       */
      get: function() {
        if (this._groupInterval) {
          return this._groupInterval;
        } else if (this._baseInterval) {
          return this._baseInterval;
        } else {
          return this._baseIntervalReal;
        }
      },
      /**
       * A base interval (granularity) of data.
       *
       * Used to indicate what are the base units of your data.
       *
       * For example, if you have a data set that has a data point every 5 minutes,
       * you may want to set this to `{ timeUnit: "minute", count: 5 }`.
       *
       * If not set, the Axis will try to determine the setting by its own, looking
       * at actual data.
       *
       * For best results, try to follow these values for `count`:
       *
       * When unit is "month", use 12 / count = round number
       * When unit is "hour", use 24 / count = round number
       * When unit is "second" and "minute", use 60 / count = round number
       *
       * @param timeInterval base interval
       */
      set: function(timeInterval) {
        if (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {
          this._baseInterval = timeInterval;
          this._mainBaseInterval = timeInterval;
          if (!isNumber(timeInterval.count)) {
            timeInterval.count = 1;
          }
          this.invalidate();
          this.postProcessSeriesDataItems();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateAxis2.prototype, "mainBaseInterval", {
      /**
       * Indicates granularity of the data of source (unaggregated) data.
       *
       * @since 4.7.0
       * @return Granularity of the main data set
       */
      get: function() {
        if (this._baseInterval) {
          return this._baseInterval;
        } else if (this._mainBaseInterval) {
          return this._mainBaseInterval;
        } else {
          return this._baseIntervalReal;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateAxis2.prototype, "skipEmptyPeriods", {
      /**
       * @return Remove empty stretches of time?
       */
      get: function() {
        return this.getPropertyValue("skipEmptyPeriods");
      },
      /**
       * If enabled, axis will automatically collapse empty (without data points)
       * periods of time, i.e. weekends.
       *
       * An "empty" period is considered a stretch of time in the length of current
       * `baseInterval` without a single data point in it.
       *
       * For each such empty period, axis will automatically create an
       * [[AxisBreak]]. By default they will be invisible. You can still configure
       * them by accessing `axis.breaks.template`.
       *
       * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).
       *
       * Important notes:
       * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.
       * * Using this feature affects performance. Use only if you need it.
       * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.
       * * Some axis label overlapping might happen.
       * * This setting is not compatible with `groupData = true`.
       *
       * @default false
       * @param value  Remove empty stretches of time?
       */
      set: function(value) {
        if (value) {
          var breakTemplate = this.axisBreaks.template;
          breakTemplate.startLine.disabled = true;
          breakTemplate.endLine.disabled = true;
          breakTemplate.fillShape.disabled = true;
          breakTemplate.breakSize = 0;
        } else {
          if (this._gapBreaks) {
            this.axisBreaks.clear();
            this._gapBreaks = false;
          }
        }
        if (this.setPropertyValue("skipEmptyPeriods", value)) {
          this.invalidate();
          this.postProcessSeriesDataItems();
          this.invalidateSeries();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateAxis2.prototype, "tooltipDateFormat", {
      /**
       * @return Date format
       */
      get: function() {
        return this.getPropertyValue("tooltipDateFormat");
      },
      /**
       * A special date format to apply axis tooltips.
       *
       * Will use same format as for labels, if not set.
       *
       * @param value  Date format
       */
      set: function(value) {
        this.setPropertyValue("tooltipDateFormat", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateAxis2.prototype, "markUnitChange", {
      /**
       * @return Use different format for period beginning?
       */
      get: function() {
        return this.getPropertyValue("markUnitChange");
      },
      /**
       * Use `periodChangeDateFormats` to apply different formats to the first
       * label in bigger time unit.
       *
       * @default true
       * @param value  Use different format for period beginning?
       */
      set: function(value) {
        if (this.setPropertyValue("markUnitChange", value)) {
          this.invalidateData();
        }
      },
      enumerable: true,
      configurable: true
    });
    DateAxis2.prototype.getTooltipText = function(position) {
      var text;
      var date = this.positionToDate(position);
      date = round2(date, this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);
      this.tooltipDate = date;
      if (hasValue(this.tooltipDateFormat)) {
        text = this._df.format(date, this.tooltipDateFormat, ["day", "month", "week", "year"].indexOf(this.baseInterval.timeUnit) == -1);
      } else {
        var dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);
        if (dateFormat) {
          text = this._df.format(date, dateFormat);
        } else {
          text = this.getPositionLabel(position);
        }
      }
      if (!this._adapterO) {
        return text;
      } else {
        return this._adapterO.apply("getTooltipText", text);
      }
    };
    DateAxis2.prototype.roundPosition = function(position, location, axisLocation) {
      var baseInterval = this.baseInterval;
      var timeUnit = baseInterval.timeUnit;
      var count = baseInterval.count;
      var date = this.positionToDate(position);
      round2(date, timeUnit, count, this._firstWeekDay, this._df.utc, void 0, this._df.timezoneMinutes, this._df.timezone);
      if (location > 0) {
        add(date, timeUnit, location * count, this._df.utc);
      }
      if (axisLocation > 0 && axisLocation < 1) {
        date.setTime(date.getTime() + this.baseDuration * axisLocation);
      }
      if (this.isInBreak(date.getTime())) {
        while (date.getTime() < this.max) {
          add(date, timeUnit, count, this._df.utc);
          if (!this.isInBreak(date.getTime())) {
            break;
          }
        }
      }
      return this.dateToPosition(date);
    };
    DateAxis2.prototype.getCellStartPosition = function(position) {
      return this.roundPosition(position, 0);
    };
    DateAxis2.prototype.getCellEndPosition = function(position) {
      return this.roundPosition(position, 1);
    };
    DateAxis2.prototype.getSeriesDataItem = function(series, position, findNearest) {
      var value = this.positionToValue(position);
      var location = 0.5;
      if (this.axisLetter == "Y") {
        location = series.dataItems.template.locations.dateY;
      } else {
        location = series.dataItems.template.locations.dateX;
      }
      var deltaValue = value - location * this.baseDuration;
      var date = round2(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, void 0, this._df.timezoneMinutes, this._df.timezone);
      var nextDate = round2(new Date(value + this.baseDuration), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, void 0, this._df.timezoneMinutes, this._df.timezone);
      if (nextDate.getTime() > date.getTime()) {
        if (Math.abs(nextDate.getTime() - deltaValue) < Math.abs(deltaValue - date.getTime())) {
          date = nextDate;
        }
      }
      var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);
      var dataItem = dataItemsByAxis.getKey(date.getTime() + series.currentDataSetId);
      if (!dataItem && findNearest) {
        var key_1;
        if (this.axisLetter == "Y") {
          key_1 = "dateY";
        } else {
          key_1 = "dateX";
        }
        dataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), function(x) {
          if (x[key_1]) {
            return x[key_1].getTime();
          } else {
            return -Infinity;
          }
        }, "any"));
      }
      return dataItem;
    };
    DateAxis2.prototype.getPositionLabel = function(position) {
      var date = this.positionToDate(position);
      return this._df.format(date, this.getCurrentLabelFormat());
    };
    DateAxis2.prototype.getCurrentLabelFormat = function() {
      return this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : "day");
    };
    DateAxis2.prototype.initRenderer = function() {
      _super.prototype.initRenderer.call(this);
      var renderer = this.renderer;
      if (renderer) {
        renderer.ticks.template.location = 0;
        renderer.grid.template.location = 0;
        renderer.labels.template.location = 0;
        renderer.baseGrid.disabled = true;
      }
    };
    Object.defineProperty(DateAxis2.prototype, "basePoint", {
      /**
       * Coordinates of the actual axis start.
       *
       * @ignore Exclude from docs
       * @return Base point
       */
      get: function() {
        return { x: 0, y: 0 };
      },
      enumerable: true,
      configurable: true
    });
    DateAxis2.prototype.animateMinMax = function(min2, max2) {
      var _this = this;
      var animation = this.animate([{ property: "_minAdjusted", from: this._minAdjusted, to: min2 }, { property: "_maxAdjusted", from: this._maxAdjusted, to: max2 }], this.rangeChangeDuration, this.rangeChangeEasing);
      animation.events.on("animationprogress", function() {
        _this.dispatch("extremeschanged");
      });
      return animation;
    };
    DateAxis2.prototype.handleExtremesChange = function() {
      _super.prototype.handleExtremesChange.call(this);
      if (this.groupData) {
        var id = this.baseInterval.timeUnit + this.baseInterval.count;
        this.groupMin[id] = this._finalMin;
        this.groupMax[id] = this._finalMax;
      }
    };
    DateAxis2.prototype.zoomToDates = function(startDate, endDate, skipRangeEvent, instantly, adjust) {
      startDate = this._df.parse(startDate);
      endDate = this._df.parse(endDate);
      this.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly, adjust);
    };
    DateAxis2.prototype.zoomToValues = function(startValue, endValue, skipRangeEvent, instantly, adjust) {
      var _this = this;
      if (!this.groupData) {
        var start = this.valueToPosition(startValue);
        var end = this.valueToPosition(endValue);
        this.zoom({ start, end }, skipRangeEvent, instantly);
      } else {
        var difference = this.adjustDifference(startValue, endValue);
        var isEnd = false;
        if (endValue == this.max) {
          isEnd = true;
        }
        var isStart = false;
        if (startValue == this.min) {
          isStart = true;
        }
        if (hasValue(difference)) {
          var mainBaseInterval = this.mainBaseInterval;
          var groupInterval_1 = this.chooseInterval(0, difference, this.groupCount, this.groupIntervals);
          if (groupInterval_1.timeUnit == mainBaseInterval.timeUnit && groupInterval_1.count < mainBaseInterval.count || getDuration(groupInterval_1.timeUnit, 1) < getDuration(mainBaseInterval.timeUnit, 1)) {
            groupInterval_1 = __assign({}, mainBaseInterval);
          }
          var id = groupInterval_1.timeUnit + groupInterval_1.count;
          var min_1 = this.groupMin[id];
          var max_1 = this.groupMax[id];
          if (!isNumber(min_1) || !isNumber(max_1)) {
            min_1 = Number.POSITIVE_INFINITY;
            max_1 = Number.NEGATIVE_INFINITY;
            this.series.each(function(series) {
              var seriesMin = series.min(_this);
              var seriesMax = series.max(_this);
              if (series._dataSets) {
                var ds = series._dataSets.getKey(groupInterval_1.timeUnit + groupInterval_1.count);
                if (ds) {
                  var mindi = ds.getIndex(0);
                  var maxdi = ds.getIndex(ds.length - 1);
                  if (mindi) {
                    if (series.xAxis == _this) {
                      seriesMin = mindi.dateX.getTime();
                    } else if (series.yAxis == _this) {
                      seriesMin = mindi.dateY.getTime();
                    }
                  }
                  if (maxdi) {
                    if (series.xAxis == _this) {
                      seriesMax = maxdi.dateX.getTime();
                    } else if (series.yAxis == _this) {
                      seriesMax = maxdi.dateY.getTime();
                    }
                  }
                }
              }
              seriesMax = round2(add(new Date(seriesMax), groupInterval_1.timeUnit, 1, _this._df.utc), groupInterval_1.timeUnit, 1, _this._df.firstDayOfWeek, _this._df.utc, void 0, _this._df.timezoneMinutes, _this._df.timezone).getTime();
              if (seriesMin < min_1) {
                min_1 = seriesMin;
              }
              if (seriesMax > max_1) {
                max_1 = seriesMax;
              }
            });
            this.groupMin[id] = min_1;
            this.groupMax[id] = max_1;
          }
          startValue = fitToRange(startValue, min_1, max_1);
          endValue = fitToRange(endValue, min_1, max_1);
          if (adjust) {
            if (isEnd) {
              startValue = endValue - difference;
              startValue = fitToRange(startValue, min_1, max_1);
            }
            if (isStart) {
              endValue = startValue + difference;
              endValue = fitToRange(endValue, min_1, max_1);
            }
          }
          var start = (startValue - min_1) / (max_1 - min_1);
          var end = (endValue - min_1) / (max_1 - min_1);
          this.zoom({ start, end }, skipRangeEvent, instantly);
        }
      }
    };
    DateAxis2.prototype.asIs = function(field) {
      return field == "baseInterval" || _super.prototype.asIs.call(this, field);
    };
    DateAxis2.prototype.copyFrom = function(source) {
      var _this = this;
      _super.prototype.copyFrom.call(this, source);
      this.dateFormats = source.dateFormats;
      this.periodChangeDateFormats = source.periodChangeDateFormats;
      this.groupIntervals.clear();
      source.groupIntervals.each(function(interval) {
        _this.groupIntervals.push(__assign({}, interval));
      });
      this.gridIntervals.clear();
      source.gridIntervals.each(function(interval) {
        _this.gridIntervals.push(__assign({}, interval));
      });
      if (source._baseInterval) {
        this.baseInterval = source._baseInterval;
      }
    };
    DateAxis2.prototype.showTooltipAtPosition = function(position, local) {
      var _this = this;
      if (!local) {
        position = this.toAxisPosition(position);
      }
      if (this.snapTooltip) {
        var actualDate = this.positionToDate(position);
        var actualTime_1 = actualDate.getTime();
        var closestDate_1;
        this.series.each(function(series) {
          if (series.baseAxis == _this) {
            var dataItem = _this.getSeriesDataItem(series, position, true);
            if (dataItem) {
              var date = void 0;
              if (series.xAxis == _this) {
                date = dataItem.dateX;
              }
              if (series.yAxis == _this) {
                date = dataItem.dateY;
              }
              if (!closestDate_1) {
                closestDate_1 = date;
              } else {
                if (Math.abs(closestDate_1.getTime() - actualTime_1) > Math.abs(date.getTime() - actualTime_1)) {
                  closestDate_1 = date;
                }
              }
            }
          }
        });
        if (closestDate_1) {
          var closestTime_1 = closestDate_1.getTime();
          closestDate_1 = round2(new Date(closestTime_1), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, void 0, this._df.timezoneMinutes, this._df.timezone);
          closestTime_1 = closestDate_1.getTime();
          var tooltipLocation = this.renderer.tooltipLocation;
          if (tooltipLocation == 0) {
            tooltipLocation = 1e-4;
          }
          closestDate_1 = new Date(closestDate_1.getTime() + this.baseDuration * tooltipLocation);
          position = this.dateToPosition(closestDate_1);
          if (this.chart.cursor && this.chart.cursor.snapToSeries) {
          } else {
            this.series.each(function(series) {
              var dataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(closestTime_1 + series.currentDataSetId);
              var point = series.showTooltipAtDataItem(dataItem);
              if (point) {
                _this.chart._seriesPoints.push({ series, point });
              } else {
                if (series.tooltipText || series.tooltipHTML) {
                  series.hideTooltip();
                }
              }
            });
          }
        }
      }
      _super.prototype.showTooltipAtPosition.call(this, position, true);
    };
    Object.defineProperty(DateAxis2.prototype, "snapTooltip", {
      /**
       * @return Should snap?
       */
      get: function() {
        return this.getPropertyValue("snapTooltip");
      },
      /**
       * Should the nearest tooltip be shown if no data item is found on the
       * current cursor position.
       *
       * @default true
       * @param value  Should snap?
       */
      set: function(value) {
        this.setPropertyValue("snapTooltip", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateAxis2.prototype, "groupData", {
      /**
       * @return Group data points?
       */
      get: function() {
        return this.getPropertyValue("groupData");
      },
      /**
       * Indicates if data should be aggregated to composide data items if there
       * are more data items in selected range than `groupCount`.
       *
       * Grouping will occur automatically, based on current selection range, and
       * will change dynamically when user zooms in/out the chart.
       *
       * NOTE: This works only if [[DateAxis]] is base axis of an [[XYSeries]].
       *
       * The related [[XYSeries]] also needs to be set up to take advantage of, by
       * setting its [`groupFields`](https://www.amcharts.com/docs/v4/reference/xyseries/#groupFields_property).
       *
       * The group intervals to aggregate data to is defined by `groupIntervals`
       * property.
       *
       * ```TypeScript
       * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());
       * dateAxis.groupData = true;
       *
       * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());
       *
       * let series = chart.series.push(new am4charts.LineSeries());
       * series.dataFields.dateX = "date";
       * series.dataFields.valueY = "value";
       * series.groupFields.valueY = "average";
       * ```
       * ```JavaScript
       * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());
       * dateAxis.groupData = true;
       *
       * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());
       *
       * var series = chart.series.push(new am4charts.LineSeries());
       * series.dataFields.dateX = "date";
       * series.dataFields.valueY = "value";
       * series.groupFields.valueY = "average";
       * ```
       * ```JSON
       * {
       *   // ...
       *   "xAxes": [{
       *     "type": "DateAxis",
       *     "groupData": true
       *   }],
       *   "yAxes": [{
       *     "type": "ValueAxis"
       *   }],
       *   "series": [{
       *     "type": "LineSeries",
       *     "dataFields": {
       *       "dateX": "date",
       *       "valueY": "value"
       *     },
       *     "groupFields": {
       *       "valueY": "average"
       *     }
       *   }]
       * }
       * ```
       *
       * @default false
       * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.
       * @since 4.7.0
       * @param  value  Group data points?
       */
      set: function(value) {
        var _this = this;
        if (this.setPropertyValue("groupData", value)) {
          this.series.each(function(series) {
            series.setDataSet("");
            if (value && !series.dataGrouped && series.inited) {
              series._baseInterval[_this.uid] = _this.mainBaseInterval;
              _this.groupSeriesData(series);
            }
          });
          this._currentDataSetId = "";
          this._groupInterval = void 0;
          this.invalidate();
          this.invalidateSeries();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateAxis2.prototype, "groupInterval", {
      /**
       * @return Interval
       */
      get: function() {
        return this.getPropertyValue("groupInterval");
      },
      /**
       * Disables automatic selection of data grouping intervals and always uses
       * `groupInterval` if set. Works only if `groupData = true`.
       *
       * @since 4.9.24
       * @param  value  Interval
       */
      set: function(value) {
        if (this.setPropertyValue("groupInterval", value)) {
          this.invalidate();
          this.invalidateSeries();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateAxis2.prototype, "groupCount", {
      /**
       * @return Number of data items
       */
      get: function() {
        return this.getPropertyValue("groupCount");
      },
      /**
       * Indicates threshold of data items in selected range at which to start
       * aggregating data items if `groupData = true`.
       *
       * @default 200
       * @since 4.7.0
       * @param  value  Number of data items
       */
      set: function(value) {
        this.setPropertyValue("groupCount", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateAxis2.prototype, "timezoneOffset", {
      /**
       * @todo Timezone offset in minutes
       */
      get: function() {
        return this.getPropertyValue("timezoneOffset");
      },
      /**
       * If set will recalculate all timestamps in data by applying specific offset
       * in minutes.
       *
       * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It
       * will skew your results by applying offset twice.
       *
       * @since 4.8.5
       * @param  value Time zone offset in minutes
       */
      set: function(value) {
        this.setPropertyValue("timezoneOffset", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateAxis2.prototype, "timezone", {
      /**
       * @return Timezone
       */
      get: function() {
        return this.getPropertyValue("timezone");
      },
      /**
       * If set will recalculate all timestamps in data to specific named timezone,
       * e.g. `"America/Vancouver"`, `"Australia/Sydney"`, `"UTC"`, etc.
       *
       * IMPORTANT: it is no longer recommended to use this setting. Please
       * set`timezone` on `dateFormatter`.
       *
       * @deprecated
       * @since 4.10.1
       * @param  value Time zone
       */
      set: function(value) {
        this.setPropertyValue("timezone", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateAxis2.prototype, "gridInterval", {
      /**
       * Current grid interval.
       *
       * @return Grid interval
       */
      get: function() {
        return this._gridInterval;
      },
      enumerable: true,
      configurable: true
    });
    DateAxis2.prototype.makeGap = function(dataItem, previous) {
      var series = dataItem.component;
      if (dataItem && previous) {
        if (!series.connect && isNumber(series.autoGapCount)) {
          if (series.baseAxis == this) {
            var date = dataItem.dates["date" + this.axisLetter];
            var prevDate = previous.dates["date" + this.axisLetter];
            if (date && prevDate) {
              var time = date.getTime();
              var prevTime = prevDate.getTime();
              if (time - prevTime > series.autoGapCount * this.baseDuration) {
                return true;
              }
            }
          }
        }
      }
      return false;
    };
    Object.defineProperty(DateAxis2.prototype, "baseValue", {
      /**
       * @return base value
       */
      get: function() {
        return this.min;
      },
      enumerable: true,
      configurable: true
    });
    DateAxis2.prototype._saveMinMax = function(min2, max2) {
      var groupInterval = this.groupInterval;
      if (!groupInterval) {
        groupInterval = this.mainBaseInterval;
      }
      var id = groupInterval.timeUnit + groupInterval.count;
      this._intervalMin[id] = min2;
      this._intervalMax[id] = max2;
    };
    return DateAxis2;
  }(ValueAxis)
);
registry.registeredClasses["DateAxis"] = DateAxis;
registry.registeredClasses["DateAxisDataItem"] = DateAxisDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererX.js
var AxisRendererX = (
  /** @class */
  function(_super) {
    __extends(AxisRendererX2, _super);
    function AxisRendererX2() {
      var _this = _super.call(this) || this;
      _this.className = "AxisRendererX";
      _this.minGridDistance = 120;
      _this.opposite = false;
      _this.rotation = 0;
      _this.width = percent(100);
      _this.labels.template.horizontalCenter = "middle";
      _this.applyTheme();
      return _this;
    }
    AxisRendererX2.prototype.setAxis = function(axis) {
      _super.prototype.setAxis.call(this, axis);
      axis.layout = "vertical";
    };
    AxisRendererX2.prototype.updateGridContainer = function() {
      var axis = this.axis;
      if (axis) {
        var gridContainer = this.gridContainer;
        gridContainer.x = axis.pixelX;
        gridContainer.width = axis.axisLength;
      }
    };
    AxisRendererX2.prototype.processRenderer = function() {
      _super.prototype.processRenderer.call(this);
      var axis = this.axis;
      if (axis) {
        if (!(axis.width instanceof Percent)) {
          axis.width = percent(100);
        }
        used(this.line);
        var title = axis.title;
        title.rotation = 0;
        title.align = "center";
        if (this.opposite) {
          this.line.toFront();
          title.toBack();
        } else {
          title.toFront();
          this.toBack();
          this.line.toBack();
        }
      }
    };
    AxisRendererX2.prototype.updateTooltip = function() {
      var axis = this.axis;
      if (axis) {
        var bigNum = 1e3;
        var bbx = this.line.pixelX;
        var bby = this.line.pixelY;
        var bbw = this.axisLength;
        var bbh = bigNum;
        if (this.opposite) {
          if (!this.inside) {
            bby = -bigNum;
            bbh = bigNum;
          }
        } else {
          if (this.inside) {
            bby = -bigNum;
            bbh = bigNum;
          }
        }
        this.axis.updateTooltip("vertical", { x: bbx, y: bby, width: bbw, height: bbh });
      }
    };
    AxisRendererX2.prototype.updateLabelElement = function(label, position, endPosition, location) {
      if (!hasValue(location)) {
        location = label.location;
      }
      position = position + (endPosition - position) * location;
      var point = this.positionToPoint(position);
      label.isMeasured = !label.inside;
      var deltaY = 0;
      var verticalCenter;
      var maxHeight = this.gridContainer.maxHeight;
      if (this.opposite) {
        if (label.inside) {
          verticalCenter = "top";
          if (label.valign == "bottom") {
            deltaY = maxHeight;
            verticalCenter = "bottom";
          }
          if (label.valign == "middle") {
            deltaY = maxHeight / 2;
            verticalCenter = "middle";
          }
        } else {
          verticalCenter = "bottom";
        }
        point.y = deltaY;
      } else {
        if (label.inside) {
          verticalCenter = "bottom";
          if (label.valign == "top") {
            deltaY = -maxHeight;
            verticalCenter = "top";
          }
          if (label.valign == "middle") {
            deltaY = -maxHeight / 2;
            verticalCenter = "middle";
          }
        } else {
          verticalCenter = "top";
        }
        point.y += deltaY;
      }
      if (label.rotation == 0) {
        label.verticalCenter = verticalCenter;
      }
      this.positionItem(label, point);
      this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);
    };
    Object.defineProperty(AxisRendererX2.prototype, "axisLength", {
      /**
       * Returns actual length of the Axis, in pixels.
       *
       * @return Length (px)
       */
      get: function() {
        var axis = this.axis;
        return axis.measuredWidth - axis.pixelPaddingRight - axis.pixelPaddingLeft || 0;
      },
      enumerable: true,
      configurable: true
    });
    AxisRendererX2.prototype.positionToPoint = function(position, position2) {
      return { x: this.positionToCoordinate(position), y: 0 };
    };
    AxisRendererX2.prototype.pointToPosition = function(point) {
      return this.coordinateToPosition(point.x, point.y);
    };
    AxisRendererX2.prototype.getPositionRangePath = function(startPosition, endPosition) {
      var x1 = fitToRange(this.positionToCoordinate(startPosition), 0, this.axisLength);
      var x2 = fitToRange(this.positionToCoordinate(endPosition), 0, this.axisLength);
      var w = Math.abs(x2 - x1);
      var h = this.getHeight();
      var x = Math.min(x1, x2);
      var y = 0;
      return rectToPath({
        x,
        y,
        width: w,
        height: h
      }, true);
    };
    AxisRendererX2.prototype.updateBreakElement = function(axisBreak) {
      _super.prototype.updateBreakElement.call(this, axisBreak);
      var startLine = axisBreak.startLine;
      var endLine = axisBreak.endLine;
      var fillShape = axisBreak.fillShape;
      var startPoint = axisBreak.startPoint;
      var endPoint = axisBreak.endPoint;
      var y1 = axisBreak.pixelMarginLeft;
      var y2 = this.getHeight() - axisBreak.pixelMarginTop - axisBreak.pixelMarginBottom;
      startPoint.x = fitToRange(startPoint.x, -1, this.axisLength + 1);
      endPoint.x = fitToRange(endPoint.x, -1, this.axisLength + 1);
      if (startPoint.x == endPoint.x && (startPoint.x < 0 || startPoint.x > this.axisLength)) {
        axisBreak.fillShape.__disabled = true;
      } else {
        axisBreak.fillShape.__disabled = false;
      }
      startLine.y = y1;
      startLine.width = 0;
      startLine.height = y2;
      endLine.y = y1;
      endLine.width = 0;
      endLine.height = y2;
      fillShape.height = y2;
      fillShape.width = Math.abs(endPoint.x - startPoint.x);
      fillShape.y = y1;
      fillShape.x = startPoint.x;
    };
    AxisRendererX2.prototype.updateGridElement = function(grid, position, endPosition) {
      position = position + (endPosition - position) * grid.location;
      var point = this.positionToPoint(position);
      grid.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: 0, y: this.getHeight() });
      this.positionItem(grid, point);
      this.toggleVisibility(grid, position, 0, 1);
    };
    AxisRendererX2.prototype.updateTickElement = function(tick, position, endPosition) {
      position = position + (endPosition - position) * tick.location;
      var point = this.positionToPoint(position);
      var tickLength = tick.length;
      point.y = spritePointToSprite({ x: 0, y: this.line.pixelY }, this.line.parent, this.gridContainer).y;
      if (this.opposite) {
        tickLength *= tick.inside ? 1 : -1;
      } else {
        tickLength *= tick.inside ? -1 : 1;
      }
      tick.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: 0, y: tickLength });
      this.positionItem(tick, point);
      this.toggleVisibility(tick, position, 0, 1);
    };
    AxisRendererX2.prototype.updateAxisLine = function() {
      this.line.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: this.axisLength, y: 0 });
    };
    AxisRendererX2.prototype.updateBaseGridElement = function() {
      _super.prototype.updateBaseGridElement.call(this);
      var axis = this.axis;
      var h = this.getHeight();
      var w = this.axisLength;
      var baseGrid = this.baseGrid;
      var x = axis.basePoint.x;
      if (x < -0.2 || x > w + 0.2) {
        baseGrid.hide(0);
      } else {
        var y = spritePointToSprite({ x: 0, y: 0 }, this.gridContainer, baseGrid.parent).y;
        baseGrid.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: 0, y: h });
        baseGrid.moveTo({ x, y });
        baseGrid.show(0);
      }
    };
    AxisRendererX2.prototype.createBreakSprites = function(axisBreak) {
      axisBreak.startLine = new WavedLine();
      axisBreak.endLine = new WavedLine();
      var wavedRectangle = new WavedRectangle();
      wavedRectangle.setWavedSides(false, true, false, true);
      axisBreak.fillShape = wavedRectangle;
    };
    AxisRendererX2.prototype.toAxisPosition = function(value) {
      var inversedPosition = value;
      var axis = this.axis;
      if (axis) {
        var relativePositionSprite = axis.relativePositionSprite;
        var x = axis.pixelX;
        if (relativePositionSprite) {
          x = spritePointToSprite({ x: this.pixelX, y: 0 }, this.parent, relativePositionSprite).x;
        } else {
          relativePositionSprite = axis.parent;
        }
        if (relativePositionSprite) {
          var relativeX = x / relativePositionSprite.innerWidth;
          var relativeWidth = axis.axisLength / relativePositionSprite.innerWidth;
          return (inversedPosition - relativeX) / relativeWidth;
        }
      }
      return value;
    };
    AxisRendererX2.prototype.updateBullet = function(bullet, position, endPosition) {
      var location = 0.5;
      if (bullet instanceof AxisBullet) {
        location = bullet.location;
      }
      position = position + (endPosition - position) * location;
      var point = this.positionToPoint(position);
      point.y = spritePointToSprite({ x: 0, y: this.line.pixelY }, this.line.parent, this.gridContainer).y;
      this.positionItem(bullet, point);
      this.toggleVisibility(bullet, position, 0, 1);
    };
    return AxisRendererX2;
  }(AxisRenderer)
);
registry.registeredClasses["AxisRendererX"] = AxisRendererX;
defaultRules.push({
  relevant: ResponsiveBreakpoints.heightXS,
  state: function(target, stateId) {
    if (target instanceof AxisRendererX) {
      var state = target.states.create(stateId);
      state.properties.inside = true;
      state.properties.maxLabelPosition = 0.9;
      state.properties.minLabelPosition = 0.1;
      return state;
    }
    return null;
  }
});
defaultRules.push({
  relevant: ResponsiveBreakpoints.heightXXS,
  state: function(target, stateId) {
    if (target instanceof AxisRendererX) {
      var state = target.states.create(stateId);
      state.properties.disabled = true;
      return state;
    }
    return null;
  }
});

// node_modules/@amcharts/amcharts4/.internal/charts/axes/CategoryAxisBreak.js
var CategoryAxisBreak = (
  /** @class */
  function(_super) {
    __extends(CategoryAxisBreak2, _super);
    function CategoryAxisBreak2() {
      var _this = _super.call(this) || this;
      _this.className = "CategoryAxisBreak";
      _this.properties.startLocation = 0.5;
      _this.properties.endLocation = 0.5;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(CategoryAxisBreak2.prototype, "startPosition", {
      /**
       * Pixel position of the break's start.
       *
       * @return Position (px)
       * @readonly
       */
      get: function() {
        if (this.axis) {
          return this.axis.indexToPosition(this.adjustedStartValue, this.startLocation);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CategoryAxisBreak2.prototype, "endPosition", {
      /**
       * Pixel position of the break's end.
       *
       * @return Position (px)
       * @readonly
       */
      get: function() {
        if (this.axis) {
          return this.axis.indexToPosition(this.adjustedEndValue, this.endLocation);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CategoryAxisBreak2.prototype, "startCategory", {
      /**
       * @return Start category
       */
      get: function() {
        return this.getPropertyValue("startCategory");
      },
      /**
       * A category break starts on.
       *
       * @param value Start category
       */
      set: function(value) {
        if (this.setPropertyValue("startCategory", value)) {
          if (this.axis) {
            this.axis.invalidateDataItems();
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CategoryAxisBreak2.prototype, "endCategory", {
      /**
       * @return End category
       */
      get: function() {
        return this.getPropertyValue("endCategory");
      },
      /**
       * A category break ends on.
       *
       * @param value  End category
       */
      set: function(value) {
        if (this.setPropertyValue("endCategory", value)) {
          if (this.axis) {
            this.axis.invalidateDataItems();
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CategoryAxisBreak2.prototype, "startValue", {
      /**
       * @return Value
       */
      get: function() {
        var category = this.getPropertyValue("startCategory");
        if (category) {
          return this.axis.categoryToIndex(category);
        } else {
          return this.getPropertyValue("startValue");
        }
      },
      /**
       * An index of start category.
       *
       * @param value  Value
       */
      set: function(value) {
        if (this.setPropertyValue("startValue", value)) {
          if (this.axis) {
            this.axis.invalidateDataItems();
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CategoryAxisBreak2.prototype, "endValue", {
      /**
       * @return Value
       */
      get: function() {
        var category = this.getPropertyValue("endCategory");
        if (category) {
          return this.axis.categoryToIndex(category);
        } else {
          return this.getPropertyValue("endValue");
        }
      },
      /**
       * An index of end category or a end value.
       *
       * @param value  Value
       */
      set: function(value) {
        if (this.setPropertyValue("endValue", value)) {
          if (this.axis) {
            this.axis.invalidateDataItems();
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CategoryAxisBreak2.prototype, "startLocation", {
      /**
       * @return Break start location
       */
      get: function() {
        return this.getPropertyValue("startLocation");
      },
      /**
       * Indicates where within starting category break should begin.
       *
       * Values range from `0` (start) to `1` (end), with default being `0.5` (middle).
       *
       * E.g. if you want to a break to fully encompass start and end categories,
       * you should set `startLocation = 0` and `endLocation = 1`.
       *
       * @since 4.9.17
       * @default 0.5
       * @param  value  Break start location
       */
      set: function(value) {
        if (this.setPropertyValue("startLocation", value)) {
          if (this.axis) {
            this.axis.invalidateDataItems();
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CategoryAxisBreak2.prototype, "endLocation", {
      /**
       * @return Break end location
       */
      get: function() {
        return this.getPropertyValue("endLocation");
      },
      /**
       * Indicates where within ending category break should end.
       *
       * Values range from `0` (start) to `1` (end), with default being `0.5` (middle).
       *
       * E.g. if you want to a break to fully encompass start and end categories,
       * you should set `startLocation = 0` and `endLocation = 1`.
       *
       * @since 4.9.17
       * @default 0.5
       * @param  value  Break end location
       */
      set: function(value) {
        if (this.setPropertyValue("endLocation", value)) {
          if (this.axis) {
            this.axis.invalidateDataItems();
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    return CategoryAxisBreak2;
  }(AxisBreak)
);
registry.registeredClasses["CategoryAxisBreak"] = CategoryAxisBreak;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/CategoryAxis.js
var CategoryAxisDataItem = (
  /** @class */
  function(_super) {
    __extends(CategoryAxisDataItem2, _super);
    function CategoryAxisDataItem2() {
      var _this = _super.call(this) || this;
      _this.seriesDataItems = {};
      _this.className = "CategoryAxisDataItem";
      _this.text = "{category}";
      _this.locations.category = 0;
      _this.locations.endCategory = 1;
      _this.deltaPosition = 0;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(CategoryAxisDataItem2.prototype, "category", {
      /**
       * @return Category
       */
      get: function() {
        if (this._adapterO) {
          if (this._adapterO.isEnabled("category")) {
            return this._adapterO.apply("category", this.properties.category);
          }
        }
        return this.properties.category;
      },
      /**
       * Category.
       *
       * @param value  Category
       */
      set: function(value) {
        var oldCategory = this.properties.category;
        this.setProperty("category", value);
        if (hasValue(oldCategory) && oldCategory != value) {
          if (this.component) {
            this.component.validateDataElement(this);
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CategoryAxisDataItem2.prototype, "endCategory", {
      /**
       * @return End category
       */
      get: function() {
        return this.properties.endCategory;
      },
      /**
       * End category.
       *
       * Used for items that span several categories, like [[CategoryAxisBreak]].
       *
       * @param value  End category
       */
      set: function(value) {
        this.setProperty("endCategory", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CategoryAxisDataItem2.prototype, "deltaPosition", {
      get: function() {
        return this.properties.deltaCoordinate;
      },
      set: function(value) {
        if (value != this.properties.deltaCoordinate) {
          this.setProperty("deltaCoordinate", value);
          if (this.component) {
            this.component.invalidateDataItems();
            this.component.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    return CategoryAxisDataItem2;
  }(AxisDataItem)
);
var CategoryAxis = (
  /** @class */
  function(_super) {
    __extends(CategoryAxis2, _super);
    function CategoryAxis2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.dataItemsByCategory = new Dictionary();
      _this.className = "CategoryAxis";
      _this.axisFieldName = "category";
      _this._lastDataItem = _this.createDataItem();
      _this._lastDataItem.component = _this;
      _this._disposers.push(_this._lastDataItem);
      _this.applyTheme();
      var dataItemsByCategory = _this.dataItemsByCategory;
      _this.addDisposer(_this.mainDataSet.events.on("removed", function(event) {
        dataItemsByCategory.removeKey(event.oldValue.category);
      }));
      return _this;
    }
    CategoryAxis2.prototype.createDataItem = function() {
      return new CategoryAxisDataItem();
    };
    CategoryAxis2.prototype.createAxisBreak = function() {
      return new CategoryAxisBreak();
    };
    CategoryAxis2.prototype.processSeriesDataItem = function(dataItem, axisLetter) {
      _super.prototype.processSeriesDataItem.call(this, dataItem, axisLetter);
      var category = dataItem["category" + this.axisLetter];
      if (hasValue(category)) {
        var categoryAxisDataItem = this.dataItemsByCategory.getKey(category);
        if (categoryAxisDataItem) {
          var seriesId = dataItem.component.uid;
          var seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];
          if (!seriesDataItems) {
            seriesDataItems = [];
            categoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;
          }
          seriesDataItems.push(dataItem);
        }
      } else {
        dataItem.component.dataItems.remove(dataItem);
      }
    };
    CategoryAxis2.prototype.validateDataRange = function() {
      var _this = this;
      _super.prototype.validateDataRange.call(this);
      each3(this._series.iterator(), function(series) {
        if (series.xAxis instanceof CategoryAxis2 && series.yAxis instanceof CategoryAxis2) {
          series.invalidateDataRange();
        } else {
          var startIndex = _this.positionToIndex(_this.start);
          var endIndex = _this.positionToIndex(_this.end);
          if (endIndex >= _this.dataItems.length) {
            endIndex--;
          }
          var seriesId = series.uid;
          var minIndex = void 0;
          var maxIndex = void 0;
          for (var i = startIndex; i <= endIndex; i++) {
            var axisDataItem = _this.dataItems.getIndex(i);
            if (axisDataItem) {
              var seriesDataItems = axisDataItem.seriesDataItems[seriesId];
              if (seriesDataItems) {
                for (var i_1 = 0; i_1 < seriesDataItems.length; i_1++) {
                  var seriesDataItem = seriesDataItems[i_1];
                  if (seriesDataItem) {
                    var index = seriesDataItem.index;
                    if (!isNumber(minIndex) || index < minIndex) {
                      minIndex = index;
                    }
                    if (!isNumber(maxIndex) || index > maxIndex) {
                      maxIndex = index;
                    }
                  }
                }
              }
            }
          }
          if (isNumber(minIndex)) {
            series.startIndex = minIndex;
          } else {
            series.start = _this.start;
          }
          if (isNumber(maxIndex)) {
            series.endIndex = maxIndex + 1;
          } else {
            series.end = _this.end;
          }
          if (_this._axisBreaks && _this._axisBreaks.length > 0) {
            series.invalidateDataRange();
          }
        }
      });
    };
    CategoryAxis2.prototype.validate = function() {
      var _this = this;
      _super.prototype.validate.call(this);
      var dataCount = this.dataItems.length;
      var startIndex = fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);
      var endIndex = fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);
      if (this.renderer.invalid) {
        this.renderer.validate();
      }
      var maxCount = this.renderer.axisLength / Math.max(this.renderer.minGridDistance, 1 / Number.MAX_SAFE_INTEGER);
      var frequency = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));
      this._startIndex = Math.floor(startIndex / frequency) * frequency;
      this._endIndex = Math.ceil(this.end * dataCount);
      this.fixAxisBreaks();
      if (this._startIndex == this._endIndex) {
        this._endIndex++;
      }
      this._frequency = frequency;
      if (this.axisLength <= 0) {
        return;
      }
      this.maxZoomFactor = this.dataItems.length;
      if (this.dataItems.length <= 0) {
        this.maxZoomFactor = 1;
      }
      this.resetIterators();
      startIndex = max(0, this._startIndex - this._frequency);
      endIndex = min(this.dataItems.length, this._endIndex + this._frequency);
      var itemIndex = 0;
      for (var i = 0; i < startIndex; i++) {
        var dataItem = this.dataItems.getIndex(i);
        dataItem.__disabled = true;
      }
      for (var i = endIndex, len = this.dataItems.length; i < len; i++) {
        var dataItem = this.dataItems.getIndex(i);
        dataItem.__disabled = true;
      }
      for (var i = startIndex; i < endIndex; i++) {
        if (i < this.dataItems.length) {
          var dataItem = this.dataItems.getIndex(i);
          if (i / this._frequency == Math.round(i / this._frequency)) {
            var axisBreak = this.isInBreak(i);
            if (!axisBreak) {
              this.appendDataItem(dataItem);
              this.validateDataElement(dataItem, itemIndex);
            }
            itemIndex++;
          } else {
            dataItem.__disabled = true;
          }
        }
      }
      this.appendDataItem(this._lastDataItem);
      this.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);
      if (this._axisBreaks) {
        var axisBreaks = this._axisBreaks;
        axisBreaks.each(function(axisBreak2) {
          var adjustedStartValue = axisBreak2.adjustedStartValue;
          var adjustedEndValue = axisBreak2.adjustedEndValue;
          if (intersect({ start: adjustedStartValue, end: adjustedEndValue }, { start: _this._startIndex, end: _this._endIndex })) {
            for (var b = adjustedStartValue; b <= adjustedEndValue; b++) {
              var dataItem2 = _this.dataItems.getIndex(b);
              dataItem2.__disabled = true;
            }
            var frequency_1 = fitToRange(Math.ceil(_this._frequency / axisBreak2.breakSize), 1, adjustedEndValue - adjustedStartValue);
            var itemIndex_1 = 0;
            if (axisBreak2.breakSize > 0) {
              for (var b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency_1) {
                var dataItem2 = _this.dataItems.getIndex(b);
                dataItem2.__disabled = false;
                _this.appendDataItem(dataItem2);
                _this.validateDataElement(dataItem2, itemIndex_1);
                itemIndex_1++;
              }
            }
          }
        });
      }
      this.validateBreaks();
      this.validateAxisRanges();
      this.ghostLabel.invalidate();
      this.renderer.invalidateLayout();
    };
    CategoryAxis2.prototype.validateDataElement = function(dataItem, itemIndex, index) {
      _super.prototype.validateDataElement.call(this, dataItem);
      dataItem.itemIndex = this._axisItemCount;
      this._axisItemCount++;
      var renderer = this.renderer;
      if (!isNumber(index)) {
        index = this.categoryToIndex(dataItem.category);
      }
      var endIndex = this.categoryToIndex(dataItem.endCategory);
      if (!isNumber(endIndex)) {
        endIndex = index;
      }
      var position = this.indexToPosition(index, dataItem.locations.category);
      var endPosition = this.indexToPosition(endIndex, dataItem.locations.endCategory);
      dataItem.position = position;
      var fillEndIndex;
      var fillPosition;
      var fillEndPosition;
      if (dataItem.isRange) {
        fillEndIndex = endIndex;
        fillPosition = this.indexToPosition(index, dataItem.locations.category);
        fillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);
      }
      dataItem.point = renderer.positionToPoint(position);
      var tick = dataItem.tick;
      if (tick && !tick.disabled) {
        renderer.updateTickElement(tick, position, endPosition);
      }
      var grid = dataItem.grid;
      if (grid && !grid.disabled) {
        renderer.updateGridElement(grid, position, endPosition);
      }
      var label = dataItem.label;
      if (label && !label.disabled) {
        if (!dataItem.isRange || label.text == void 0) {
          dataItem.text = dataItem.text;
        }
        renderer.updateLabelElement(label, position, endPosition);
        if (renderer instanceof AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth || renderer instanceof AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight) {
          if (dataItem.label.html) {
            this.ghostLabel.html = dataItem.label.currentText;
          } else {
            this.ghostLabel.text = dataItem.label.currentText;
          }
        }
      }
      var fill = dataItem.axisFill;
      if (fill && !fill.disabled) {
        if (!dataItem.isRange) {
          fillEndIndex = index + this._frequency;
          fillPosition = this.indexToPosition(index, fill.location);
          fillEndPosition = this.indexToPosition(fillEndIndex, fill.location);
        }
        renderer.updateFillElement(fill, fillPosition, fillEndPosition);
        if (!dataItem.isRange) {
          this.fillRule(dataItem, itemIndex);
        }
      }
      if (dataItem.bullet) {
        renderer.updateBullet(dataItem.bullet, position, endPosition);
      }
      var mask = dataItem.mask;
      if (mask) {
        renderer.updateFillElement(mask, fillPosition, fillEndPosition);
      }
    };
    CategoryAxis2.prototype.disposeData = function() {
      this.dataItemsByCategory.clear();
      _super.prototype.disposeData.call(this);
    };
    CategoryAxis2.prototype.processDataItem = function(dataItem, dataContext) {
      if (dataItem) {
        _super.prototype.processDataItem.call(this, dataItem, dataContext);
        if (hasValue(dataItem.category)) {
          this.dataItemsByCategory.setKey(dataItem.category, dataItem);
        }
      }
    };
    CategoryAxis2.prototype.getDataItem = function(dataContext) {
      var category = dataContext[this.dataFields.category];
      if (hasValue(category)) {
        var dataItem = this.dataItemsByCategory.getKey(category);
        if (dataItem) {
          return dataItem;
        } else {
          return this.dataItems.create();
        }
      }
    };
    CategoryAxis2.prototype.indexToPosition = function(index, location) {
      if (!isNumber(location)) {
        location = 0.5;
      }
      var startIndex = this.startIndex;
      var endIndex = this.endIndex;
      var difference = this.adjustDifference(startIndex, endIndex);
      var startLocation = this.startLocation;
      var endLocation = this.endLocation;
      difference -= startLocation;
      difference -= 1 - endLocation;
      if (this._axisBreaks) {
        var axisBreaks = this._axisBreaks;
        eachContinue2(axisBreaks.iterator(), function(axisBreak) {
          var breakStartIndex = axisBreak.adjustedStartValue;
          var breakEndIndex = axisBreak.adjustedEndValue;
          if (index < startIndex || !isNumber(breakStartIndex) || !isNumber(breakEndIndex)) {
            return false;
          }
          if (intersect({ start: breakStartIndex, end: breakEndIndex }, { start: startIndex, end: endIndex })) {
            breakStartIndex = Math.max(startIndex, breakStartIndex);
            breakEndIndex = Math.min(endIndex, breakEndIndex);
            var breakSize = axisBreak.breakSize;
            if (index > breakEndIndex) {
              startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);
            } else if (index < breakStartIndex) {
            } else {
              index = breakStartIndex + (index - breakStartIndex) * breakSize;
            }
          }
          return true;
        });
      }
      var deltaPosition = 0;
      var dataItem = this.dataItems.getIndex(index);
      if (dataItem) {
        deltaPosition = dataItem.deltaPosition;
      }
      return round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);
    };
    CategoryAxis2.prototype.categoryToPosition = function(category, location) {
      var index = this.categoryToIndex(category);
      return this.indexToPosition(index, location);
    };
    CategoryAxis2.prototype.categoryToPoint = function(category, location) {
      var position = this.categoryToPosition(category, location);
      var point = this.renderer.positionToPoint(position);
      var angle = this.renderer.positionToAngle(position);
      return { x: point.x, y: point.y, angle };
    };
    CategoryAxis2.prototype.anyToPoint = function(category, location) {
      return this.categoryToPoint(category, location);
    };
    CategoryAxis2.prototype.anyToPosition = function(category, location) {
      return this.categoryToPosition(category, location);
    };
    CategoryAxis2.prototype.categoryToIndex = function(category) {
      if (hasValue(category)) {
        var dataItem = this.dataItemsByCategory.getKey(category);
        if (dataItem) {
          return dataItem.index;
        }
      }
    };
    CategoryAxis2.prototype.zoomToCategories = function(startCategory, endCategory) {
      this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);
    };
    CategoryAxis2.prototype.getAnyRangePath = function(start, end, startLocation, endLocation) {
      var startPos = this.categoryToPosition(start, startLocation);
      var endPos = this.categoryToPosition(end, endLocation);
      return this.getPositionRangePath(startPos, endPos);
    };
    CategoryAxis2.prototype.roundPosition = function(position, location) {
      var index = this.positionToIndex(position);
      return this.indexToPosition(index, location);
    };
    CategoryAxis2.prototype.getFirstSeriesDataItem = function(series, category) {
      for (var i = 0; i < series.dataItems.length; i++) {
        var dataItem = series.dataItems.getIndex(i);
        if (series.xAxis == this) {
          if (dataItem.categoryX == category) {
            return dataItem;
          }
        }
        if (series.yAxis == this) {
          if (dataItem.categoryY == category) {
            return dataItem;
          }
        }
      }
    };
    CategoryAxis2.prototype.getLastSeriesDataItem = function(series, category) {
      for (var i = series.dataItems.length - 1; i >= 0; i--) {
        var dataItem = series.dataItems.getIndex(i);
        if (series.xAxis == this) {
          if (dataItem.categoryX == category) {
            return dataItem;
          }
        }
        if (series.yAxis == this) {
          if (dataItem.categoryY == category) {
            return dataItem;
          }
        }
      }
    };
    CategoryAxis2.prototype.getSeriesDataItemByCategory = function(category, series) {
      var _this = this;
      var seriesDataItem;
      series.dataItems.each(function(dataItem) {
        if (series.xAxis == _this) {
          if (dataItem.categoryX == category) {
            seriesDataItem = dataItem;
          }
        } else if (series.yAxis == _this) {
          if (dataItem.categoryY == category) {
            seriesDataItem = dataItem;
          }
        }
      });
      return seriesDataItem;
    };
    CategoryAxis2.prototype.getSeriesDataItem = function(series, position, findNearest) {
      var _this = this;
      if (isNumber(position)) {
        var index_1 = this.positionToIndex(position);
        if (index_1 >= this.dataItems.length) {
          index_1--;
        }
        var dataItem = this.dataItems.getIndex(index_1);
        if (dataItem) {
          var category_1 = dataItem.category;
          var sdi_1;
          var seriesDataItem = series.dataItems.getIndex(index_1);
          if (seriesDataItem) {
            if (series.xAxis == this) {
              if (seriesDataItem.categoryX == category_1) {
                return seriesDataItem;
              }
            }
            if (series.yAxis == this) {
              if (seriesDataItem.categoryY == category_1) {
                return seriesDataItem;
              }
            }
          }
          series.dataItems.each(function(dataItem2) {
            if (series.xAxis == _this) {
              if (dataItem2.categoryX == category_1) {
                if (!sdi_1) {
                  sdi_1 = dataItem2;
                }
                if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem2.index)) {
                  sdi_1 = dataItem2;
                }
              }
            }
            if (series.yAxis == _this) {
              if (dataItem2.categoryY == category_1) {
                if (!sdi_1) {
                  sdi_1 = dataItem2;
                }
                if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem2.index)) {
                  sdi_1 = dataItem2;
                }
              }
            }
          });
          if (findNearest) {
          }
          return sdi_1;
        }
      }
    };
    CategoryAxis2.prototype.getX = function(dataItem, key, location, stackKey, range) {
      var position = this.getPositionX(dataItem, key, location, stackKey, range);
      if (isNaN(position)) {
        return this.basePoint.x;
      } else {
        return this.renderer.positionToPoint(position).x;
      }
    };
    CategoryAxis2.prototype.getPositionX = function(dataItem, key, location, stackKey, range) {
      var position;
      if (hasValue(key)) {
        position = this.categoryToPosition(dataItem.categories[key], location);
      }
      if (range) {
        position = fitToRange(position, range.start, range.end);
      }
      return position;
    };
    CategoryAxis2.prototype.getY = function(dataItem, key, location, stackKey, range) {
      var position = this.getPositionY(dataItem, key, location, stackKey, range);
      if (isNaN(position)) {
        return this.basePoint.y;
      } else {
        return this.renderer.positionToPoint(position).y;
      }
    };
    CategoryAxis2.prototype.getPositionY = function(dataItem, key, location, stackKey, range) {
      var position;
      if (hasValue(key)) {
        position = this.categoryToPosition(dataItem.categories[key], location);
      }
      if (range) {
        position = fitToRange(position, range.start, range.end);
      }
      return position;
    };
    CategoryAxis2.prototype.getAngle = function(dataItem, key, location, stackKey, range) {
      var position = this.categoryToPosition(dataItem.categories[key], location);
      if (range) {
        position = fitToRange(position, range.start, range.end);
      }
      return this.positionToAngle(position);
    };
    CategoryAxis2.prototype.getCellStartPosition = function(position) {
      return this.roundPosition(position, 0);
    };
    CategoryAxis2.prototype.getCellEndPosition = function(position) {
      return this.roundPosition(position, 1);
    };
    CategoryAxis2.prototype.getTooltipText = function(position) {
      var dataItem = this.dataItems.getIndex(this.positionToIndex(position));
      if (dataItem) {
        this.tooltipDataItem = dataItem;
        this.tooltip.dataItem = dataItem;
        if (this.tooltipText) {
          return this.tooltipText;
        }
        if (!this._adapterO) {
          return dataItem.category;
        } else {
          return this._adapterO.apply("getTooltipText", dataItem.category);
        }
      }
    };
    CategoryAxis2.prototype.positionToIndex = function(position) {
      position = round(position, 10);
      if (position < 0) {
        position = 0;
      }
      if (position > 1) {
        position = 1;
      }
      var startIndex = this.startIndex;
      var endIndex = this.endIndex;
      var difference = endIndex - startIndex - this.startLocation - (1 - this.endLocation);
      position += 1 / difference * this.startLocation;
      var index = null;
      if (this._axisBreaks) {
        var axisBreaks = this._axisBreaks;
        eachContinue2(axisBreaks.iterator(), function(axisBreak) {
          var breakStartPosition = axisBreak.startPosition;
          var breakEndPosition = axisBreak.endPosition;
          var breakStartIndex = axisBreak.adjustedStartValue;
          var breakEndIndex = axisBreak.adjustedEndValue;
          breakStartIndex = max(breakStartIndex, startIndex);
          breakEndIndex = min(breakEndIndex, endIndex);
          var breakSize = axisBreak.breakSize;
          difference -= (breakEndIndex - breakStartIndex) * (1 - breakSize);
          if (position > breakEndPosition) {
            startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);
          } else if (position < breakStartPosition) {
          } else {
            var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);
            index = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));
            return false;
          }
          return true;
        });
      }
      if (!isNumber(index)) {
        index = Math.floor(position * difference + startIndex);
      }
      if (index >= this.dataItems.length) {
        index = this.dataItems.length - 1;
      }
      return index;
    };
    CategoryAxis2.prototype.positionToCategory = function(position) {
      return this.getPositionLabel(position);
    };
    CategoryAxis2.prototype.getPositionLabel = function(position) {
      var dataItem = this.dataItems.getIndex(this.positionToIndex(position));
      if (dataItem) {
        return dataItem.category;
      }
    };
    Object.defineProperty(CategoryAxis2.prototype, "basePoint", {
      /**
       * Coordinates of the actual axis start.
       *
       * @ignore Exclude from docs
       * @return Base point
       */
      get: function() {
        return this.renderer.positionToPoint(1);
      },
      enumerable: true,
      configurable: true
    });
    CategoryAxis2.prototype.initRenderer = function() {
      _super.prototype.initRenderer.call(this);
      var renderer = this.renderer;
      renderer.baseGrid.disabled = true;
    };
    Object.defineProperty(CategoryAxis2.prototype, "frequency", {
      /**
       * Current frequency of labels of the axis.
       *
       * Normally it would be 1, but when labels start to be hidden due
       * to `minGridDistance` this read-only property will increase.
       *
       * @readonly
       * @since 4.2.0
       * @return Label frequency
       */
      get: function() {
        return this._frequency;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CategoryAxis2.prototype, "sortBySeries", {
      /**
       * @return Sort categories?
       */
      get: function() {
        return this.getPropertyValue("sortBySeries");
      },
      /**
       * If set to a reference of [[ColumnSeries]] the categories will be sorted
       * by actual values.
       *
       * The categories are ordered in descending order (from highest values to
       * lowest). To reverse the order, use axis renderer's `inversed` setting.
       * E.g.:
       *
       * ```TypeScript
       * categoryAxis.sortBySeries = series;
       * categoryAxis.renderer.inversed = true;
       * ```
       * ```JavaScript
       * categoryAxis.sortBySeries = series;
       * categoryAxis.renderer.inversed = true;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "xAxes": [{
       *     // ...
       *     "sortBySeries": "s1",
       *     "renderer": {
       *       // ...
       *       "inversed": true
       *     }
       *   }]
       * }
       * ```
       *
       * @since 4.8.7
       * @param  value  Sort categories?
       */
      set: function(value) {
        this.setPropertyValue("sortBySeries", value, true);
      },
      enumerable: true,
      configurable: true
    });
    CategoryAxis2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config.sortBySeries) && isString(config.sortBySeries)) {
          if (this.map.hasKey(config.sortBySeries)) {
            config.sortBySeries = this.map.getKey(config.sortBySeries);
          } else {
            this.addDelayedMap("sortBySeries", config.sortBySeries);
            delete config.sortBySeries;
          }
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    return CategoryAxis2;
  }(Axis)
);
registry.registeredClasses["CategoryAxis"] = CategoryAxis;
registry.registeredClasses["CategoryAxisDataItem"] = CategoryAxisDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/series/XYSeries.js
var XYSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(XYSeriesDataItem2, _super);
    function XYSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "XYSeriesDataItem";
      _this.values.customValue = {};
      _this.values.valueX = { stack: 0 };
      _this.values.valueY = { stack: 0 };
      _this.values.openValueX = {};
      _this.values.openValueY = {};
      _this.values.dateX = {};
      _this.values.dateY = {};
      _this.values.openDateX = {};
      _this.values.openDateY = {};
      _this.setLocation("dateX", 0.5, 0);
      _this.setLocation("dateY", 0.5, 0);
      _this.setLocation("categoryX", 0.5, 0);
      _this.setLocation("categoryY", 0.5, 0);
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(XYSeriesDataItem2.prototype, "valueX", {
      /**
       * @return Value
       */
      get: function() {
        return this.values.valueX.value;
      },
      /**
       * Item's numeric value on X value axis.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("valueX", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeriesDataItem2.prototype, "customValue", {
      /**
       * @return Value
       */
      get: function() {
        return this.values.customValue.value;
      },
      /**
       * Item's custom numeric value.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("customValue", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeriesDataItem2.prototype, "valueY", {
      /**
       * @return Value
       */
      get: function() {
        return this.values.valueY.value;
      },
      /**
       * Item's numeric value on Y value axis.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("valueY", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeriesDataItem2.prototype, "dateX", {
      /**
       * @return Date
       */
      get: function() {
        return this.getDate("dateX");
      },
      /**
       * Item's date value on X date-based axis.
       *
       * @param date  Date
       */
      set: function(date) {
        this.setDate("dateX", date);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeriesDataItem2.prototype, "dateY", {
      /**
       * @return Date
       */
      get: function() {
        return this.getDate("dateY");
      },
      /**
       * Item's date value on Y date-based axis.
       *
       * @param date  Date
       */
      set: function(date) {
        this.setDate("dateY", date);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeriesDataItem2.prototype, "categoryX", {
      /**
       * @return Category
       */
      get: function() {
        return this.categories.categoryX;
      },
      /**
       * Item's category on X category axis.
       *
       * @param category  Category
       */
      set: function(category) {
        this.setCategory("categoryX", category);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeriesDataItem2.prototype, "categoryY", {
      /**
       * @return Category
       */
      get: function() {
        return this.categories.categoryY;
      },
      /**
       * Item's category on Y category axis.
       *
       * @param category  Category
       */
      set: function(category) {
        this.setCategory("categoryY", category);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeriesDataItem2.prototype, "openValueX", {
      /**
       * @return Value
       */
      get: function() {
        return this.values.openValueX.value;
      },
      /**
       * Item's open numeric value on X value axis.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("openValueX", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeriesDataItem2.prototype, "openValueY", {
      /**
       * @return Value
       */
      get: function() {
        return this.values.openValueY.value;
      },
      /**
       * Item's open numeric value on Y value axis.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("openValueY", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeriesDataItem2.prototype, "openDateX", {
      /**
       * @return Date
       */
      get: function() {
        return this.getDate("openDateX");
      },
      /**
       * Item's open date value on X date-based axis.
       *
       * @param date  Date
       */
      set: function(date) {
        this.setDate("openDateX", date);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeriesDataItem2.prototype, "openDateY", {
      /**
       * @return Date
       */
      get: function() {
        return this.getDate("openDateY");
      },
      /**
       * Item's open date value on Y date-based axis.
       *
       * @param date  Date
       */
      set: function(date) {
        this.setDate("openDateY", date);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeriesDataItem2.prototype, "openCategoryX", {
      /**
       * @return Category
       */
      get: function() {
        return this.categories.openCategoryX;
      },
      /**
       * Item's open category on X category axis.
       *
       * @param category  Category
       */
      set: function(category) {
        this.setCategory("openCategoryX", category);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeriesDataItem2.prototype, "openCategoryY", {
      /**
       * @return Category
       */
      get: function() {
        return this.categories.openCategoryY;
      },
      /**
       * Item's open category on Y category axis.
       *
       * @param category  Category
       */
      set: function(category) {
        this.setCategory("openCategoryY", category);
      },
      enumerable: true,
      configurable: true
    });
    XYSeriesDataItem2.prototype.getMin = function(fields, working, stackValue) {
      var _this = this;
      var min2;
      if (!isNumber(stackValue)) {
        stackValue = 0;
      }
      each(fields, function(field) {
        var value;
        if (working) {
          value = _this.getWorkingValue(field);
        } else {
          value = _this.getValue(field);
        }
        value += stackValue;
        if (value < min2 || !isNumber(min2)) {
          min2 = value;
        }
      });
      return min2;
    };
    XYSeriesDataItem2.prototype.getMax = function(fields, working, stackValue) {
      var _this = this;
      var max2;
      if (!isNumber(stackValue)) {
        stackValue = 0;
      }
      each(fields, function(field) {
        var value;
        if (working) {
          value = _this.getWorkingValue(field);
        } else {
          value = _this.getValue(field);
        }
        value += stackValue;
        if (value > max2 || !isNumber(max2)) {
          max2 = value;
        }
      });
      return max2;
    };
    return XYSeriesDataItem2;
  }(SeriesDataItem)
);
var XYSeries = (
  /** @class */
  function(_super) {
    __extends(XYSeries2, _super);
    function XYSeries2() {
      var _this = _super.call(this) || this;
      _this.groupFields = {};
      _this._xAxis = new MutableValueDisposer();
      _this._yAxis = new MutableValueDisposer();
      _this._xValueFields = [];
      _this._yValueFields = [];
      _this._baseInterval = {};
      _this.dataGrouped = false;
      _this.usesShowFields = false;
      _this._dataSetChanged = false;
      _this._maxxX = 1e5;
      _this._maxxY = 1e5;
      _this._propertiesChanged = false;
      _this.outOfRange = false;
      _this.className = "XYSeries";
      _this.isMeasured = false;
      _this.groupFields.valueX = "close";
      _this.groupFields.valueY = "close";
      _this.groupFields.customValue = "close";
      _this.groupFields.openValueX = "open";
      _this.groupFields.openValueY = "open";
      _this.cursorTooltipEnabled = true;
      _this.cursorHoverEnabled = true;
      _this.excludeFromTotal = false;
      _this.mainContainer.mask = new Sprite();
      _this.mainContainer.mask.setElement(_this.paper.add("path"));
      _this.stacked = false;
      _this.snapTooltip = false;
      _this._showBullets = false;
      _this.tooltip.pointerOrientation = "horizontal";
      _this.properties.stackToNegative = true;
      _this.hideTooltipWhileZooming = true;
      _this.setPropertyValue("maskBullets", true);
      _this.tooltip.events.on("hidden", function() {
        _this.returnBulletDefaultState();
      }, void 0, false);
      _this._disposers.push(_this._xAxis);
      _this._disposers.push(_this._yAxis);
      _this.observe(visualProperties, function() {
        if (_this.inited) {
          _this._propertiesChanged = true;
          if (_this.legendDataItem) {
            _this.legendDataItem.childrenCreated = false;
          }
          if (_this.chart && _this.chart.legend) {
            _this.chart.legend.invalidateDataItems();
          }
          _this.invalidate();
        }
      }, void 0, false);
      _this.applyTheme();
      return _this;
    }
    XYSeries2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("X/Y Series");
      }
    };
    XYSeries2.prototype.createDataItem = function() {
      return new XYSeriesDataItem();
    };
    XYSeries2.prototype.resetExtremes = function() {
      this._tmin.clear();
      this._tmax.clear();
      this._smin.clear();
      this._smax.clear();
    };
    XYSeries2.prototype.dataChangeUpdate = function() {
      this.dataGrouped = false;
      this._baseInterval = {};
      this._currentDataSetId = "";
      this.resetExtremes();
      if (this.xAxis) {
        this.xAxis.seriesDataChangeUpdate(this);
      }
      if (this.yAxis) {
        this.yAxis.seriesDataChangeUpdate(this);
      }
    };
    XYSeries2.prototype.validateData = function() {
      this._baseInterval = {};
      var dataFields = this.dataFields;
      if (dataFields.valueYShow || dataFields.openValueXShow || dataFields.openValueXShow || dataFields.openValueYShow) {
        this.usesShowFields = true;
      } else {
        this.usesShowFields = false;
      }
      this.defineFields();
      if (this.data.length > 0) {
        this.dataChangeUpdate();
      }
      _super.prototype.validateData.call(this);
      this.updateItemReaderText();
      if (this.chart) {
        if (!hasValue(this.dataFields[this._xField]) || !hasValue(this.dataFields[this._yField])) {
          throw Error('Data fields for series "' + (this.name ? this.name : this.uid) + '" are not properly defined.');
        }
      }
      if (this.inited && this.isHidden) {
        this.hide(0);
      }
      this.dataGrouped = false;
    };
    XYSeries2.prototype.processDataItem = function(dataItem, dataContext) {
      try {
        _super.prototype.processDataItem.call(this, dataItem, dataContext);
        this.xAxis.processSeriesDataItem(dataItem, "X");
        this.yAxis.processSeriesDataItem(dataItem, "Y");
        this.setInitialWorkingValues(dataItem);
      } catch (e) {
        if (this._chart) {
          this._chart.raiseCriticalError(e);
        }
      }
    };
    XYSeries2.prototype.updateDataItem = function(dataItem) {
      _super.prototype.updateDataItem.call(this, dataItem);
      this.xAxis.processSeriesDataItem(dataItem, "X");
      this.yAxis.processSeriesDataItem(dataItem, "Y");
    };
    XYSeries2.prototype.setInitialWorkingValues = function(dataItem) {
    };
    XYSeries2.prototype.disposeData = function() {
      _super.prototype.disposeData.call(this);
      var xAxis = this.xAxis;
      var yAxis = this.yAxis;
      if (xAxis) {
        var dataItemsX = this.dataItemsByAxis.getKey(xAxis.uid);
        if (dataItemsX) {
          dataItemsX.clear();
        }
        if (xAxis instanceof CategoryAxis) {
          this.clearCatAxis(xAxis);
        }
      }
      if (yAxis) {
        var dataItemsY = this.dataItemsByAxis.getKey(yAxis.uid);
        if (dataItemsY) {
          dataItemsY.clear();
        }
        if (yAxis instanceof CategoryAxis) {
          this.clearCatAxis(yAxis);
        }
      }
    };
    XYSeries2.prototype.clearCatAxis = function(axis) {
      var uid = this.uid;
      axis.dataItems.each(function(dataItem) {
        if (dataItem.seriesDataItems[uid]) {
          dataItem.seriesDataItems[uid] = [];
        }
      });
    };
    XYSeries2.prototype.defineFields = function() {
      var xAxis = this.xAxis;
      var yAxis = this.yAxis;
      if (xAxis && yAxis) {
        var xAxisFieldName = xAxis.axisFieldName;
        var xField = xAxisFieldName + "X";
        var xOpenField = "open" + capitalize(xAxisFieldName) + "X";
        var yAxisFieldName = yAxis.axisFieldName;
        var yField = yAxisFieldName + "Y";
        var yOpenField = "open" + capitalize(yAxisFieldName) + "Y";
        this._xField = xField;
        this._yField = yField;
        if (this.dataFields[xOpenField]) {
          this._xOpenField = xOpenField;
        }
        if (this.dataFields[yOpenField]) {
          this._yOpenField = yOpenField;
        }
        if (!this.dataFields[yOpenField] && this.baseAxis == yAxis) {
          this._yOpenField = yField;
        }
        if (!this.dataFields[xOpenField] && this.baseAxis == xAxis) {
          this._xOpenField = xField;
        }
        if (this.stacked && this.baseAxis == xAxis) {
          this._xOpenField = xField;
        }
        if (this.stacked && this.baseAxis == yAxis) {
          this._yOpenField = yField;
        }
        if (xAxis instanceof CategoryAxis && yAxis instanceof CategoryAxis) {
          if (!this._yOpenField) {
            this._yOpenField = yField;
          }
        }
        this._xValueFields = [];
        this._yValueFields = [];
        this.addValueField(xAxis, this._xValueFields, this._xField);
        this.addValueField(xAxis, this._xValueFields, this._xOpenField);
        this.addValueField(yAxis, this._yValueFields, this._yField);
        this.addValueField(yAxis, this._yValueFields, this._yOpenField);
      }
    };
    XYSeries2.prototype.addValueField = function(axis, fields, field) {
      if (axis instanceof ValueAxis) {
        if (hasValue(this.dataFields[field]) && fields.indexOf(field) == -1) {
          fields.push(field);
        }
      }
    };
    XYSeries2.prototype.setCategoryAxisField = function(field, axis) {
      if (!hasValue(this.dataFields[field])) {
        this.dataFields[field] = axis.dataFields.category;
      }
    };
    XYSeries2.prototype.setDateAxisField = function(field, axis) {
      if (!hasValue(this.dataFields[field])) {
        this.dataFields[field] = axis.dataFields.date;
      }
    };
    XYSeries2.prototype.afterDraw = function() {
      _super.prototype.afterDraw.call(this);
      this.createMask();
    };
    XYSeries2.prototype.createMask = function() {
      if (this.mainContainer.mask) {
        var path_1 = this.getMaskPath();
        each3(this.axisRanges.iterator(), function(range) {
          if (range.axisFill.fillPath) {
            range.axisFill.validate();
            path_1 += range.axisFill.fillPath;
          }
        });
        this.mainContainer.mask.path = path_1;
      }
    };
    XYSeries2.prototype.getMaskPath = function() {
      if (this.xAxis && this.yAxis) {
        return rectToPath({
          x: 0,
          y: 0,
          width: this.xAxis.axisLength,
          height: this.yAxis.axisLength
        });
      }
      return "";
    };
    XYSeries2.prototype.getAxisField = function(axis) {
      if (axis == this.xAxis) {
        return this.xField;
      }
      if (axis == this.yAxis) {
        return this.yField;
      }
    };
    XYSeries2.prototype.validateDataItems = function() {
      var chart = this.chart;
      if (chart) {
        this._maxxX = max(1e5, chart.plotContainer.maxWidth * 2);
        this._maxxY = max(1e5, chart.plotContainer.maxHeight * 2);
      }
      var xAxis = this.xAxis;
      var yAxis = this.yAxis;
      if (xAxis && yAxis) {
        xAxis.updateAxisBySeries();
        yAxis.updateAxisBySeries();
      }
      _super.prototype.validateDataItems.call(this);
      if (xAxis && yAxis) {
        xAxis.postProcessSeriesDataItems(this);
        yAxis.postProcessSeriesDataItems(this);
      }
    };
    XYSeries2.prototype.validateDataRange = function() {
      var xAxis = this.xAxis;
      var yAxis = this.yAxis;
      if (xAxis && yAxis) {
        if (xAxis.dataRangeInvalid) {
          xAxis.validateDataRange();
        }
        if (yAxis.dataRangeInvalid) {
          yAxis.validateDataRange();
        }
      }
      _super.prototype.validateDataRange.call(this);
    };
    XYSeries2.prototype.validate = function() {
      var xAxis = this.xAxis;
      var yAxis = this.yAxis;
      if (xAxis && yAxis) {
        if (xAxis.invalid) {
          xAxis.validate();
        }
        if (yAxis.invalid) {
          yAxis.validate();
        }
        this.y = yAxis.pixelY;
        this.x = xAxis.pixelX;
        this._showBullets = true;
        var minBulletDistance = this.minBulletDistance;
        if (isNumber(minBulletDistance)) {
          if (this.baseAxis.axisLength / (this.endIndex - this.startIndex) < minBulletDistance) {
            this._showBullets = false;
          }
        }
      }
      this.updateTooltip();
      if (xAxis instanceof DateAxis && xAxis.groupData && !this.dataGrouped || yAxis instanceof DateAxis && yAxis.groupData && !this.dataGrouped) {
        return;
      }
      _super.prototype.validate.call(this);
      var chart = this.chart;
      var maskBullets = this.maskBullets;
      if (chart && maskBullets) {
        if (chart.className == "XYChart") {
          if (chart.leftAxesContainer.layout == "vertical" || chart.rightAxesContainer.layout == "vertical") {
            if (this.yAxis) {
              this.bulletsContainer.mask = this.yAxis.renderer.gridContainer;
            } else {
              this.bulletsContainer.mask = void 0;
            }
          }
          if (chart.topAxesContainer.layout == "horizontal" || chart.bottomAxesContainer.layout == "horizontal") {
            if (this.xAxis) {
              this.bulletsContainer.mask = this.xAxis.renderer.gridContainer;
            } else {
              this.bulletsContainer.mask = void 0;
            }
          }
        }
      }
    };
    Object.defineProperty(XYSeries2.prototype, "xAxis", {
      /**
       * @return Axis
       */
      get: function() {
        if (this.chart) {
          if (!this._xAxis.get()) {
            var axis = this.chart.xAxes.getIndex(0);
            if (!axis) {
              throw Error("There are no X axes on chart.");
            }
            this.xAxis = axis;
          }
          return this._xAxis.get();
        }
      },
      /**
       * X axis the series is attached to.
       *
       * @param axis  Axis
       */
      set: function(axis) {
        this.setXAxis(axis);
      },
      enumerable: true,
      configurable: true
    });
    XYSeries2.prototype.setXAxis = function(axis) {
      var oldAxis = this._xAxis.get();
      if (oldAxis != axis) {
        if (oldAxis) {
          this.dataItemsByAxis.removeKey(oldAxis.uid);
          this._xAxis.dispose();
          oldAxis.series.removeValue(this);
        }
        this._xAxis.set(axis, axis.registerSeries(this));
        this.dataItemsByAxis.setKey(axis.uid, new Dictionary());
        this.invalidateData();
      }
    };
    Object.defineProperty(XYSeries2.prototype, "yAxis", {
      /**
       * @return Axis
       */
      get: function() {
        if (this.chart) {
          if (!this._yAxis.get()) {
            var axis = this.chart.yAxes.getIndex(0);
            if (!axis) {
              throw Error("There are no Y axes on chart.");
            }
            this.yAxis = axis;
          }
          return this._yAxis.get();
        }
      },
      /**
       * Y axis the series is attached to.
       *
       * @param axis  Axis
       */
      set: function(axis) {
        this.setYAxis(axis);
      },
      enumerable: true,
      configurable: true
    });
    XYSeries2.prototype.setYAxis = function(axis) {
      var oldAxis = this._yAxis.get();
      if (oldAxis != axis) {
        if (oldAxis) {
          this.dataItemsByAxis.removeKey(oldAxis.uid);
          this._yAxis.dispose();
          oldAxis.series.removeValue(this);
        }
        this._yAxis.set(axis, axis.registerSeries(this));
        if (axis.chart instanceof XYChart) {
          axis.chart.handleYAxisSet(this);
        }
        this.dataItemsByAxis.setKey(axis.uid, new Dictionary());
        this.invalidateData();
      }
    };
    Object.defineProperty(XYSeries2.prototype, "baseAxis", {
      /**
       * @return Axis
       */
      get: function() {
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if (!this._baseAxis && xAxis && yAxis) {
          if (yAxis instanceof DateAxis) {
            this._baseAxis = yAxis;
          }
          if (xAxis instanceof DateAxis) {
            this._baseAxis = xAxis;
          }
          if (yAxis instanceof CategoryAxis) {
            this._baseAxis = yAxis;
          }
          if (xAxis instanceof CategoryAxis) {
            this._baseAxis = xAxis;
          }
          if (!this._baseAxis) {
            this._baseAxis = xAxis;
          }
        }
        return this._baseAxis;
      },
      /**
       * The main (base) axis.
       *
       * This is the axis that series fills will go to, or grow animations will
       * happen from.
       *
       * @param value  Axis
       */
      set: function(value) {
        if (this._baseAxis != value) {
          this._baseAxis = value;
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    XYSeries2.prototype.addData = function(rawDataItem, removeCount, skipRaw) {
      _super.prototype.addData.call(this, rawDataItem, removeCount, skipRaw);
      var scrollbarSeries = this.scrollbarSeries;
      if (scrollbarSeries) {
        this.scrollbarSeries.addData(rawDataItem, removeCount, true);
        this.scrollbarSeries._parseDataFrom = this._parseDataFrom;
      }
    };
    XYSeries2.prototype.setData = function(value) {
      _super.prototype.setData.call(this, value);
      if (this.scrollbarSeries) {
        this.scrollbarSeries.setData(value);
      }
    };
    XYSeries2.prototype.setDataSet = function(id) {
      var changed = _super.prototype.setDataSet.call(this, id);
      if (changed) {
        this._dataSetChanged = true;
        var dataItems = this.dataItems;
        this.resetExtremes();
        if (dataItems && dataItems.length > 0) {
          var xAxis = this.xAxis;
          var yAxis = this.yAxis;
          this._prevStartIndex = void 0;
          this._prevEndIndex = void 0;
          this._startIndex = void 0;
          this._endIndex = void 0;
          if (!this.appeared) {
            this.processValues(false);
          }
          if (xAxis instanceof DateAxis && xAxis == this.baseAxis) {
            this._tmin.setKey(xAxis.uid, dataItems.getIndex(0).dateX.getTime());
            this._tmax.setKey(xAxis.uid, dataItems.getIndex(dataItems.length - 1).dateX.getTime());
            this.dispatch("extremeschanged");
          }
          if (yAxis instanceof DateAxis && yAxis == this.baseAxis) {
            this._tmin.setKey(yAxis.uid, dataItems.getIndex(0).dateY.getTime());
            this._tmax.setKey(yAxis.uid, dataItems.getIndex(dataItems.length - 1).dateY.getTime());
            this.dispatch("extremeschanged");
          }
        }
      }
      return changed;
    };
    XYSeries2.prototype.processValues = function(working) {
      _super.prototype.processValues.call(this, working);
      var xAxis = this.xAxis;
      var yAxis = this.yAxis;
      if (!xAxis || !yAxis) {
        return;
      }
      var dataItems = this.dataItems;
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var startIndex = this.startIndex;
      var endIndex = this.endIndex;
      var workingStartIndex = startIndex;
      var workingEndIndex = endIndex;
      if (!working) {
        startIndex = 0;
        endIndex = this.dataItems.length;
      }
      for (var i = startIndex; i < endIndex; i++) {
        var dataItem = dataItems.getIndex(i);
        this.getStackValue(dataItem, working);
        var stackX = dataItem.getValue("valueX", "stack");
        var stackY = dataItem.getValue("valueY", "stack");
        if (!working) {
          stackX = dataItem.getValue("valueX", "stackTrue");
          stackY = dataItem.getValue("valueY", "stackTrue");
        }
        minX = min(dataItem.getMin(this._xValueFields, working, stackX), minX);
        minY = min(dataItem.getMin(this._yValueFields, working, stackY), minY);
        maxX = max(dataItem.getMax(this._xValueFields, working, stackX), maxX);
        maxY = max(dataItem.getMax(this._yValueFields, working, stackY), maxY);
        if (this.stacked) {
          if (this.baseAxis == xAxis) {
            if (stackY < minY) {
              minY = stackY;
            }
            if (stackY > maxY) {
              maxY = stackY;
            }
          }
          if (this.baseAxis == yAxis) {
            if (stackX < minX) {
              minX = stackX;
            }
            if (stackX > maxX) {
              maxX = stackX;
            }
          }
        }
      }
      xAxis.processSeriesDataItems();
      yAxis.processSeriesDataItems();
      var xAxisId = xAxis.uid;
      var yAxisId = yAxis.uid;
      if (this.xAxis instanceof ValueAxis && (minX == Infinity || maxX == -Infinity)) {
        this._smin.setKey(xAxisId, void 0);
        this._smax.setKey(xAxisId, void 0);
        this.dispatchImmediately("selectionextremeschanged");
        return;
      }
      if (this.yAxis instanceof ValueAxis && (minY == Infinity || maxY == -Infinity)) {
        this._smin.setKey(yAxisId, void 0);
        this._smax.setKey(yAxisId, void 0);
        this.dispatchImmediately("selectionextremeschanged");
        return;
      }
      if (!working) {
        if (this._tmin.getKey(xAxisId) != minX || this._tmax.getKey(xAxisId) != maxX || this._tmin.getKey(yAxisId) != minY || this._tmax.getKey(yAxisId) != maxY) {
          this._tmin.setKey(xAxisId, minX);
          this._tmax.setKey(xAxisId, maxX);
          this._tmin.setKey(yAxisId, minY);
          this._tmax.setKey(yAxisId, maxY);
          var stackedSeries = this.stackedSeries;
          if (stackedSeries) {
            if (stackedSeries.isDisposed()) {
              this.stackedSeries = void 0;
            } else {
              stackedSeries.processValues(false);
            }
          }
          this.dispatchImmediately("extremeschanged");
        }
      }
      if (startIndex != workingStartIndex || endIndex != workingEndIndex) {
        minX = Infinity;
        maxX = -Infinity;
        minY = Infinity;
        maxY = -Infinity;
        for (var i = workingStartIndex; i < workingEndIndex; i++) {
          var dataItem = dataItems.getIndex(i);
          this.getStackValue(dataItem, working);
          var stackX = dataItem.getValue("valueX", "stack");
          var stackY = dataItem.getValue("valueY", "stack");
          if (!working) {
            stackX = dataItem.getValue("valueX", "stackTrue");
            stackY = dataItem.getValue("valueY", "stackTrue");
          }
          minX = min(dataItem.getMin(this._xValueFields, working, stackX), minX);
          minY = min(dataItem.getMin(this._yValueFields, working, stackY), minY);
          maxX = max(dataItem.getMax(this._xValueFields, working, stackX), maxX);
          maxY = max(dataItem.getMax(this._yValueFields, working, stackY), maxY);
          if (this.stacked) {
            if (this.baseAxis == xAxis) {
              if (stackY < minY) {
                minY = stackY;
              }
              if (stackY > maxY) {
                maxY = stackY;
              }
            }
            if (this.baseAxis == yAxis) {
              if (stackX < minX) {
                minX = stackX;
              }
              if (stackX > maxX) {
                maxX = stackX;
              }
            }
          }
        }
      }
      if (this.xAxis instanceof ValueAxis && (minX == Infinity || maxX == -Infinity)) {
        this._smin.setKey(xAxisId, void 0);
        this._smax.setKey(xAxisId, void 0);
        this.dispatchImmediately("selectionextremeschanged");
        return;
      }
      if (this.yAxis instanceof ValueAxis && (minY == Infinity || maxY == -Infinity)) {
        this._smin.setKey(yAxisId, void 0);
        this._smax.setKey(yAxisId, void 0);
        this.dispatchImmediately("selectionextremeschanged");
        return;
      }
      if (this._smin.getKey(xAxisId) != minX || this._smax.getKey(xAxisId) != maxX || this._smin.getKey(yAxisId) != minY || this._smax.getKey(yAxisId) != maxY) {
        this._smin.setKey(xAxisId, minX);
        this._smax.setKey(xAxisId, maxX);
        this._smin.setKey(yAxisId, minY);
        this._smax.setKey(yAxisId, maxY);
        if (this.appeared || this.start != 0 || this.end != 1 || this.dataItems != this.mainDataSet) {
          var changed = false;
          if (yAxis instanceof ValueAxis && !(yAxis instanceof DateAxis)) {
            var tmin = this._tmin.getKey(yAxisId);
            if (!isNumber(tmin) || (this.usesShowFields || this._dataSetChanged || xAxis instanceof DateAxis && xAxis.groupData && this.isShowing) && minY < tmin || this.stackedSeries && !this.isHidden && !working) {
              this._tmin.setKey(yAxisId, minY);
              changed = true;
            }
            var tmax = this._tmax.getKey(yAxisId);
            if (!isNumber(tmax) || (this.usesShowFields || this._dataSetChanged || xAxis instanceof DateAxis && xAxis.groupData && this.isShowing) && maxY > tmax || this.stackedSeries && !this.isHidden && !working) {
              this._tmax.setKey(yAxisId, maxY);
              changed = true;
            }
          }
          if (xAxis instanceof ValueAxis && !(xAxis instanceof DateAxis)) {
            var tmin = this._tmin.getKey(xAxisId);
            if (!isNumber(tmin) || (this.usesShowFields || this._dataSetChanged || yAxis instanceof DateAxis && yAxis.groupData && this.isShowing) && minX < tmin || this.stackedSeries && !this.isHidden && !working) {
              this._tmin.setKey(xAxisId, minX);
              changed = true;
            }
            var tmax = this._tmax.getKey(xAxisId);
            if (!isNumber(tmax) || (this.usesShowFields || this._dataSetChanged || yAxis instanceof DateAxis && yAxis.groupData && this.isShowing) && maxX > tmax || this.stackedSeries && !this.isHidden && !working) {
              this._tmax.setKey(xAxisId, maxX);
              changed = true;
            }
          }
          if (changed) {
            this.dispatchImmediately("extremeschanged");
          }
          if (this.start == 0 && this.end == 1) {
            this._dataSetChanged = false;
          }
          this.dispatchImmediately("selectionextremeschanged");
        }
      }
      if (!working && this.stacked) {
        this.processValues(true);
      }
    };
    XYSeries2.prototype.hideTooltip = function(duration) {
      _super.prototype.hideTooltip.call(this, duration);
      this.returnBulletDefaultState();
      this._prevTooltipDataItem = void 0;
    };
    XYSeries2.prototype.showTooltipAtPosition = function(xPosition, yPosition) {
      var dataItem;
      if (this.visible && !this.isHiding && !this.isShowing) {
        var xAxis = this._xAxis.get();
        var yAxis = this._yAxis.get();
        if (xAxis == this.baseAxis) {
          dataItem = xAxis.getSeriesDataItem(this, xAxis.toAxisPosition(xPosition), this.snapTooltip);
        }
        if (yAxis == this.baseAxis) {
          dataItem = yAxis.getSeriesDataItem(this, yAxis.toAxisPosition(yPosition), this.snapTooltip);
        }
        var point = this.showTooltipAtDataItem(dataItem);
        if (point) {
          return point;
        }
        if (!this.tooltipText && !this.tooltipHTML) {
          return;
        }
      }
      this.hideTooltip();
    };
    XYSeries2.prototype.getAdjustedXLocation = function(dataItem, field, bulletLocationX) {
      return dataItem.locations[field];
    };
    XYSeries2.prototype.getAdjustedYLocation = function(dataItem, field, bulletLocationY) {
      return dataItem.locations[field];
    };
    XYSeries2.prototype.showTooltipAtDataItem = function(dataItem) {
      var e_1, _a;
      var cursor = this.chart.cursor;
      if (cursor && cursor.hideSeriesTooltipsOnSelection && cursor.selection.visible && cursor.downPoint) {
        this.hideTooltip();
        return;
      }
      this.returnBulletDefaultState(dataItem);
      if (dataItem && dataItem.visible) {
        this.updateLegendValue(dataItem);
        if (this.cursorTooltipEnabled) {
          this.tooltipDataItem = dataItem;
          var tooltipXField = this.tooltipXField;
          var tooltipYField = this.tooltipYField;
          if (hasValue(dataItem[tooltipXField]) && hasValue(dataItem[tooltipYField])) {
            var tooltipPoint = this.getPoint(dataItem, tooltipXField, tooltipYField, this.getAdjustedXLocation(dataItem, tooltipXField), this.getAdjustedYLocation(dataItem, tooltipYField));
            if (tooltipPoint) {
              if (this.chart.className == "XYChart" && (tooltipPoint.y < -1 || tooltipPoint.y > this.yAxis.pixelHeight + 1 || tooltipPoint.x < -1 || tooltipPoint.x > this.xAxis.pixelWidth + 1)) {
              } else {
                this.tooltipX = tooltipPoint.x;
                this.tooltipY = tooltipPoint.y;
                if (this._prevTooltipDataItem != dataItem) {
                  this.dispatchImmediately("tooltipshownat", {
                    type: "tooltipshownat",
                    target: this,
                    dataItem
                  });
                  this._prevTooltipDataItem = dataItem;
                }
                if (this.cursorHoverEnabled) {
                  try {
                    for (var _b = __values(dataItem.sprites), _c = _b.next(); !_c.done; _c = _b.next()) {
                      var sprite = _c.value;
                      if (!sprite.parent.visible || sprite.isHidden || sprite.__disabled || sprite.disabled || sprite.isHiding) {
                      } else {
                        if (!sprite.interactions.isRealHover) {
                          sprite.dispatchImmediately("over");
                          sprite.interactions.isRealHover = true;
                        }
                        sprite.isHover = true;
                      }
                    }
                  } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                  } finally {
                    try {
                      if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                  }
                }
                if (this.showTooltip()) {
                  return spritePointToSvg({ x: tooltipPoint.x, y: tooltipPoint.y }, this);
                }
                return;
              }
            }
          }
        }
      } else {
        this.updateLegendValue(dataItem, true);
      }
    };
    XYSeries2.prototype.returnBulletDefaultState = function(dataItem) {
      var e_2, _a;
      if (this._prevTooltipDataItem && this._prevTooltipDataItem != dataItem) {
        try {
          for (var _b = __values(this._prevTooltipDataItem.sprites), _c = _b.next(); !_c.done; _c = _b.next()) {
            var sprite = _c.value;
            if (!sprite.isDisposed()) {
              var fireEvent = sprite.interactions.isRealHover;
              sprite.isHover = false;
              if (fireEvent) {
                sprite.dispatchImmediately("out");
              }
            } else {
              this._prevTooltipDataItem = void 0;
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    };
    XYSeries2.prototype.shouldCreateBullet = function(dataItem, bulletTemplate) {
      var xField = bulletTemplate.xField;
      if (!hasValue(xField)) {
        xField = this.xField;
      }
      var yField = bulletTemplate.yField;
      if (!hasValue(yField)) {
        yField = this.yField;
      }
      if (this.xAxis instanceof ValueAxis && !dataItem.hasValue([xField]) || this.yAxis instanceof ValueAxis && !dataItem.hasValue([yField])) {
        return false;
      }
      if (bulletTemplate.disabled) {
        var disabledField = bulletTemplate.propertyFields.disabled;
        var dataContext = dataItem.dataContext;
        if (dataContext && dataContext[disabledField] === false) {
          return true;
        } else {
          return false;
        }
      }
      return true;
    };
    XYSeries2.prototype.updateTooltip = function() {
      if (!this.hideTooltipWhileZooming && this.tooltip && !this.tooltip.isHidden && !this.isHiding && !this.isHidden && this.tooltipDataItem) {
        this.showTooltipAtDataItem(this.tooltipDataItem);
      }
    };
    XYSeries2.prototype.positionBullet = function(bullet) {
      _super.prototype.positionBullet.call(this, bullet);
      var dataItem = bullet.dataItem;
      var xField = bullet.xField;
      if (!hasValue(xField)) {
        xField = this.xField;
      }
      var yField = bullet.yField;
      if (!hasValue(yField)) {
        yField = this.yField;
      }
      var xAxis = this.xAxis;
      var yAxis = this.yAxis;
      if (xAxis instanceof ValueAxis && !dataItem.hasValue([xField]) || yAxis instanceof ValueAxis && !dataItem.hasValue([yField])) {
        bullet.visible = false;
      } else {
        var bulletLocationX = this.getBulletLocationX(bullet, xField);
        var bulletLocationY = this.getBulletLocationY(bullet, yField);
        var point = this.getPoint(dataItem, xField, yField, bulletLocationX, bulletLocationY);
        if (point) {
          var xOpenField = this.xOpenField;
          var yOpenField = this.yOpenField;
          var positionX = void 0;
          var positionY = void 0;
          if (xAxis instanceof DateAxis) {
            if (!isNumber(bulletLocationX)) {
              bulletLocationX = 0;
            }
            var openValue = void 0;
            var closeValue = dataItem.getWorkingValue(xField);
            if (!xOpenField) {
              if (xAxis == this.baseAxis) {
                openValue = xAxis.baseValue;
              }
            } else {
              openValue = dataItem.getWorkingValue(xOpenField);
            }
            if (!isNumber(openValue)) {
              openValue = closeValue;
            }
            var stack = dataItem.getValue("valueX", "stack");
            openValue += stack;
            closeValue += stack;
            if (openValue == closeValue) {
              var baseInterval = xAxis.baseInterval;
              var dateFormatter = xAxis.dateFormatter;
              openValue = round2(new Date(openValue), baseInterval.timeUnit, baseInterval.count, dateFormatter.firstDayOfWeek, dateFormatter.utc, void 0, dateFormatter.timezoneMinutes, dateFormatter.timezone).getTime();
              closeValue = add(new Date(openValue), baseInterval.timeUnit, baseInterval.count, dateFormatter.utc).getTime();
            }
            var middleValue = void 0;
            if (xAxis == this.baseAxis) {
              middleValue = openValue + (closeValue - openValue) * bulletLocationX;
            } else {
              middleValue = openValue + (closeValue - openValue) * (1 - bulletLocationX);
            }
            positionX = xAxis.valueToPosition(middleValue);
          } else if (xAxis instanceof ValueAxis) {
            if (!isNumber(bulletLocationX)) {
              bulletLocationX = 0;
            }
            var openValue = void 0;
            var closeValue = dataItem.getWorkingValue(xField);
            if (!xOpenField) {
              openValue = xAxis.baseValue;
            } else {
              openValue = dataItem.getWorkingValue(xOpenField);
            }
            var stack = dataItem.getValue("valueX", "stack");
            openValue += stack;
            closeValue += stack;
            var middleValue = openValue + (closeValue - openValue) * (1 - bulletLocationX);
            positionX = xAxis.valueToPosition(middleValue);
          } else if (xAxis instanceof CategoryAxis) {
            var rightLocation = this.getAdjustedXLocation(dataItem, xField, bullet.locationX);
            var leftLocation = this.getAdjustedXLocation(dataItem, xOpenField, bullet.locationX);
            positionX = xAxis.categoryToPosition(dataItem[xField], rightLocation);
            var openPositionX = void 0;
            if (xOpenField) {
              openPositionX = xAxis.categoryToPosition(dataItem[xOpenField], leftLocation);
            }
            if (!isNumber(openPositionX)) {
              openPositionX = 1;
            }
            positionX = openPositionX + (positionX - openPositionX) * bulletLocationX;
          }
          if (yAxis instanceof DateAxis) {
            if (!isNumber(bulletLocationY)) {
              bulletLocationY = 0;
            }
            var openValue = void 0;
            var closeValue = dataItem.getWorkingValue(yField);
            if (!yOpenField) {
              if (yAxis == this.baseAxis) {
                openValue = yAxis.baseValue;
              }
            } else {
              openValue = dataItem.getWorkingValue(yOpenField);
            }
            if (!isNumber(openValue)) {
              openValue = closeValue;
            }
            var stack = dataItem.getValue("valueY", "stack");
            openValue += stack;
            closeValue += stack;
            if (openValue == closeValue) {
              var baseInterval = yAxis.baseInterval;
              var dateFormatter = yAxis.dateFormatter;
              openValue = round2(new Date(openValue), baseInterval.timeUnit, baseInterval.count, dateFormatter.firstDayOfWeek, dateFormatter.utc, void 0, dateFormatter.timezoneMinutes, dateFormatter.timezone).getTime();
              closeValue = add(new Date(openValue), baseInterval.timeUnit, baseInterval.count, dateFormatter.utc).getTime();
            }
            var middleValue = void 0;
            if (yAxis == this.baseAxis) {
              middleValue = openValue + (closeValue - openValue) * bulletLocationY;
            } else {
              middleValue = openValue + (closeValue - openValue) * (1 - bulletLocationY);
            }
            positionY = yAxis.valueToPosition(middleValue);
          } else if (yAxis instanceof ValueAxis) {
            if (!isNumber(bulletLocationY)) {
              bulletLocationY = 0;
            }
            var openValue = void 0;
            var closeValue = dataItem.getWorkingValue(yField);
            if (!yOpenField) {
              openValue = yAxis.baseValue;
            } else {
              openValue = dataItem.getWorkingValue(yOpenField);
            }
            var stack = dataItem.getValue("valueY", "stack");
            openValue += stack;
            closeValue += stack;
            var middleValue = openValue + (closeValue - openValue) * (1 - bulletLocationY);
            positionY = yAxis.valueToPosition(middleValue);
          } else if (yAxis instanceof CategoryAxis) {
            positionY = yAxis.categoryToPosition(dataItem[yField], bulletLocationY);
            var topLocation = this.getAdjustedYLocation(dataItem, yField, bullet.locationY);
            var bottomLocation = this.getAdjustedYLocation(dataItem, yOpenField, bullet.locationY);
            positionY = yAxis.categoryToPosition(dataItem[yField], topLocation);
            var openPositionY = void 0;
            if (yOpenField) {
              openPositionY = yAxis.categoryToPosition(dataItem[yOpenField], bottomLocation);
            }
            if (!isNumber(openPositionY)) {
              openPositionY = 1;
            }
            positionY = openPositionY + (positionY - openPositionY) * bulletLocationY;
          }
          bullet.visible = true;
          this.positionBulletReal(bullet, positionX, positionY);
        } else {
          bullet.visible = false;
        }
      }
    };
    XYSeries2.prototype.positionBulletReal = function(bullet, positionX, positionY) {
      bullet.x = this.xAxis.renderer.positionToPoint(positionX, positionY).x;
      bullet.y = this.yAxis.renderer.positionToPoint(positionY, positionX).y;
    };
    XYSeries2.prototype.getBulletLocationX = function(bullet, field) {
      var bulletLocation = bullet.locationX;
      var dataItem = bullet.dataItem;
      if (!isNumber(bulletLocation)) {
        bulletLocation = dataItem.workingLocations[field];
      }
      return bulletLocation;
    };
    XYSeries2.prototype.getBulletLocationY = function(bullet, field) {
      var bulletLocation = bullet.locationY;
      var dataItem = bullet.dataItem;
      if (!isNumber(bulletLocation)) {
        bulletLocation = dataItem.workingLocations[field];
      }
      return bulletLocation;
    };
    XYSeries2.prototype.updateStacking = function() {
      var _this = this;
      this.invalidateDataItems();
      if (this.chart) {
        this.chart.series.each(function(series) {
          if (series.baseAxis == _this.baseAxis) {
            series.stackedSeries = void 0;
            series.invalidateDataItems();
            series.invalidateProcessedData();
          }
        });
      }
    };
    Object.defineProperty(XYSeries2.prototype, "stacked", {
      /**
       * @return Can be stacked?
       */
      get: function() {
        return this.getPropertyValue("stacked");
      },
      /**
       * Can items from this series be included into stacks?
       *
       * Note: proper stacking is only possible if series have the same number
       * of data items. To ensure this, don't set data directly on series
       * but do this on chart instead.
       *
       * @default false
       * @param stacked  Can be stacked?
       */
      set: function(stacked) {
        if (this.setPropertyValue("stacked", stacked, true)) {
          this.updateStacking();
          var xAxis = this.xAxis;
          var yAxis = this.yAxis;
          if (!stacked) {
            var field_1;
            if (xAxis != this.baseAxis && xAxis instanceof ValueAxis) {
              field_1 = this.xField;
            }
            if (yAxis != this.baseAxis && yAxis instanceof ValueAxis) {
              field_1 = this.yField;
            }
            if (field_1) {
              this.dataItems.each(function(dataItem) {
                dataItem.setCalculatedValue(field_1, 0, "stack");
                dataItem.setCalculatedValue(field_1, 0, "stackTrue");
              });
            }
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeries2.prototype, "snapTooltip", {
      /**
       * @return Should snap?
       */
      get: function() {
        return this.getPropertyValue("snapTooltip");
      },
      /**
       * Should the nearest tooltip be shown if no data item is found on the
       * current cursor position? In order this to work, you should set snapTooltip = false on the series baseAxis.
       *
       * @default false
       * @param value  Should snap?
       */
      set: function(value) {
        this.setPropertyValue("snapTooltip", value);
      },
      enumerable: true,
      configurable: true
    });
    XYSeries2.prototype.show = function(duration) {
      var _this = this;
      if (this.isHidden) {
        if (this.appeared && this.xAxis instanceof DateAxis && this.xAxis.groupData) {
          this._tmin.setKey(this.yAxis.uid, void 0);
          this._tmax.setKey(this.yAxis.uid, void 0);
        }
        if (this.appeared && this.yAxis instanceof DateAxis && this.yAxis.groupData) {
          this._tmin.setKey(this.xAxis.uid, void 0);
          this._tmax.setKey(this.xAxis.uid, void 0);
        }
      }
      var fields;
      if (this.xAxis instanceof ValueAxis && this.xAxis != this.baseAxis) {
        fields = this._xValueFields;
      }
      if (this.yAxis instanceof ValueAxis && this.yAxis != this.baseAxis) {
        fields = this._yValueFields;
      }
      var startIndex = this.startIndex;
      var endIndex = this.endIndex;
      var delay = 0;
      var interpolationDuration = this.defaultState.transitionDuration;
      if (isNumber(duration)) {
        interpolationDuration = duration;
      }
      if (!options.animationsEnabled) {
        interpolationDuration = 0;
      }
      var anim;
      each3(indexed(this.dataItems.iterator()), function(a) {
        var i = a[0];
        var dataItem = a[1];
        var realDuration = interpolationDuration;
        if (i < _this.startIndex - 10 || i > _this.endIndex + 10) {
          realDuration = 0;
          delay = 0;
        }
        if (_this.sequencedInterpolation && realDuration > 0) {
          delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);
        }
        anim = dataItem.show(realDuration, delay, fields);
      });
      this.dataSets.each(function(key, dataSet) {
        if (dataSet != _this.dataItems) {
          dataSet.each(function(dataItem) {
            dataItem.events.disable();
            dataItem.show(0, 0, fields);
            dataItem.events.enable();
          });
        }
      });
      if (this.mainDataSet != this.dataItems) {
        this.mainDataSet.each(function(dataItem) {
          dataItem.events.disable();
          dataItem.show(0, 0, fields);
          dataItem.events.enable();
        });
      }
      var animation = _super.prototype.show.call(this, duration);
      if (anim && !anim.isFinished()) {
        animation = anim;
      }
      if (this.hidden) {
        this.dispatchImmediately("selectionextremeschanged");
        this.hidden = false;
      }
      return animation;
    };
    XYSeries2.prototype.hide = function(duration) {
      var _this = this;
      var fields;
      var value;
      var xAxis = this.xAxis;
      if (xAxis instanceof ValueAxis && xAxis != this.baseAxis) {
        fields = this._xValueFields;
        if (this.stacked || xAxis.minZoomed < xAxis.baseValue && xAxis.maxZoomed > xAxis.baseValue || this.stackedSeries) {
          value = xAxis.baseValue;
        } else {
          value = xAxis.min;
        }
      }
      var yAxis = this.yAxis;
      if (yAxis instanceof ValueAxis && yAxis != this.baseAxis) {
        fields = this._yValueFields;
        if (this.stacked || yAxis.minZoomed < yAxis.baseValue && yAxis.maxZoomed > yAxis.baseValue || this.stackedSeries) {
          value = yAxis.baseValue;
        } else {
          value = yAxis.min;
        }
      }
      var startIndex = this.startIndex;
      var endIndex = this.endIndex;
      var interpolationDuration = this.hiddenState.transitionDuration;
      if (isNumber(duration)) {
        interpolationDuration = duration;
      }
      if (!options.animationsEnabled) {
        interpolationDuration = 0;
      }
      var delay = 0;
      var anim;
      each3(indexed(this.dataItems.iterator()), function(a) {
        var i = a[0];
        var dataItem = a[1];
        var realDuration = interpolationDuration;
        if (i < _this.startIndex - 10 || i > _this.endIndex + 10) {
          realDuration = 0;
        }
        if (realDuration == 0) {
          dataItem.hide(0, 0, value, fields);
        } else {
          if (_this.sequencedInterpolation && realDuration > 0) {
            delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);
          }
          anim = dataItem.hide(realDuration, delay, value, fields);
        }
      });
      this.dataSets.each(function(key, dataSet) {
        if (dataSet != _this.dataItems) {
          dataSet.each(function(dataItem) {
            dataItem.events.disable();
            dataItem.hide(0, 0, value, fields);
            dataItem.events.enable();
          });
        }
      });
      if (this.mainDataSet != this.dataItems) {
        this.mainDataSet.each(function(dataItem) {
          dataItem.events.disable();
          dataItem.hide(0, 0, value, fields);
          dataItem.events.enable();
        });
      }
      var animation = _super.prototype.hide.call(this, interpolationDuration);
      if (animation && !animation.isFinished()) {
        animation.delay(delay);
      }
      if (anim && !anim.isFinished()) {
        animation = anim;
      }
      if (this.appeared) {
        this.dispatch("selectionextremeschanged");
      }
      this.validateDataElements();
      return animation;
    };
    XYSeries2.prototype.handleDataItemWorkingValueChange = function(dataItem, name) {
      _super.prototype.handleDataItemWorkingValueChange.call(this, dataItem, name);
      var axisSeries = this.baseAxis.series;
      each3(axisSeries.iterator(), function(series) {
        if (series.stacked || series.stackedSeries) {
          series.invalidateProcessedData();
        }
      });
    };
    XYSeries2.prototype.getStackValue = function(dataItem, working) {
      var _this = this;
      var xAxis = this.xAxis;
      var yAxis = this.yAxis;
      if (!this.stacked || !xAxis || !yAxis) {
        return;
      } else {
        var chart = this.chart;
        var index = chart.series.indexOf(this);
        var field_2;
        if (xAxis != this.baseAxis && xAxis instanceof ValueAxis) {
          field_2 = this.xField;
        }
        if (yAxis != this.baseAxis && yAxis instanceof ValueAxis) {
          field_2 = this.yField;
        }
        if (!field_2) {
          return;
        }
        dataItem.setCalculatedValue(field_2, 0, "stack");
        dataItem.setCalculatedValue(field_2, 0, "stackTrue");
        eachContinue2(chart.series.range(0, index).backwards().iterator(), function(prevSeries) {
          if (prevSeries.xAxis == xAxis && prevSeries.yAxis == yAxis && prevSeries.className == _this.className) {
            prevSeries.stackedSeries = _this;
            var prevDataItem = prevSeries.dataItems.getIndex(dataItem.index);
            if (prevDataItem && prevDataItem.hasValue(_this._xValueFields) && prevDataItem.hasValue(_this._yValueFields)) {
              var value = dataItem.getValue(field_2);
              var prevValue = void 0;
              var prevStack = prevDataItem.getValue(field_2, "stackTrue");
              if (prevStack == null) {
                prevStack = 0;
              }
              var prevRealValue = prevDataItem.getValue(field_2) + prevStack;
              prevValue = prevDataItem.getWorkingValue(field_2) + prevDataItem.getValue(field_2, "stack");
              if (_this.stackToNegative) {
                if (value >= 0 && prevRealValue >= 0 || value < 0 && prevRealValue < 0) {
                  dataItem.setCalculatedValue(field_2, prevValue, "stack");
                  dataItem.setCalculatedValue(field_2, prevRealValue, "stackTrue");
                  return false;
                } else if (!prevSeries.stacked) {
                  return false;
                }
              } else {
                dataItem.setCalculatedValue(field_2, prevValue, "stack");
                dataItem.setCalculatedValue(field_2, prevRealValue, "stackTrue");
                return false;
              }
            } else if (!prevSeries.stacked) {
              return false;
            }
          }
          return true;
        });
      }
    };
    Object.defineProperty(XYSeries2.prototype, "stackToNegative", {
      /**
       * @return Stack to base line
       */
      get: function() {
        return this.getPropertyValue("stackToNegative");
      },
      /**
       * This setting indicates how negative values are treated in stacked stacked
       * series.
       *
       * If set to `true` (default), negative values will stack on the base line.
       *
       * If set to `false`, negative value will stack in relation to the previous
       * value in the stack.
       *
       * @since 4.9.34
       * @param  value  Stack to base line
       */
      set: function(value) {
        this.setPropertyValue("stackToNegative", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeries2.prototype, "xField", {
      /**
       * [xField description]
       *
       * @ignore Exclude from docs
       * @todo Description
       * @return [description]
       */
      get: function() {
        return this._xField;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeries2.prototype, "yField", {
      /**
       * [yField description]
       *
       * @ignore Exclude from docs
       * @todo Description
       * @return [description]
       */
      get: function() {
        return this._yField;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeries2.prototype, "xOpenField", {
      /**
       * [xOpenField description]
       *
       * @ignore Exclude from docs
       * @todo Description
       * @return [description]
       */
      get: function() {
        return this._xOpenField;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeries2.prototype, "yOpenField", {
      /**
       * [yOpenField description]
       *
       * @ignore Exclude from docs
       * @todo Description
       * @return [description]
       */
      get: function() {
        return this._yOpenField;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeries2.prototype, "tooltipXField", {
      /**
       * @ignore Exclude from docs
       * @todo Description
       * @return [description]
       */
      get: function() {
        if (this._tooltipXField) {
          return this._tooltipXField;
        }
        return this._xField;
      },
      /**
       * [tooltipXField description]
       *
       * @ignore Exclude from docs
       * @todo Description
       * @param value [description]
       */
      set: function(value) {
        this._tooltipXField = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeries2.prototype, "tooltipYField", {
      /**
       * @ignore Exclude from docs
       * @todo Description
       * @return [description]
       */
      get: function() {
        if (this._tooltipYField) {
          return this._tooltipYField;
        }
        return this._yField;
      },
      /**
       * [tooltipYField description]
       *
       * @ignore Exclude from docs
       * @todo Description
       * @param value [description]
       */
      set: function(value) {
        this._tooltipYField = value;
      },
      enumerable: true,
      configurable: true
    });
    XYSeries2.prototype.min = function(axis) {
      return this._tmin.getKey(axis.uid);
    };
    XYSeries2.prototype.max = function(axis) {
      return this._tmax.getKey(axis.uid);
    };
    XYSeries2.prototype.selectionMin = function(axis) {
      var value = this._smin.getKey(axis.uid);
      return value;
    };
    XYSeries2.prototype.selectionMax = function(axis) {
      var value = this._smax.getKey(axis.uid);
      return value;
    };
    XYSeries2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config.baseAxis) && isString(config.baseAxis)) {
          if (this.map.hasKey(config.baseAxis)) {
            config.baseAxis = this.map.getKey(config.baseAxis);
          } else {
            this.processingErrors.push("[XYSeries (" + (this.name || "unnamed") + ')] No axis with id "' + config.baseAxis + '" found for `baseAxis`.');
            delete config.baseAxis;
          }
        }
        if (hasValue(config.xAxis) && isString(config.xAxis)) {
          if (this.map.hasKey(config.xAxis)) {
            config.xAxis = this.map.getKey(config.xAxis);
          } else {
            this.processingErrors.push("[XYSeries (" + (this.name || "unnamed") + ')] No axis with id "' + config.xAxis + '" found for `xAxis`.');
            delete config.xAxis;
          }
        }
        if (hasValue(config.yAxis) && isString(config.yAxis)) {
          if (this.map.hasKey(config.yAxis)) {
            config.yAxis = this.map.getKey(config.yAxis);
          } else {
            this.processingErrors.push("[XYSeries (" + (this.name || "unnamed") + ')] No axis with id "' + config.yAxis + '" found for `yAxis`.');
            delete config.yAxis;
          }
        }
        if (hasValue(config.axisRanges) && isArray(config.axisRanges)) {
          for (var i = 0, len = config.axisRanges.length; i < len; i++) {
            var range = config.axisRanges[i];
            if (!hasValue(range.type)) {
              range.type = "AxisDataItem";
            }
            if (hasValue(range.axis) && isString(range.axis) && this.map.hasKey(range.axis)) {
              range.component = this.map.getKey(range.axis);
            } else if (hasValue(range.component) && isString(range.component) && this.map.hasKey(range.component)) {
              range.component = this.map.getKey(range.component);
            }
          }
        }
        if (!hasValue(config.dataFields) || !isObject(config.dataFields)) {
          this.processingErrors.push("`dataFields` is not set for series [" + (this.name || "unnamed") + "]");
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    XYSeries2.prototype.getPoint = function(dataItem, xKey, yKey, locationX, locationY, stackKeyX, stackKeyY) {
      if (this.xAxis && this.yAxis) {
        var x = this.xAxis.getX(dataItem, xKey, locationX);
        var y = this.yAxis.getY(dataItem, yKey, locationY);
        x = fitToRange(x, -this._maxxX, this._maxxX);
        y = fitToRange(y, -this._maxxY, this._maxxY);
        return { x, y };
      }
    };
    XYSeries2.prototype.updateItemReaderText = function() {
      if (this._itemReaderTextChanged) {
        return;
      }
      var text = "";
      each2(this.dataFields, function(key, val) {
        text += "{" + key + "} ";
      });
      this.itemReaderText = text;
      this._itemReaderTextChanged = false;
    };
    Object.defineProperty(XYSeries2.prototype, "cursorTooltipEnabled", {
      /**
       * @return Display tooltip?
       */
      get: function() {
        return this.getPropertyValue("cursorTooltipEnabled");
      },
      /**
       * Indicates if series should display a tooltip for chart's cursor.
       *
       * If set to `true` (default), the tooltips set for all series item's
       * elements like columns and bullets will be automatically shown
       * when [[XYCursor]] passes over category/date, even if its not hovered
       * directly over the item.
       *
       * Set this to `false` to disable such behavior and display item-specific
       * tooltips only when hovered directly over them
       *
       * @default true
       * @param value Display tooltip?
       */
      set: function(value) {
        this.setPropertyValue("cursorTooltipEnabled", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeries2.prototype, "cursorHoverEnabled", {
      /**
       * @return Hover enabled?
       */
      get: function() {
        return this.getPropertyValue("cursorHoverEnabled");
      },
      /**
       * Indicates if series should apply hover state on bullets/columns/etc when
       * cursor is over the data item.
       *
       * If set to `true` (default) and chart cursor is enabled on th chart,
       * hovering over date/category will trigger hover states on related Series
       * items like bullets and columns.
       *
       * @default true
       * @since 4.2.2
       * @param  value  Hover enabled?
       */
      set: function(value) {
        this.setPropertyValue("cursorHoverEnabled", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeries2.prototype, "excludeFromTotal", {
      /**
       * @return Exclude from totals?
       */
      get: function() {
        return this.getPropertyValue("excludeFromTotal");
      },
      /**
       * Indicates if series' values should be excluded when calculating totals.
       *
       * @default false
       * @since 4.4.9
       * @param  value  Exclude from totals?
       */
      set: function(value) {
        this.setPropertyValue("excludeFromTotal", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeries2.prototype, "hideTooltipWhileZooming", {
      /**
       * @return Hide tooltip while zooming?
       */
      get: function() {
        return this.getPropertyValue("hideTooltipWhileZooming");
      },
      /**
       * Indicates if series' tooltip should be hidden while series axis range is
       * animating (zooming).
       *
       * @default true
       * @since 4.7.16
       * @param  value  Hide tooltip while zooming?
       */
      set: function(value) {
        this.setPropertyValue("hideTooltipWhileZooming", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYSeries2.prototype, "maskBullets", {
      /**
       * @return Mask bullets?
       */
      get: function() {
        return this.getPropertyValue("maskBullets");
      },
      /**
       * Indicates if series' bullets should be masked.
       *
       * @default true
       * @since 4.7.17
       * @param  value  Mask bullets?
       */
      set: function(value) {
        this.setPropertyValue("maskBullets", value);
        var chart = this.chart;
        if (chart) {
          if (value) {
            this.bulletsContainer.parent = chart.bulletsContainer;
          } else {
            this.bulletsContainer.parent = chart.axisBulletsContainer;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    XYSeries2.prototype.copyFrom = function(source) {
      this.groupFields = copyProperties2(source.groupFields, {});
      _super.prototype.copyFrom.call(this, source);
    };
    XYSeries2.prototype.dispose = function() {
      if (this.scrollbarSeries) {
        this.scrollbarSeries.dispose();
      }
      _super.prototype.dispose.call(this);
    };
    return XYSeries2;
  }(Series)
);
registry.registeredClasses["XYSeries"] = XYSeries;
registry.registeredClasses["XYSeriesDataItem"] = XYSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/XYChartScrollbar.js
var XYChartScrollbar = (
  /** @class */
  function(_super) {
    __extends(XYChartScrollbar2, _super);
    function XYChartScrollbar2() {
      var _this = _super.call(this) || this;
      _this._chart = new MutableValueDisposer();
      _this.className = "XYChartScrollbar";
      var interfaceColors = new InterfaceColorSet();
      _this.padding(0, 0, 0, 0);
      var scrollbarChart = _this.createChild(XYChart);
      scrollbarChart.shouldClone = false;
      scrollbarChart.margin(0, 0, 0, 0);
      scrollbarChart.padding(0, 0, 0, 0);
      scrollbarChart.interactionsEnabled = false;
      _this._scrollbarChart = scrollbarChart;
      if (!isIE()) {
        var filter = new DesaturateFilter();
        filter.filterUnits = "userSpaceOnUse";
        scrollbarChart.plotContainer.filters.push(filter);
      }
      _this._disposers.push(_this._scrollbarChart);
      _this.minHeight = 60;
      _this.minWidth = 60;
      var unselectedOverlay = _this.createChild(Sprite);
      unselectedOverlay.shouldClone = false;
      unselectedOverlay.setElement(_this.paper.add("path"));
      unselectedOverlay.fill = interfaceColors.getFor("background");
      unselectedOverlay.fillOpacity = 0.8;
      unselectedOverlay.interactionsEnabled = false;
      unselectedOverlay.isMeasured = false;
      unselectedOverlay.toBack();
      _this._unselectedOverlay = unselectedOverlay;
      _this._disposers.push(_this._unselectedOverlay);
      scrollbarChart.toBack();
      _this.background.cornerRadius(0, 0, 0, 0);
      var thumbBackground = _this.thumb.background;
      thumbBackground.cornerRadius(0, 0, 0, 0);
      thumbBackground.fillOpacity = 0;
      thumbBackground.fill = interfaceColors.getFor("background");
      var hoverState = thumbBackground.states.getKey("hover");
      if (hoverState) {
        hoverState.properties.fillOpacity = 0.2;
      }
      var downState = thumbBackground.states.getKey("down");
      if (downState) {
        downState.properties.fillOpacity = 0.4;
      }
      _this._disposers.push(_this._chart);
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(XYChartScrollbar2.prototype, "series", {
      /**
       * A list of series that are used to draw graph(s) on the scrollbar.
       *
       * @readonly
       * @return Series
       */
      get: function() {
        if (!this._series) {
          this._series = new List();
          this._disposers.push(this._series.events.on("inserted", this.handleSeriesAdded, this, false));
          this._disposers.push(this._series.events.on("removed", this.handleSeriesRemoved, this, false));
        }
        return this._series;
      },
      enumerable: true,
      configurable: true
    });
    XYChartScrollbar2.prototype.handleSeriesAdded = function(event) {
      var _this = this;
      var sourceSeries = event.newValue;
      if (!sourceSeries.xAxis || !sourceSeries.yAxis) {
        return;
      }
      var scrollbarChart = this.scrollbarChart;
      scrollbarChart.zoomOutButton.disabled = true;
      this.chart = sourceSeries.chart;
      scrollbarChart.dateFormatter.inputDateFormat = this.chart.dateFormatter.inputDateFormat;
      scrollbarChart.language.locale = this.chart.language.locale;
      var addXAxis = true;
      var addYAxis = true;
      each3(this.series.iterator(), function(series2) {
        if (series2 != sourceSeries) {
          if (series2.xAxis == sourceSeries.xAxis && _this.scrollbarChart.xAxes.length > 0) {
            addXAxis = false;
          }
          if (series2.yAxis == sourceSeries.yAxis && _this.scrollbarChart.yAxes.length > 0) {
            addYAxis = false;
          }
        }
      });
      sourceSeries.events.on("beforedisposed", function() {
        _this.series.removeValue(sourceSeries);
      });
      var interfaceColors = new InterfaceColorSet();
      var series = sourceSeries.clone();
      if (options.onlyShowOnViewport || options.queue) {
        this.addDisposer(this.chart.events.on("removedfromqueue", function() {
          scrollbarChart.invalidateData();
        }));
      }
      if (isIE()) {
        series.stroke = color("#aaaaaa");
        series.fill = series.stroke;
        series.propertyFields.fill = void 0;
        series.propertyFields.stroke = void 0;
      }
      sourceSeries.scrollbarSeries = series;
      if (addXAxis) {
        var xAxis = sourceSeries.xAxis.clone();
        scrollbarChart.xAxes.moveValue(xAxis);
        xAxis.title.disabled = true;
        xAxis.rangeChangeDuration = 0;
        var renderer = xAxis.renderer;
        renderer.ticks.template.disabled = true;
        renderer.inside = true;
        renderer.labels.template.inside = true;
        renderer.line.strokeOpacity = 0;
        renderer.minLabelPosition = 0.02;
        renderer.maxLabelPosition = 0.98;
        renderer.line.disabled = true;
        renderer.axisFills.template.disabled = true;
        renderer.baseGrid.disabled = true;
        renderer.grid.template.strokeOpacity = 0.05;
        renderer.minWidth = void 0;
        renderer.minHeight = void 0;
        renderer.padding(0, 0, 0, 0);
        renderer.chart = scrollbarChart;
        renderer.margin(0, 0, 0, 0);
        xAxis.width = percent(100);
        var labelsTemplate = renderer.labels.template;
        labelsTemplate.fillOpacity = 0.5;
        xAxis.maxZoomCount = void 0;
        xAxis.minZoomCount = void 0;
        if (xAxis instanceof DateAxis) {
          var vAxis_1 = xAxis;
          var sourceAxis = sourceSeries.xAxis;
          vAxis_1.groupCount = sourceAxis.groupCount * 5;
          vAxis_1.min = void 0;
          vAxis_1.max = void 0;
          this._disposers.push(vAxis_1.clonedFrom.events.on("extremeschanged", function() {
            if (isNumber(vAxis_1.clonedFrom.minDefined)) {
              vAxis_1.min = vAxis_1.clonedFrom.minDefined;
            }
            if (isNumber(vAxis_1.clonedFrom.maxDefined)) {
              vAxis_1.max = vAxis_1.clonedFrom.maxDefined;
            }
          }, void 0, false));
        } else if (xAxis instanceof ValueAxis) {
          var vAxis_2 = xAxis;
          vAxis_2.min = void 0;
          vAxis_2.max = void 0;
          if (!isNumber(vAxis_2.clonedFrom.minDefined)) {
            vAxis_2.min = void 0;
          }
          if (!isNumber(vAxis_2.clonedFrom.maxDefined)) {
            vAxis_2.max = void 0;
          }
          this._disposers.push(vAxis_2.clonedFrom.events.on("extremeschanged", function() {
            if (isNumber(vAxis_2.clonedFrom.minDefined)) {
              vAxis_2.min = vAxis_2.clonedFrom.min;
            }
            if (isNumber(vAxis_2.clonedFrom.maxDefined)) {
              vAxis_2.max = vAxis_2.clonedFrom.max;
            }
          }, void 0, false));
        }
        series.xAxis = xAxis;
      } else {
        this.scrollbarChart.xAxes.each(function(xAxis2) {
          if (xAxis2.clonedFrom == sourceSeries.xAxis) {
            series.xAxis = xAxis2;
          }
        });
      }
      if (addYAxis) {
        var yAxis = sourceSeries.yAxis.clone();
        scrollbarChart.yAxes.moveValue(yAxis);
        yAxis.title.disabled = true;
        yAxis.rangeChangeDuration = 0;
        var renderer = yAxis.renderer;
        renderer.ticks.template.disabled = true;
        renderer.inside = true;
        renderer.labels.template.inside = true;
        renderer.line.strokeOpacity = 0;
        renderer.minLabelPosition = 0.02;
        renderer.maxLabelPosition = 0.98;
        renderer.line.disabled = true;
        renderer.axisFills.template.disabled = true;
        renderer.grid.template.stroke = interfaceColors.getFor("background");
        renderer.baseGrid.disabled = true;
        renderer.grid.template.strokeOpacity = 0.05;
        renderer.minWidth = void 0;
        renderer.minHeight = void 0;
        renderer.chart = scrollbarChart;
        renderer.padding(0, 0, 0, 0);
        renderer.margin(0, 0, 0, 0);
        yAxis.height = percent(100);
        var labelsTemplate = renderer.labels.template;
        labelsTemplate.fillOpacity = 0.5;
        series.yAxis = yAxis;
        yAxis.maxZoomCount = void 0;
        yAxis.minZoomCount = void 0;
        if (yAxis instanceof DateAxis) {
          var vAxis_3 = yAxis;
          vAxis_3.min = void 0;
          vAxis_3.max = void 0;
          var sourceAxis = sourceSeries.yAxis;
          yAxis.groupCount = sourceAxis.groupCount * 5;
          this._disposers.push(vAxis_3.clonedFrom.events.on("extremeschanged", function() {
            if (isNumber(vAxis_3.clonedFrom.minDefined)) {
              vAxis_3.min = vAxis_3.clonedFrom.minDefined;
            }
            if (isNumber(vAxis_3.clonedFrom.maxDefined)) {
              vAxis_3.max = vAxis_3.clonedFrom.maxDefined;
            }
          }));
        } else if (yAxis instanceof ValueAxis) {
          var vAxis_4 = yAxis;
          vAxis_4.min = void 0;
          vAxis_4.max = void 0;
          if (!isNumber(vAxis_4.clonedFrom.minDefined)) {
            vAxis_4.min = void 0;
          }
          if (!isNumber(vAxis_4.clonedFrom.maxDefined)) {
            vAxis_4.max = void 0;
          }
          this._disposers.push(vAxis_4.clonedFrom.events.on("extremeschanged", function() {
            if (isNumber(vAxis_4.clonedFrom.minDefined)) {
              vAxis_4.min = vAxis_4.clonedFrom.minDefined;
            }
            if (isNumber(vAxis_4.clonedFrom.maxDefined)) {
              vAxis_4.max = vAxis_4.clonedFrom.maxDefined;
            }
          }));
        }
      } else {
        this.scrollbarChart.yAxes.each(function(yAxis2) {
          if (yAxis2.clonedFrom == sourceSeries.yAxis) {
            series.yAxis = yAxis2;
          }
        });
      }
      series.rangeChangeDuration = 0;
      series.interpolationDuration = 0;
      series.defaultState.transitionDuration = 0;
      series.showOnInit = false;
      this._disposers.push(series.events.on("validated", this.zoomOutAxes, this, false));
      this._disposers.push(sourceSeries.events.on("datavalidated", function() {
        if (series.data != sourceSeries.data) {
          series.data = sourceSeries.data;
        }
      }, void 0, false));
      series.defaultState.properties.visible = true;
      scrollbarChart.series.push(series);
      this.updateByOrientation();
    };
    XYChartScrollbar2.prototype.updateByOrientation = function() {
      var _this = this;
      if (this._scrollbarChart) {
        each3(this._scrollbarChart.xAxes.iterator(), function(xAxis) {
          var renderer = xAxis.renderer;
          if (_this.orientation == "vertical") {
            renderer.grid.template.disabled = true;
            renderer.labels.template.disabled = true;
            renderer.minGridDistance = 10;
          } else {
            renderer.grid.template.disabled = false;
            renderer.labels.template.disabled = false;
            renderer.minGridDistance = xAxis.clonedFrom.renderer.minGridDistance;
          }
        });
        each3(this._scrollbarChart.yAxes.iterator(), function(yAxis) {
          var renderer = yAxis.renderer;
          if (_this.orientation == "horizontal") {
            renderer.grid.template.disabled = true;
            renderer.labels.template.disabled = true;
            renderer.minGridDistance = 10;
          } else {
            renderer.grid.template.disabled = false;
            renderer.labels.template.disabled = false;
            renderer.minGridDistance = yAxis.clonedFrom.renderer.minGridDistance;
          }
        });
      }
    };
    XYChartScrollbar2.prototype.handleSeriesRemoved = function(event) {
      var sourceSeries = event.oldValue;
      var scrollbarChart = this.scrollbarChart;
      scrollbarChart.series.each(function(series) {
        if (series && series.clonedFrom == sourceSeries) {
          scrollbarChart.series.removeValue(series);
        }
      });
      if (scrollbarChart.series.length == 0) {
        scrollbarChart.xAxes.clear();
        scrollbarChart.yAxes.clear();
      }
      try {
        sourceSeries.events.off("validated", this.zoomOutAxes, this);
      } catch (err) {
      }
    };
    Object.defineProperty(XYChartScrollbar2.prototype, "scrollbarChart", {
      /**
       * A chart element that is used to display graphs in the Scrollbar.
       *
       * This is not the same as `chart`. It's a totally independent instance of
       * [[XYChart]] with separate config, series, etc.
       *
       * It can be configured just like any other [[XYChart]].
       *
       * @readonly
       * @return Scrollbar's internal chart
       */
      get: function() {
        return this._scrollbarChart;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYChartScrollbar2.prototype, "chart", {
      /**
       * @return Chart
       */
      get: function() {
        return this._chart.get();
      },
      /**
       * A chart that Scrollbar belongs to.
       *
       * @param chart  Chart
       */
      set: function(chart) {
        if (this._chart.get() !== chart) {
          this._chart.set(chart, chart.events.on("datavalidated", this.handleDataChanged, this, false));
          this.handleDataChanged();
          this._scrollbarChart.dataProvider = chart;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYChartScrollbar2.prototype, "unselectedOverlay", {
      /**
       * A [[Sprite]] object representing overlay that is used to dim area of the
       * scrollbar that is currently not selected.
       *
       * Use its `fillOpacity` to set opacity of the fill, with `0` (zero)
       * completely disabling the dimming, and `1` making unselected area completely
       * blank.
       *
       * @since 4.6.1
       * @readonly
       * @return Unselected area curtain element
       */
      get: function() {
        return this._unselectedOverlay;
      },
      enumerable: true,
      configurable: true
    });
    XYChartScrollbar2.prototype.handleDataChanged = function() {
      if (this.chart.data != this.scrollbarChart.data) {
        this.scrollbarChart.data = this.chart.data;
      } else {
        this.scrollbarChart.invalidateRawData();
      }
    };
    XYChartScrollbar2.prototype.zoomOutAxes = function() {
      var scrollbarChart = this.scrollbarChart;
      each3(scrollbarChart.xAxes.iterator(), function(x) {
        x.zoom({ start: 0, end: 1 }, true, true);
      });
      each3(scrollbarChart.yAxes.iterator(), function(y) {
        y.zoom({ start: 0, end: 1 }, true, true);
      });
    };
    XYChartScrollbar2.prototype.updateThumb = function(dispatchEvents) {
      if (dispatchEvents === void 0) {
        dispatchEvents = true;
      }
      _super.prototype.updateThumb.call(this, dispatchEvents);
      if (this._unselectedOverlay) {
        var thumb = this.thumb;
        var x = thumb.pixelX || 0;
        var y = thumb.pixelY || 0;
        var w = thumb.pixelWidth || 0;
        var h = thumb.pixelHeight || 0;
        var path = "";
        if (this.orientation == "horizontal") {
          path = rectToPath({
            x: -1,
            y: 0,
            width: x,
            height: h
          });
          path += rectToPath({
            x: x + w,
            y: 0,
            width: (this.pixelWidth || 0) - x - w,
            height: h
          });
        } else {
          path = rectToPath({
            x: 0,
            y: 0,
            width: w,
            height: y
          });
          path += rectToPath({
            x: 0,
            y: y + h,
            width: w,
            height: (this.pixelHeight || 0) - y - h
          });
        }
        this._unselectedOverlay.path = path;
      }
    };
    XYChartScrollbar2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config.series) && isArray(config.series)) {
          for (var i = 0, len = config.series.length; i < len; i++) {
            var series = config.series[i];
            if (hasValue(series) && isString(series)) {
              if (this.map.hasKey(series)) {
                config.series[i] = this.map.getKey(series);
              } else {
                throw Error("XYChartScrollbar error: Series with id `" + series + "` does not exist.");
              }
            }
          }
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    return XYChartScrollbar2;
  }(Scrollbar)
);
registry.registeredClasses["XYChartScrollbar"] = XYChartScrollbar;

// node_modules/@amcharts/amcharts4/.internal/charts/types/XYChart.js
var XYChartDataItem = (
  /** @class */
  function(_super) {
    __extends(XYChartDataItem2, _super);
    function XYChartDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "XYChartDataItem";
      _this.applyTheme();
      return _this;
    }
    return XYChartDataItem2;
  }(SerialChartDataItem)
);
var XYChart = (
  /** @class */
  function(_super) {
    __extends(XYChart2, _super);
    function XYChart2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._axisRendererX = AxisRendererX;
      _this._axisRendererY = AxisRendererY;
      _this._seriesPoints = [];
      _this.className = "XYChart";
      _this.maskBullets = true;
      _this.arrangeTooltips = true;
      var chartContainer = _this.chartContainer;
      chartContainer.layout = "vertical";
      _this.padding(15, 15, 15, 15);
      var topAxesCont = chartContainer.createChild(Container);
      topAxesCont.shouldClone = false;
      topAxesCont.layout = "vertical";
      topAxesCont.width = percent(100);
      topAxesCont.zIndex = 1;
      _this.topAxesContainer = topAxesCont;
      var yAxesAndPlotCont = chartContainer.createChild(Container);
      yAxesAndPlotCont.shouldClone = false;
      yAxesAndPlotCont.layout = "horizontal";
      yAxesAndPlotCont.width = percent(100);
      yAxesAndPlotCont.height = percent(100);
      yAxesAndPlotCont.zIndex = 0;
      _this.yAxesAndPlotContainer = yAxesAndPlotCont;
      var bottomAxesCont = chartContainer.createChild(Container);
      bottomAxesCont.shouldClone = false;
      bottomAxesCont.width = percent(100);
      bottomAxesCont.layout = "vertical";
      bottomAxesCont.zIndex = 1;
      _this.bottomAxesContainer = bottomAxesCont;
      var leftAxesCont = yAxesAndPlotCont.createChild(Container);
      leftAxesCont.shouldClone = false;
      leftAxesCont.layout = "horizontal";
      leftAxesCont.height = percent(100);
      leftAxesCont.contentAlign = "right";
      leftAxesCont.events.on("transformed", _this.updateXAxesMargins, _this, false);
      leftAxesCont.zIndex = 1;
      _this.leftAxesContainer = leftAxesCont;
      var plotCont = yAxesAndPlotCont.createChild(Container);
      plotCont.shouldClone = false;
      plotCont.height = percent(100);
      plotCont.width = percent(100);
      plotCont.background.fillOpacity = 0;
      _this.plotContainer = plotCont;
      _this.mouseWheelBehavior = "none";
      _this._cursorContainer = plotCont;
      var rightAxesCont = yAxesAndPlotCont.createChild(Container);
      rightAxesCont.shouldClone = false;
      rightAxesCont.layout = "horizontal";
      rightAxesCont.height = percent(100);
      rightAxesCont.zIndex = 1;
      rightAxesCont.events.on("transformed", _this.updateXAxesMargins, _this, false);
      _this.rightAxesContainer = rightAxesCont;
      _this.seriesContainer.parent = plotCont;
      _this.bulletsContainer.parent = plotCont;
      var zoomOutButton = plotCont.createChild(ZoomOutButton);
      zoomOutButton.shouldClone = false;
      zoomOutButton.align = "right";
      zoomOutButton.valign = "top";
      zoomOutButton.zIndex = Number.MAX_SAFE_INTEGER;
      zoomOutButton.marginTop = 5;
      zoomOutButton.marginRight = 5;
      zoomOutButton.hide(0);
      _this.zoomOutButton = zoomOutButton;
      var axisBulletsContainer = _this.plotContainer.createChild(Container);
      axisBulletsContainer.shouldClone = false;
      axisBulletsContainer.width = percent(100);
      axisBulletsContainer.height = percent(100);
      axisBulletsContainer.isMeasured = false;
      axisBulletsContainer.zIndex = 4;
      axisBulletsContainer.layout = "none";
      _this.axisBulletsContainer = axisBulletsContainer;
      _this._bulletMask = _this.plotContainer;
      _this.events.on("beforedatavalidated", function() {
        _this.series.each(function(series) {
          series.dataGrouped = false;
          series._baseInterval = {};
        });
      }, _this, false);
      _this.applyTheme();
      return _this;
    }
    XYChart2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      this.zoomOutButton.exportable = false;
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("X/Y chart");
      }
    };
    XYChart2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      this.seriesContainer.toFront();
      this.bulletsContainer.toFront();
      if (this.maskBullets) {
        this.bulletsContainer.mask = this._bulletMask;
      }
      this.updateSeriesLegend();
    };
    XYChart2.prototype.updatePlotElements = function() {
      each3(this.series.iterator(), function(series) {
        series.invalidate();
      });
    };
    XYChart2.prototype.validateData = function() {
      if (this._parseDataFrom == 0) {
        each3(this.xAxes.iterator(), function(axis) {
          axis.dataChangeUpdate();
        });
        each3(this.yAxes.iterator(), function(axis) {
          axis.dataChangeUpdate();
        });
        each3(this.series.iterator(), function(series) {
          series.dataChangeUpdate();
        });
      }
      _super.prototype.validateData.call(this);
    };
    XYChart2.prototype.updateXAxesMargins = function() {
      var leftAxesWidth = this.leftAxesContainer.measuredWidth;
      var rightAxesWidth = this.rightAxesContainer.measuredWidth;
      var bottomAxesCont = this.bottomAxesContainer;
      if (bottomAxesCont.paddingLeft != leftAxesWidth || bottomAxesCont.paddingRight != rightAxesWidth) {
        bottomAxesCont.paddingLeft = leftAxesWidth;
        bottomAxesCont.paddingRight = rightAxesWidth;
      }
      var topAxesCont = this.topAxesContainer;
      if (topAxesCont.paddingLeft != leftAxesWidth || topAxesCont.paddingRight != rightAxesWidth) {
        topAxesCont.paddingLeft = leftAxesWidth;
        topAxesCont.paddingRight = rightAxesWidth;
      }
    };
    XYChart2.prototype.reinit = function() {
      _super.prototype.reinit.call(this);
      this.series.each(function(series) {
        series.appeared = false;
      });
    };
    XYChart2.prototype.handleXAxisChange = function(event) {
      this.updateXAxis(event.target);
    };
    XYChart2.prototype.handleYAxisChange = function(event) {
      this.updateYAxis(event.target);
    };
    XYChart2.prototype.processXAxis = function(event) {
      var axis = event.newValue;
      axis.chart = this;
      if (!axis.renderer) {
        axis.renderer = new this._axisRendererX();
        axis.renderer.observe(["opposite", "inside", "inversed", "minGridDistance"], this.handleXAxisChange, this, false);
      }
      axis.axisLetter = "X";
      axis.events.on("startendchanged", this.handleXAxisRangeChange, this, false);
      axis.dataProvider = this;
      this.updateXAxis(axis.renderer);
      this.processAxis(axis);
    };
    XYChart2.prototype.processYAxis = function(event) {
      var axis = event.newValue;
      axis.chart = this;
      if (!axis.renderer) {
        axis.renderer = new this._axisRendererY();
        axis.renderer.observe(["opposite", "inside", "inversed", "minGridDistance"], this.handleYAxisChange, this, false);
      }
      axis.axisLetter = "Y";
      axis.events.on("startendchanged", this.handleYAxisRangeChange, this, false);
      axis.dataProvider = this;
      this.updateYAxis(axis.renderer);
      this.processAxis(axis);
    };
    XYChart2.prototype.handleXAxisRangeChange = function() {
      var range = this.getCommonAxisRange(this.xAxes);
      if (this.scrollbarX) {
        this.zoomAxes(this.xAxes, range, true);
      }
      this.toggleZoomOutButton();
      this.updateScrollbar(this.scrollbarX, range);
    };
    XYChart2.prototype.toggleZoomOutButton = function() {
      if (this.zoomOutButton) {
        var show_1 = false;
        eachContinue2(this.xAxes.iterator(), function(axis) {
          if (axis.toggleZoomOutButton) {
            if (axis.maxZoomCount > 0) {
              var minZoomFactor = axis.maxZoomFactor / axis.maxZoomCount;
              if (round(axis.end - axis.start, 3) < 1 / minZoomFactor) {
                show_1 = true;
                return false;
              }
            } else {
              if (round(axis.start, 3) > 0 || round(axis.end, 3) < 1) {
                show_1 = true;
                return false;
              }
            }
          }
          return true;
        });
        eachContinue2(this.yAxes.iterator(), function(axis) {
          if (axis.toggleZoomOutButton) {
            if (axis.maxZoomCount > 0) {
              var minZoomFactor = axis.maxZoomFactor / axis.maxZoomCount;
              if (round(axis.end - axis.start, 3) < 1 / minZoomFactor) {
                show_1 = true;
                return false;
              }
            } else {
              if (round(axis.start, 3) > 0 || round(axis.end, 3) < 1) {
                show_1 = true;
                return false;
              }
            }
            return true;
          }
        });
        if (!this.seriesAppeared) {
          show_1 = false;
        }
        if (show_1) {
          this.zoomOutButton.show();
        } else {
          this.zoomOutButton.hide();
        }
      }
    };
    XYChart2.prototype.seriesAppeared = function() {
      var appeared = false;
      each3(this.series.iterator(), function(series) {
        if (!series.appeared) {
          appeared = false;
          return false;
        }
      });
      return appeared;
    };
    XYChart2.prototype.handleYAxisRangeChange = function() {
      var range = this.getCommonAxisRange(this.yAxes);
      if (this.scrollbarY) {
        this.zoomAxes(this.yAxes, range, true);
      }
      this.toggleZoomOutButton();
      this.updateScrollbar(this.scrollbarY, range);
    };
    XYChart2.prototype.updateScrollbar = function(scrollbar, range) {
      if (scrollbar) {
        scrollbar.skipRangeEvents();
        scrollbar.start = range.start;
        scrollbar.end = range.end;
      }
    };
    XYChart2.prototype.getCommonAxisRange = function(axes) {
      var start;
      var end;
      axes.each(function(axis) {
        if (!axis.zoomable || axis instanceof ValueAxis && axis.syncWithAxis) {
        } else {
          var axisStart = axis.start;
          var axisEnd = axis.end;
          if (axis.renderer.inversed) {
            axisStart = 1 - axis.end;
            axisEnd = 1 - axis.start;
          }
          if (!isNumber(start) || axisStart < start) {
            start = axisStart;
          }
          if (!isNumber(end) || axisEnd > end) {
            end = axisEnd;
          }
        }
      });
      return { start, end };
    };
    XYChart2.prototype.updateXAxis = function(renderer) {
      var axis = renderer.axis;
      if (renderer.opposite) {
        axis.parent = this.topAxesContainer;
        axis.toFront();
      } else {
        axis.parent = this.bottomAxesContainer;
        axis.toBack();
      }
      if (axis.renderer) {
        axis.renderer.processRenderer();
      }
    };
    XYChart2.prototype.updateYAxis = function(renderer) {
      var axis = renderer.axis;
      if (renderer.opposite) {
        axis.parent = this.rightAxesContainer;
        axis.toBack();
      } else {
        axis.parent = this.leftAxesContainer;
        axis.toFront();
      }
      if (axis.renderer) {
        axis.renderer.processRenderer();
      }
    };
    XYChart2.prototype.processAxis = function(axis) {
      var _this = this;
      if (axis instanceof CategoryAxis) {
        this._dataUsers.moveValue(axis);
      }
      var renderer = axis.renderer;
      renderer.gridContainer.parent = this.plotContainer;
      renderer.gridContainer.toBack();
      renderer.breakContainer.parent = this.plotContainer;
      renderer.breakContainer.toFront();
      renderer.breakContainer.zIndex = 10;
      axis.addDisposer(new Disposer(function() {
        _this.dataUsers.removeValue(axis);
      }));
      renderer.bulletsContainer.parent = this.axisBulletsContainer;
      this._disposers.push(axis.events.on("positionchanged", function() {
        var point = spritePointToSprite({ x: 0, y: 0 }, axis, _this.axisBulletsContainer);
        if (axis.renderer instanceof AxisRendererY) {
          renderer.bulletsContainer.y = point.y;
        }
        if (axis.renderer instanceof AxisRendererX) {
          renderer.bulletsContainer.x = point.x;
        }
      }, void 0, false));
      this.plotContainer.events.on("maxsizechanged", function() {
        if (_this.inited) {
          axis.invalidateDataItems();
          _this.updateSeriesMasks();
        }
      }, axis, false);
    };
    XYChart2.prototype.updateSeriesMasks = function() {
      if (isIE()) {
        this.series.each(function(series) {
          var mask = series.mainContainer.mask;
          series.mainContainer.mask = void 0;
          series.mainContainer.mask = mask;
        });
      }
    };
    XYChart2.prototype.handleSeriesRemoved = function(event) {
      var series = event.oldValue;
      if (series) {
        if (series.xAxis) {
          series.xAxis.series.removeValue(series);
          series.xAxis.invalidateProcessedData();
        }
        if (series.yAxis) {
          series.yAxis.series.removeValue(series);
          series.yAxis.invalidateProcessedData();
        }
        this.series.each(function(series2) {
          series2.resetExtremes();
        });
      }
      _super.prototype.handleSeriesRemoved.call(this, event);
    };
    Object.defineProperty(XYChart2.prototype, "xAxes", {
      /**
       * A list of horizontal (X) axes.
       *
       * @return List of axes
       */
      get: function() {
        if (!this._xAxes) {
          this._xAxes = new List();
          this._xAxes.events.on("inserted", this.processXAxis, this, false);
          this._xAxes.events.on("removed", this.handleAxisRemoval, this, false);
          this._disposers.push(new ListDisposer(this._xAxes, false));
        }
        return this._xAxes;
      },
      enumerable: true,
      configurable: true
    });
    XYChart2.prototype.handleAxisRemoval = function(event) {
      var axis = event.oldValue;
      this.dataUsers.removeValue(axis);
      if (axis.autoDispose) {
        axis.dispose();
      }
    };
    Object.defineProperty(XYChart2.prototype, "yAxes", {
      /**
       * A list of vertical (Y) axes.
       *
       * @return List of axes
       */
      get: function() {
        if (!this._yAxes) {
          this._yAxes = new List();
          this._yAxes.events.on("inserted", this.processYAxis, this, false);
          this._yAxes.events.on("removed", this.handleAxisRemoval, this, false);
          this._disposers.push(new ListDisposer(this._yAxes, false));
        }
        return this._yAxes;
      },
      enumerable: true,
      configurable: true
    });
    XYChart2.prototype.handleSeriesAdded = function(event) {
      try {
        _super.prototype.handleSeriesAdded.call(this, event);
        var series = event.newValue;
        if (this.xAxes.length == 0 || this.yAxes.length == 0) {
          registry.removeFromInvalidComponents(series);
          series.dataInvalid = false;
        }
        used(series.xAxis);
        used(series.yAxis);
        series.maskBullets = series.maskBullets;
        if (series.fill == void 0) {
          if (this.patterns) {
            if (!hasValue(series.stroke)) {
              series.stroke = this.colors.next();
            }
            series.fill = this.patterns.next();
            if (hasValue(series.fillOpacity)) {
              series.fill.backgroundOpacity = series.fillOpacity;
            }
            if (series.stroke instanceof Color) {
              series.fill.stroke = series.stroke;
              series.fill.fill = series.stroke;
            }
          } else {
            series.fill = this.colors.next();
          }
        }
        if (!hasValue(series.stroke)) {
          series.stroke = series.fill;
        }
      } catch (e) {
        this.raiseCriticalError(e);
      }
    };
    Object.defineProperty(XYChart2.prototype, "cursor", {
      /**
       * @return Cursor
       */
      get: function() {
        return this._cursor;
      },
      /**
       * Chart's [[Cursor]].
       *
       * @param cursor  Cursor
       */
      set: function(cursor) {
        if (this._cursor != cursor) {
          if (this._cursor) {
            this.removeDispose(this._cursor);
          }
          this._cursor = cursor;
          if (cursor) {
            this._disposers.push(cursor);
            cursor.chart = this;
            cursor.shouldClone = false;
            cursor.parent = this._cursorContainer;
            cursor.events.on("cursorpositionchanged", this.handleCursorPositionChange, this, false);
            cursor.events.on("zoomstarted", this.handleCursorZoomStart, this, false);
            cursor.events.on("zoomended", this.handleCursorZoomEnd, this, false);
            cursor.events.on("panstarted", this.handleCursorPanStart, this, false);
            cursor.events.on("panning", this.handleCursorPanning, this, false);
            cursor.events.on("panended", this.handleCursorPanEnd, this, false);
            cursor.events.on("behaviorcanceled", this.handleCursorCanceled, this, false);
            cursor.events.on("hidden", this.handleHideCursor, this, false);
            cursor.zIndex = Number.MAX_SAFE_INTEGER - 1;
            if (this.tapToActivate) {
              this.setTapToActivate(this.tapToActivate);
            }
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    XYChart2.prototype.handleCursorPositionChange = function() {
      var cursor = this.cursor;
      if (cursor.visible && !cursor.isHiding) {
        var xPosition_1 = this.cursor.xPosition;
        var yPosition_1 = this.cursor.yPosition;
        this.showSeriesTooltip({
          x: xPosition_1,
          y: yPosition_1
        });
        var exceptAxes_1 = [];
        var snapToSeries = cursor.snapToSeries;
        if (snapToSeries && !cursor.downPoint) {
          if (snapToSeries instanceof XYSeries) {
            snapToSeries = [snapToSeries];
          }
          var dataItems_1 = [];
          each(snapToSeries, function(snpSeries) {
            if (!snpSeries.isHidden && !snpSeries.isHiding) {
              var xAxis = snpSeries.xAxis;
              var yAxis = snpSeries.yAxis;
              if (xAxis instanceof ValueAxis && !(xAxis instanceof DateAxis) && yAxis instanceof ValueAxis && !(yAxis instanceof DateAxis)) {
                snpSeries.dataItems.each(function(dataItem) {
                  dataItems_1.push(dataItem);
                });
                move(exceptAxes_1, snpSeries.yAxis);
                move(exceptAxes_1, snpSeries.xAxis);
              } else {
                if (snpSeries.baseAxis == snpSeries.xAxis) {
                  move(exceptAxes_1, snpSeries.yAxis);
                  dataItems_1.push(xAxis.getSeriesDataItem(snpSeries, xAxis.toAxisPosition(xPosition_1), true));
                }
                if (snpSeries.baseAxis == snpSeries.yAxis) {
                  move(exceptAxes_1, snpSeries.xAxis);
                  dataItems_1.push(yAxis.getSeriesDataItem(snpSeries, yAxis.toAxisPosition(yPosition_1), true));
                }
              }
            }
          });
          var closestDataItem_1 = this.getClosest(dataItems_1, xPosition_1, yPosition_1);
          if (closestDataItem_1) {
            this.series.each(function(series) {
              var closestSeries = closestDataItem_1.component;
              if (series != closestSeries) {
                series.hideTooltip();
                if (series.xAxis != closestSeries.xAxis) {
                  series.xAxis.hideTooltip();
                  exceptAxes_1.push(series.xAxis);
                }
                if (series.yAxis != closestSeries.yAxis) {
                  series.yAxis.hideTooltip();
                  exceptAxes_1.push(series.yAxis);
                }
              }
            });
            closestDataItem_1.component.showTooltipAtDataItem(closestDataItem_1);
            cursor.handleSnap(closestDataItem_1.component);
          }
        }
        this._seriesPoints = [];
        if (this._cursorXPosition != xPosition_1) {
          this.showAxisTooltip(this.xAxes, xPosition_1, exceptAxes_1);
        }
        if (this._cursorYPosition != yPosition_1) {
          this.showAxisTooltip(this.yAxes, yPosition_1, exceptAxes_1);
        }
        if (this.arrangeTooltips) {
          this.sortSeriesTooltips(this._seriesPoints);
        }
        if (this.legend) {
          this.legend.afterDraw();
        }
      }
    };
    XYChart2.prototype.getClosest = function(dataItems, xPosition, yPosition) {
      var minDistance = Infinity;
      var closestDataItem;
      eachContinue(dataItems, function(dataItem) {
        if (dataItem) {
          var xAxis = dataItem.component.xAxis;
          var yAxis = dataItem.component.yAxis;
          var xPos = xAxis.positionToCoordinate(xAxis.toGlobalPosition(xAxis.toAxisPosition(xPosition)));
          var yPos = yAxis.positionToCoordinate(yAxis.toGlobalPosition(yAxis.toAxisPosition(yPosition)));
          var xField = dataItem.component.xField;
          var yField = dataItem.component.yField;
          if (xAxis instanceof ValueAxis && !isNumber(dataItem.getValue(xField))) {
            return true;
          }
          if (yAxis instanceof ValueAxis && !isNumber(dataItem.getValue(yField))) {
            return true;
          }
          var dxPosition = xAxis.positionToCoordinate(xAxis.toGlobalPosition(xAxis.getPositionX(dataItem, xField, dataItem.locations[xField], "valueX")));
          var dyPosition = yAxis.positionToCoordinate(yAxis.toGlobalPosition(yAxis.getPositionY(dataItem, yField, dataItem.locations[yField], "valueY")));
          var distance = Math.sqrt(Math.pow(xPos - dxPosition, 2) + Math.pow(yPos - dyPosition, 2));
          if (distance < minDistance) {
            minDistance = distance;
            closestDataItem = dataItem;
          }
          return true;
        }
      });
      return closestDataItem;
    };
    XYChart2.prototype.handleHideCursor = function() {
      this.hideObjectTooltip(this.xAxes);
      this.hideObjectTooltip(this.yAxes);
      this.hideObjectTooltip(this.series);
      this._cursorXPosition = void 0;
      this._cursorYPosition = void 0;
      this.updateSeriesLegend();
    };
    XYChart2.prototype.updateSeriesLegend = function() {
      each3(this.series.iterator(), function(series) {
        series.updateLegendValue();
      });
    };
    XYChart2.prototype.hideObjectTooltip = function(sprites) {
      each3(sprites.iterator(), function(sprite) {
        if (sprite.cursorTooltipEnabled) {
          sprite.hideTooltip(0);
        }
      });
    };
    XYChart2.prototype.showSeriesTooltip = function(position) {
      var _this = this;
      if (!position) {
        this.series.each(function(series) {
          series.hideTooltip();
        });
        return;
      }
      var seriesPoints = [];
      this.series.each(function(series) {
        if (series.xAxis instanceof DateAxis && series.xAxis.snapTooltip || series.yAxis instanceof DateAxis && series.yAxis.snapTooltip) {
        } else {
          var point = series.showTooltipAtPosition(position.x, position.y);
          if (point) {
            series.tooltip.setBounds(spriteRectToSvg({ x: 0, y: 0, width: _this.pixelWidth, height: _this.pixelHeight }, _this));
            seriesPoints.push({ series, point });
          }
        }
      });
      if (this.arrangeTooltips) {
        this.sortSeriesTooltips(seriesPoints);
      }
    };
    XYChart2.prototype.sortSeriesTooltips = function(seriesPoints) {
      if (seriesPoints.length > 0) {
        var cursor_1 = this.cursor;
        if (cursor_1 && isNumber(cursor_1.maxTooltipDistance)) {
          var cursorPoint_1 = spritePointToSvg({ x: cursor_1.point.x, y: cursor_1.point.y }, cursor_1);
          var nearestSeries_1;
          var nearestPoint_1;
          var smallestDistance_1 = Infinity;
          each(seriesPoints, function(seriesPoint) {
            var series2 = seriesPoint.series;
            var fixedPoint = seriesPoint.point;
            if (fixedPoint) {
              var point = { x: fixedPoint.x, y: fixedPoint.y };
              var distance = Math.abs(getDistance(point, cursorPoint_1));
              if (distance < smallestDistance_1) {
                nearestPoint_1 = point;
                smallestDistance_1 = distance;
                nearestSeries_1 = series2;
              }
            }
          });
          var newSeriesPoints_1 = [];
          if (nearestSeries_1) {
            each(seriesPoints, function(seriesPoint) {
              if (Math.abs(getDistance(seriesPoint.point, nearestPoint_1)) <= Math.abs(cursor_1.maxTooltipDistance)) {
                newSeriesPoints_1.push({ series: seriesPoint.series, point: seriesPoint.point });
              } else {
                var tooltipDataItem = seriesPoint.series.tooltipDataItem;
                if (tooltipDataItem) {
                  each(tooltipDataItem.sprites, function(sprite) {
                    sprite.isHover = false;
                    sprite.handleOutReal();
                  });
                }
                seriesPoint.series.hideTooltip(0);
              }
            });
            if (cursor_1.maxTooltipDistance < 0) {
              if (newSeriesPoints_1.length > 0) {
                each(newSeriesPoints_1, function(np) {
                  if (nearestSeries_1 != np.series) {
                    np.series.hideTooltip(0);
                  }
                });
              }
              newSeriesPoints_1 = [{ series: nearestSeries_1, point: nearestPoint_1 }];
            }
          }
          seriesPoints = newSeriesPoints_1;
        }
        var topLeft_1 = spritePointToSvg({ x: -0.5, y: -0.5 }, this.plotContainer);
        var bottomRight_1 = spritePointToSvg({ x: this.plotContainer.pixelWidth + 0.5, y: this.plotContainer.pixelHeight + 0.5 }, this.plotContainer);
        var sum_1 = 0;
        var filteredSeriesPoints_1 = [];
        each(seriesPoints, function(seriesPoint) {
          var point = seriesPoint.point;
          if (point && isInRectangle(point, { x: topLeft_1.x, y: topLeft_1.y, width: bottomRight_1.x - topLeft_1.x, height: bottomRight_1.y - topLeft_1.y })) {
            filteredSeriesPoints_1.push({ point, series: seriesPoint.series });
            sum_1 += point.y;
          }
        });
        seriesPoints = filteredSeriesPoints_1;
        var firstSeries = this.series.getIndex(0);
        var inversed = false;
        if (firstSeries && firstSeries.yAxis && firstSeries.yAxis.renderer.inversed) {
          inversed = true;
        }
        if (inversed) {
          seriesPoints.sort(function(a, b) {
            return order2(a.point.y, b.point.y);
          });
        } else {
          seriesPoints.sort(function(a, b) {
            return order2(b.point.y, a.point.y);
          });
          seriesPoints.reverse();
        }
        var averageY = sum_1 / seriesPoints.length;
        var maxY = svgPointToDocument({ x: 0, y: 0 }, this.svgContainer.SVGContainer).y;
        if (seriesPoints.length > 0) {
          var top_1 = topLeft_1.y;
          var bottom = bottomRight_1.y;
          spritePointToDocument({ x: 0, y: top_1 }, this);
          var dropped = false;
          if (averageY > top_1 + (bottom - top_1) / 2) {
            var nextHeight = bottom;
            for (var i = seriesPoints.length - 1; i >= 0; i--) {
              var series = seriesPoints[i].series;
              var tooltip = series.tooltip;
              var pointY = seriesPoints[i].point.y;
              tooltip.setBounds({ x: 0, y: -maxY, width: this.pixelWidth, height: nextHeight + maxY });
              if (tooltip.invalid) {
                tooltip.validate();
              }
              tooltip.toBack();
              nextHeight = spritePointToSvg({ x: 0, y: tooltip.label.pixelY - tooltip.pixelY + pointY - tooltip.pixelMarginTop }, tooltip).y;
              if (nextHeight < -maxY) {
                dropped = true;
                break;
              }
            }
          }
          if (averageY <= top_1 + (bottom - top_1) / 2 || dropped) {
            var nextY = top_1;
            for (var i = 0, len = seriesPoints.length; i < len; i++) {
              var series = seriesPoints[i].series;
              var pointY = seriesPoints[i].point.y;
              var tooltip = series.tooltip;
              tooltip.setBounds({ x: 0, y: nextY, width: this.pixelWidth, height: bottom });
              if (tooltip.invalid) {
                tooltip.validate();
              }
              tooltip.toBack();
              nextY = spritePointToSvg({ x: 0, y: tooltip.label.pixelY + tooltip.label.measuredHeight - tooltip.pixelY + pointY + tooltip.pixelMarginBottom }, tooltip).y;
            }
          }
        }
      }
    };
    XYChart2.prototype.showAxisTooltip = function(axes, position, except) {
      var _this = this;
      each3(axes.iterator(), function(axis) {
        if (!except || except.indexOf(axis) == -1) {
          if (_this.dataItems.length > 0 || axis.dataItems.length > 0) {
            axis.showTooltipAtPosition(position);
          }
        }
      });
    };
    XYChart2.prototype.getUpdatedRange = function(axis, range) {
      if (!axis) {
        return;
      }
      var start;
      var end;
      var inversed = axis.renderer.inversed;
      if (inversed) {
        invertRange(range);
        start = 1 - axis.end;
        end = 1 - axis.start;
      } else {
        start = axis.start;
        end = axis.end;
      }
      var difference = end - start;
      return {
        start: start + range.start * difference,
        end: start + range.end * difference
      };
    };
    XYChart2.prototype.handleCursorZoomEnd = function(event) {
      var cursor = this.cursor;
      var behavior = cursor.behavior;
      if (behavior == "zoomX" || behavior == "zoomXY") {
        var xRange = cursor.xRange;
        if (xRange && this.xAxes.length > 0) {
          xRange = this.getUpdatedRange(this.xAxes.getIndex(0), xRange);
          xRange.priority = "start";
          this.zoomAxes(this.xAxes, xRange);
        }
      }
      if (behavior == "zoomY" || behavior == "zoomXY") {
        var yRange = cursor.yRange;
        if (yRange && this.yAxes.length > 0) {
          yRange = this.getUpdatedRange(this.yAxes.getIndex(0), yRange);
          yRange.priority = "start";
          this.zoomAxes(this.yAxes, yRange);
        }
      }
      this.handleHideCursor();
    };
    XYChart2.prototype.handleCursorPanStart = function(event) {
      var xAxis = this.xAxes.getIndex(0);
      if (xAxis) {
        this._panStartXRange = { start: xAxis.start, end: xAxis.end };
        if (xAxis.renderer.inversed) {
          this._panStartXRange = invertRange(this._panStartXRange);
        }
      }
      var yAxis = this.yAxes.getIndex(0);
      if (yAxis) {
        this._panStartYRange = { start: yAxis.start, end: yAxis.end };
        if (yAxis.renderer.inversed) {
          this._panStartYRange = invertRange(this._panStartYRange);
        }
      }
    };
    XYChart2.prototype.handleCursorPanEnd = function(event) {
      var cursor = this.cursor;
      var behavior = cursor.behavior;
      if (this._panEndXRange && (behavior == "panX" || behavior == "panXY")) {
        var panEndRange = this._panEndXRange;
        var panStartRange = this._panStartXRange;
        var delta = 0;
        if (panEndRange.start < 0) {
          delta = panEndRange.start;
        }
        if (panStartRange.end > 1) {
          if (panEndRange.end > panStartRange.end) {
            delta = panEndRange.end - panStartRange.end;
          }
        } else if (panEndRange.end > 1) {
          delta = panEndRange.end - 1;
        }
        this.zoomAxes(this.xAxes, { start: panEndRange.start - delta, end: panEndRange.end - delta }, false, cursor.snapOnPan);
        this._panEndXRange = void 0;
        this._panStartXRange = void 0;
      }
      if (this._panEndYRange && (behavior == "panY" || behavior == "panXY")) {
        var panEndRange = this._panEndYRange;
        var delta = 0;
        if (panEndRange.start < 0) {
          delta = panEndRange.start;
        }
        if (panEndRange.end > 1) {
          delta = panEndRange.end - 1;
        }
        this.zoomAxes(this.yAxes, { start: panEndRange.start - delta, end: panEndRange.end - delta }, false, cursor.snapOnPan);
        this._panEndYRange = void 0;
        this._panStartYRange = void 0;
      }
    };
    XYChart2.prototype.handleCursorCanceled = function() {
      this._panEndXRange = void 0;
      this._panStartXRange = void 0;
    };
    XYChart2.prototype.handleCursorPanning = function(event) {
      var cursor = this.cursor;
      var behavior = cursor.behavior;
      var maxPanOut = cursor.maxPanOut;
      if (this._panStartXRange && (behavior == "panX" || behavior == "panXY")) {
        var panStartRange = this._panStartXRange;
        var range = cursor.xRange;
        var axisRange = this.getCommonAxisRange(this.xAxes);
        var difference = panStartRange.end - panStartRange.start;
        var delta = range.start * (axisRange.end - axisRange.start);
        var newStart = Math.max(-maxPanOut, delta + panStartRange.start);
        var newEnd = Math.min(delta + panStartRange.end, 1 + maxPanOut);
        if (newStart <= 0) {
          newEnd = newStart + difference;
        }
        if (newEnd >= 1) {
          newStart = newEnd - difference;
        }
        var newRange = {
          start: newStart,
          end: newEnd
        };
        this._panEndXRange = newRange;
        this.zoomAxes(this.xAxes, newRange, false, false, cursor.maxPanOut);
      }
      if (this._panStartYRange && (behavior == "panY" || behavior == "panXY")) {
        var panStartRange = this._panStartYRange;
        var range = cursor.yRange;
        var axisRange = this.getCommonAxisRange(this.yAxes);
        var difference = panStartRange.end - panStartRange.start;
        var delta = range.start * (axisRange.end - axisRange.start);
        var newStart = Math.max(-maxPanOut, delta + panStartRange.start);
        var newEnd = Math.min(delta + panStartRange.end, 1 + maxPanOut);
        if (newStart <= 0) {
          newEnd = newStart + difference;
        }
        if (newEnd >= 1) {
          newStart = newEnd - difference;
        }
        var newRange = {
          start: newStart,
          end: newEnd
        };
        this._panEndYRange = newRange;
        this.zoomAxes(this.yAxes, newRange, false, false, cursor.maxPanOut);
      }
      this.handleHideCursor();
    };
    XYChart2.prototype.handleYAxisSet = function(series) {
    };
    XYChart2.prototype.handleCursorZoomStart = function(event) {
    };
    Object.defineProperty(XYChart2.prototype, "scrollbarX", {
      /**
       * @return Scrollbar
       */
      get: function() {
        return this._scrollbarX;
      },
      /**
       * Horizontal (X) scrollbar.
       *
       * @param scrollbar Scrollbar
       */
      set: function(scrollbar) {
        var _this = this;
        if (this._scrollbarX) {
          this.removeDispose(this._scrollbarX);
        }
        this._scrollbarX = scrollbar;
        if (scrollbar) {
          this._disposers.push(scrollbar);
          scrollbar.parent = this.topAxesContainer;
          scrollbar.shouldClone = false;
          scrollbar.startGrip.exportable = false;
          scrollbar.endGrip.exportable = false;
          scrollbar.toBack();
          scrollbar.orientation = "horizontal";
          scrollbar.events.on("rangechanged", this.handleXScrollbarChange, this, false);
          this.events.on("datavalidated", function() {
            return scrollbar.updateThumb(false);
          }, this, false);
          scrollbar.adapter.add("positionValue", function(arg) {
            var xAxis = _this.xAxes.getIndex(0);
            if (xAxis) {
              arg.value = xAxis.getPositionLabel(xAxis.renderer.inversed ? 1 - arg.position : arg.position);
            }
            return arg;
          });
          scrollbar.adapter.add("positionValueDirection", function(arg) {
            var xAxis = _this.xAxes.getIndex(0);
            if (xAxis) {
              arg.flipped = xAxis.renderer.inversed;
            }
            return arg;
          });
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYChart2.prototype, "scrollbarY", {
      /**
       * @return Scrollbar
       */
      get: function() {
        return this._scrollbarY;
      },
      /**
       * Vertical (Y) scrollbar.
       *
       * @param scrollbar Scrollbar
       */
      set: function(scrollbar) {
        var _this = this;
        if (this._scrollbarY) {
          this.removeDispose(this._scrollbarY);
        }
        this._scrollbarY = scrollbar;
        if (scrollbar) {
          this._disposers.push(scrollbar);
          scrollbar.parent = this.rightAxesContainer;
          scrollbar.startGrip.exportable = false;
          scrollbar.shouldClone = false;
          scrollbar.endGrip.exportable = false;
          scrollbar.toFront();
          scrollbar.orientation = "vertical";
          scrollbar.events.on("rangechanged", this.handleYScrollbarChange, this, false);
          this.events.on("datavalidated", function() {
            return scrollbar.updateThumb(false);
          }, this, false);
          scrollbar.adapter.add("positionValue", function(arg) {
            var yAxis = _this.yAxes.getIndex(0);
            if (yAxis) {
              arg.value = yAxis.getPositionLabel(yAxis.renderer.inversed ? arg.position : 1 - arg.position);
            }
            return arg;
          });
          scrollbar.adapter.add("positionValueDirection", function(arg) {
            var yAxis = _this.yAxes.getIndex(0);
            if (yAxis) {
              arg.flipped = !yAxis.renderer.inversed;
            }
            return arg;
          });
        }
      },
      enumerable: true,
      configurable: true
    });
    XYChart2.prototype.handleXScrollbarChange = function(event) {
      if (this.inited) {
        var scrollbar = event.target;
        var range = scrollbar.range;
        if (range.start == 0) {
          range.priority = "start";
        }
        if (range.end == 1) {
          range.priority = "end";
        }
        range = this.zoomAxes(this.xAxes, range);
        scrollbar.fixRange(range);
      }
    };
    XYChart2.prototype.handleYScrollbarChange = function(event) {
      if (this.inited) {
        var scrollbar = event.target;
        var range = scrollbar.range;
        if (range.end == 1) {
          range.priority = "end";
        }
        if (range.start == 0) {
          range.priority = "start";
        }
        range = this.zoomAxes(this.yAxes, range);
        scrollbar.fixRange(range);
      }
    };
    XYChart2.prototype.zoomAxes = function(axes, range, instantly, round3, declination, stop) {
      var realRange = { start: 0, end: 1 };
      this.showSeriesTooltip();
      var originalRange = range;
      if (!this.dataInvalid) {
        each3(axes.iterator(), function(axis) {
          var maxZoomFactor = axis.maxZoomFactor;
          if (isNumber(axis.minZoomCount)) {
            maxZoomFactor = maxZoomFactor / axis.minZoomCount;
          }
          if (stop && 1 / (range.end - range.start) >= maxZoomFactor) {
          } else {
            if (axis.zoomable) {
              if (axis.renderer.inversed) {
                range = invertRange(originalRange);
              } else {
                range = originalRange;
              }
              axis.hideTooltip(0);
              if (round3) {
                if (axis instanceof CategoryAxis) {
                  var cellWidth = axis.getCellEndPosition(0) - axis.getCellStartPosition(0);
                  range.start = axis.roundPosition(range.start + cellWidth / 2 - axis.startLocation * cellWidth, axis.startLocation);
                  range.end = axis.roundPosition(range.end - cellWidth / 2 + (1 - axis.endLocation) * cellWidth, axis.endLocation);
                } else {
                  var d = 1e-4;
                  range.start = axis.roundPosition(range.start + d, 0, axis.startLocation);
                  range.end = axis.roundPosition(range.end + d, 0, axis.endLocation);
                }
              }
              var axisRange = axis.zoom(range, instantly, instantly, declination);
              if (axis.renderer.inversed) {
                axisRange = invertRange(axisRange);
              }
              realRange = axisRange;
            }
          }
        });
      }
      return realRange;
    };
    Object.defineProperty(XYChart2.prototype, "maskBullets", {
      /**
       * @return Mask bullet container?
       */
      get: function() {
        return this.getPropertyValue("maskBullets");
      },
      /**
       * Indicates if bullet container is masked.
       *
       * If it is set to `true`, any bullets that do not fit into bullet container
       * will be clipped off. Settting to `false` will allow bullets to "spill out"
       * of the plot area so they are not cut off.
       *
       * @param value Mask bullet container?
       */
      set: function(value) {
        if (this.setPropertyValue("maskBullets", value, true) && this.bulletsContainer) {
          if (value) {
            this.bulletsContainer.mask = this._bulletMask;
          } else {
            this.bulletsContainer.mask = void 0;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYChart2.prototype, "arrangeTooltips", {
      /**
       * @return Arrange tooltips?
       */
      get: function() {
        return this.getPropertyValue("arrangeTooltips");
      },
      /**
       * Indicates if chart should arrange series tooltips so that they would not
       * overlap.
       *
       * If set to `true` (default), the chart will adjust vertical positions of
       * all simultaneously shown tooltips to avoid overlapping.
       *
       * However, if you have a vertically-arranged chart, it might not make sense,
       * because tooltips would most probably not be aligned horizontally. In this
       * case it would probably be a good idea to set this setting to `false`.
       *
       * @default true
       * @param value Arrange tooltips?
       */
      set: function(value) {
        this.setPropertyValue("arrangeTooltips", value, true);
      },
      enumerable: true,
      configurable: true
    });
    XYChart2.prototype.handleWheel = function(event) {
      var plotContainer = this.plotContainer;
      var svgPoint = documentPointToSvg(event.point, this.htmlContainer, this.svgContainer.cssScale);
      var plotPoint = svgPointToSprite(svgPoint, plotContainer);
      var shift = event.shift.y;
      this.handleWheelReal(shift, this.mouseWheelBehavior, plotPoint);
    };
    XYChart2.prototype.handleHorizontalWheel = function(event) {
      var plotContainer = this.plotContainer;
      var svgPoint = documentPointToSvg(event.point, this.htmlContainer, this.svgContainer.cssScale);
      var plotPoint = svgPointToSprite(svgPoint, plotContainer);
      this.handleWheelReal(event.shift.x, this.horizontalMouseWheelBehavior, plotPoint);
    };
    XYChart2.prototype.handleWheelReal = function(shift, mouseWheelBehavior, plotPoint) {
      if (shift != 0) {
        var plotContainer = this.plotContainer;
        var rangeX = this.getCommonAxisRange(this.xAxes);
        var rangeY = this.getCommonAxisRange(this.yAxes);
        var shiftStep = 0.1;
        var maxPanOut = 0;
        if (mouseWheelBehavior == "panX" || mouseWheelBehavior == "panXY") {
          var xAxis = this.xAxes.getIndex(0);
          var round3 = false;
          var singleItemStep = shiftStep;
          if (xAxis instanceof CategoryAxis) {
            singleItemStep = 0.5 / ((rangeX.end - rangeX.start) * xAxis.dataItems.length);
            round3 = true;
          }
          shiftStep = Math.max(0.2, singleItemStep);
          var differenceX = rangeX.end - rangeX.start;
          var newStartX = Math.max(-maxPanOut, rangeX.start + shiftStep * shift / 100 * (rangeX.end - rangeX.start));
          var newEndX = Math.min(rangeX.end + shiftStep * shift / 100 * (rangeX.end - rangeX.start), 1 + maxPanOut);
          if (newStartX <= 0) {
            newEndX = newStartX + differenceX;
          }
          if (newEndX >= 1) {
            newStartX = newEndX - differenceX;
          }
          this.zoomAxes(this.xAxes, { start: newStartX, end: newEndX }, void 0, round3);
        }
        if (mouseWheelBehavior == "panY" || mouseWheelBehavior == "panXY") {
          var yAxis = this.yAxes.getIndex(0);
          var singleItemStep = shiftStep;
          var round3 = false;
          if (yAxis instanceof CategoryAxis) {
            singleItemStep = 0.5 / ((rangeX.end - rangeX.start) * yAxis.dataItems.length);
            round3 = true;
          }
          shiftStep = Math.max(0.2, singleItemStep);
          shift *= -1;
          var differenceY = rangeY.end - rangeY.start;
          var newStartY = Math.max(-maxPanOut, rangeY.start + shiftStep * shift / 100 * (rangeY.end - rangeY.start));
          var newEndY = Math.min(rangeY.end + shiftStep * shift / 100 * (rangeY.end - rangeY.start), 1 + maxPanOut);
          if (newStartY <= 0) {
            newEndY = newStartY + differenceY;
          }
          if (newEndY >= 1) {
            newStartY = newEndY - differenceY;
          }
          this.zoomAxes(this.yAxes, { start: newStartY, end: newEndY }, void 0, round3);
        }
        if (mouseWheelBehavior == "zoomX" || mouseWheelBehavior == "zoomXY") {
          var locationX = plotPoint.x / plotContainer.maxWidth;
          var location2X = this.xAxes.getIndex(0).toAxisPosition(locationX);
          var newStartX = Math.max(-maxPanOut, rangeX.start - shiftStep * (rangeX.end - rangeX.start) * shift / 100 * locationX);
          newStartX = Math.min(newStartX, location2X);
          var newEndX = Math.min(rangeX.end + shiftStep * (rangeX.end - rangeX.start) * shift / 100 * (1 - locationX), 1 + maxPanOut);
          newEndX = Math.max(newEndX, location2X);
          this.zoomAxes(this.xAxes, { start: newStartX, end: newEndX }, void 0);
        }
        if (mouseWheelBehavior == "zoomY" || mouseWheelBehavior == "zoomXY") {
          var locationY = plotPoint.y / plotContainer.maxHeight;
          var location2Y = this.yAxes.getIndex(0).toAxisPosition(locationY);
          var newStartY = Math.max(-maxPanOut, rangeY.start - shiftStep * (rangeY.end - rangeY.start) * shift / 100 * (1 - locationY));
          newStartY = Math.min(newStartY, location2Y);
          var newEndY = Math.min(rangeY.end + shiftStep * shift / 100 * locationY * (rangeY.end - rangeY.start), 1 + maxPanOut);
          newEndY = Math.max(newEndY, location2Y);
          this.zoomAxes(this.yAxes, { start: newStartY, end: newEndY }, void 0);
        }
      }
    };
    Object.defineProperty(XYChart2.prototype, "mouseWheelBehavior", {
      /**
       * @return Mouse wheel behavior
       */
      get: function() {
        return this.getPropertyValue("mouseWheelBehavior");
      },
      /**
       * Specifies action for when mouse wheel is used when over the chart.
       *
       * Options: Options: `"zoomX"`, `"zoomY"`, `"zoomXY"`, `"panX"`, `"panY"`,`"panXY"`, `"none"` (default).
       *
       * You can control sensitivity of wheel zooming via `mouseOptions`.
       *
       * @default "none"
       * @see {@link https://www.amcharts.com/docs/v4/reference/sprite/#mouseOptions_property} More information about `mouseOptions`
       * @param mouse wheel behavior
       */
      set: function(value) {
        if (this.setPropertyValue("mouseWheelBehavior", value)) {
          if (value != "none") {
            this._mouseWheelDisposer = this.plotContainer.events.on("wheel", this.handleWheel, this, false);
            this._disposers.push(this._mouseWheelDisposer);
          } else {
            if (this._mouseWheelDisposer) {
              this.plotContainer.wheelable = false;
              this.plotContainer.hoverable = false;
              this._mouseWheelDisposer.dispose();
            }
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYChart2.prototype, "horizontalMouseWheelBehavior", {
      /**
       * @return Horizontal mouse wheel behavior
       */
      get: function() {
        return this.getPropertyValue("horizontalMouseWheelBehavior");
      },
      /**
       * Specifies action for when horizontal mouse wheel is used when over the chart.
       *
       * Options: Options: `"zoomX"`, `"zoomY"`, `"zoomXY"`, `"panX"`, `"panY"`, `"panXY"`, `"none"` (default).
       *
       * @default "none"
       * @see {@link https://www.amcharts.com/docs/v4/reference/sprite/#mouseOptions_property} More information about `mouseOptions`
       * @param mouse wheel behavior
       */
      set: function(value) {
        if (this.setPropertyValue("horizontalMouseWheelBehavior", value)) {
          if (value != "none") {
            this._mouseWheelDisposer2 = this.plotContainer.events.on("wheel", this.handleHorizontalWheel, this, false);
            this._disposers.push(this._mouseWheelDisposer2);
          } else {
            if (this._mouseWheelDisposer2) {
              this.plotContainer.wheelable = false;
              this.plotContainer.hoverable = false;
              this._mouseWheelDisposer2.dispose();
            }
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    XYChart2.prototype.dataSourceDateFields = function(fields) {
      var _this = this;
      fields = _super.prototype.dataSourceDateFields.call(this, fields);
      each3(this.series.iterator(), function(series) {
        fields = _this.populateDataSourceFields(fields, series.dataFields, ["dateX", "dateY", "openDateX", "openDateY"]);
      });
      return fields;
    };
    XYChart2.prototype.dataSourceNumberFields = function(fields) {
      var _this = this;
      fields = _super.prototype.dataSourceDateFields.call(this, fields);
      each3(this.series.iterator(), function(series) {
        fields = _this.populateDataSourceFields(fields, series.dataFields, ["valueX", "valueY", "openValueX", "openValueY"]);
      });
      return fields;
    };
    XYChart2.prototype.processConfig = function(config) {
      if (config) {
        var xAxes = [];
        var yAxes = [];
        if (hasValue(config.xAxes) && isArray(config.xAxes)) {
          for (var i = 0, len = config.xAxes.length; i < len; i++) {
            if (!config.xAxes[i].type) {
              throw Error("[XYChart error] No type set for xAxes[" + i + "].");
            } else if (hasValue(config.xAxes[i]["axisRanges"])) {
              for (var x = 0, len_1 = config.xAxes[i]["axisRanges"].length; x < len_1; x++) {
                var range = config.xAxes[i]["axisRanges"][x];
                if (hasValue(range.date) && isString(range.date)) {
                  range.date = this.dateFormatter.parse(range.date);
                }
                if (hasValue(range.endDate) && isString(range.endDate)) {
                  range.endDate = this.dateFormatter.parse(range.endDate);
                }
              }
              xAxes.push({
                axisRanges: config.xAxes[i]["axisRanges"],
                index: i
              });
              delete config.xAxes[i]["axisRanges"];
            }
          }
        }
        if (hasValue(config.yAxes) && isArray(config.yAxes)) {
          for (var i = 0, len = config.yAxes.length; i < len; i++) {
            if (!config.yAxes[i].type) {
              throw Error("[XYChart error] No type set for yAxes[" + i + "].");
            } else if (hasValue(config.yAxes[i]["axisRanges"])) {
              for (var x = 0, len_2 = config.yAxes[i]["axisRanges"].length; x < len_2; x++) {
                var range = config.yAxes[i]["axisRanges"][x];
                if (hasValue(range.date) && isString(range.date)) {
                  range.date = this.dateFormatter.parse(range.date);
                }
                if (hasValue(range.endDate) && isString(range.endDate)) {
                  range.endDate = this.dateFormatter.parse(range.endDate);
                }
              }
              yAxes.push({
                axisRanges: config.yAxes[i]["axisRanges"],
                index: i
              });
              delete config.yAxes[i]["axisRanges"];
            }
          }
        }
        if (hasValue(config.series) && isArray(config.series)) {
          for (var i = 0, len = config.series.length; i < len; i++) {
            config.series[i].type = config.series[i].type || "LineSeries";
          }
        }
        if (hasValue(config.cursor) && !hasValue(config.cursor.type)) {
          config.cursor.type = "XYCursor";
        }
        if (hasValue(config.scrollbarX) && !hasValue(config.scrollbarX.type)) {
          config.scrollbarX.type = "Scrollbar";
        }
        if (hasValue(config.scrollbarY) && !hasValue(config.scrollbarY.type)) {
          config.scrollbarY.type = "Scrollbar";
        }
        _super.prototype.processConfig.call(this, config);
        if (yAxes.length) {
          for (var i = 0, len = yAxes.length; i < len; i++) {
            this.yAxes.getIndex(yAxes[i].index).config = {
              axisRanges: yAxes[i].axisRanges
            };
          }
        }
        if (xAxes.length) {
          for (var i = 0, len = xAxes.length; i < len; i++) {
            this.xAxes.getIndex(xAxes[i].index).config = {
              axisRanges: xAxes[i].axisRanges
            };
          }
        }
      }
    };
    XYChart2.prototype.configOrder = function(a, b) {
      if (a == b) {
        return 0;
      } else if (a == "scrollbarX") {
        return 1;
      } else if (b == "scrollbarX") {
        return -1;
      } else if (a == "scrollbarY") {
        return 1;
      } else if (b == "scrollbarY") {
        return -1;
      } else if (a == "cursor") {
        return 1;
      } else if (b == "cursor") {
        return -1;
      } else if (a == "series") {
        return 1;
      } else if (b == "series") {
        return -1;
      } else {
        return _super.prototype.configOrder.call(this, a, b);
      }
    };
    XYChart2.prototype.createSeries = function() {
      return new XYSeries();
    };
    Object.defineProperty(XYChart2.prototype, "zoomOutButton", {
      /**
       * @return Zoom out button
       */
      get: function() {
        return this._zoomOutButton;
      },
      /**
       * A [[Button]] element that is used for zooming out the chart.
       *
       * This button appears only when chart is zoomed in, and disappears
       * autoamatically when it is zoome dout.
       *
       * @param button  Zoom out button
       */
      set: function(button) {
        var _this = this;
        this._zoomOutButton = button;
        if (button) {
          button.events.on("hit", function() {
            _this.zoomAxes(_this.xAxes, { start: 0, end: 1 });
            _this.zoomAxes(_this.yAxes, { start: 0, end: 1 });
          }, void 0, false);
        }
      },
      enumerable: true,
      configurable: true
    });
    XYChart2.prototype.copyFrom = function(source) {
      var _this = this;
      source.xAxes.each(function(axis) {
        var a = _this.xAxes.push(axis.clone());
        a.chart = _this;
        a.renderer.chart = _this;
      });
      source.yAxes.each(function(axis) {
        var a = _this.yAxes.push(axis.clone());
        a.renderer.chart = _this;
        a.chart = _this;
      });
      _super.prototype.copyFrom.call(this, source);
      if (source.cursor) {
        this.cursor = source.cursor.clone();
      }
      if (source.scrollbarX) {
        this.scrollbarX = source.scrollbarX.clone();
      }
      if (source.scrollbarY) {
        this.scrollbarY = source.scrollbarY.clone();
      }
    };
    XYChart2.prototype.disposeData = function() {
      _super.prototype.disposeData.call(this);
      var scrollbarX = this.scrollbarX;
      if (scrollbarX && scrollbarX instanceof XYChartScrollbar) {
        scrollbarX.scrollbarChart.disposeData();
      }
      var scrollbarY = this.scrollbarY;
      if (scrollbarY && scrollbarY instanceof XYChartScrollbar) {
        scrollbarY.scrollbarChart.disposeData();
      }
      this.xAxes.each(function(axis) {
        if (axis instanceof CategoryAxis) {
          axis.disposeData();
        }
      });
      this.yAxes.each(function(axis) {
        if (axis instanceof CategoryAxis) {
          axis.disposeData();
        }
      });
    };
    XYChart2.prototype.addData = function(rawDataItem, removeCount) {
      if (this.scrollbarX instanceof XYChartScrollbar) {
        this.addScrollbarData(this.scrollbarX, removeCount);
      }
      if (this.scrollbarY instanceof XYChartScrollbar) {
        this.addScrollbarData(this.scrollbarY, removeCount);
      }
      _super.prototype.addData.call(this, rawDataItem, removeCount);
    };
    XYChart2.prototype.addScrollbarData = function(scrollbar, removeCount) {
      var chart = scrollbar.scrollbarChart;
      chart._parseDataFrom = chart.data.length;
      chart.invalidateData();
    };
    XYChart2.prototype.removeScrollbarData = function(scrollbar, removeCount) {
      var chart = scrollbar.scrollbarChart;
      if (isNumber(removeCount)) {
        while (removeCount > 0) {
          var dataItem = this.dataItems.getIndex(0);
          if (dataItem) {
            chart.dataItems.remove(dataItem);
          }
          chart.dataUsers.each(function(dataUser) {
            var dataItem2 = dataUser.dataItems.getIndex(0);
            if (dataItem2) {
              dataUser.dataItems.remove(dataItem2);
            }
          });
          chart._parseDataFrom--;
          removeCount--;
        }
        chart.invalidateData();
      }
    };
    XYChart2.prototype.removeData = function(count) {
      if (this.scrollbarX instanceof XYChartScrollbar) {
        this.removeScrollbarData(this.scrollbarX, count);
      }
      if (this.scrollbarY instanceof XYChartScrollbar) {
        this.removeScrollbarData(this.scrollbarY, count);
      }
      _super.prototype.removeData.call(this, count);
    };
    XYChart2.prototype.setTapToActivate = function(value) {
      _super.prototype.setTapToActivate.call(this, value);
      if (this.cursor) {
        this.cursor.interactions.isTouchProtected = value;
        this.plotContainer.interactions.isTouchProtected = value;
      }
    };
    XYChart2.prototype.handleTapToActivate = function() {
      _super.prototype.handleTapToActivate.call(this);
      if (this.cursor) {
        this.cursor.interactions.isTouchProtected = false;
        this.plotContainer.interactions.isTouchProtected = false;
      }
    };
    XYChart2.prototype.handleTapToActivateDeactivation = function() {
      _super.prototype.handleTapToActivateDeactivation.call(this);
      if (this.cursor) {
        this.cursor.interactions.isTouchProtected = true;
        this.plotContainer.interactions.isTouchProtected = true;
      }
    };
    return XYChart2;
  }(SerialChart)
);
registry.registeredClasses["XYChart"] = XYChart;
defaultRules.push({
  relevant: ResponsiveBreakpoints.maybeXS,
  state: function(target, stateId) {
    if (target instanceof XYChart && target.scrollbarX) {
      var state = target.states.create(stateId);
      var sbstate = target.scrollbarX.states.create(stateId);
      sbstate.properties.disabled = true;
      return state;
    }
    return null;
  }
});
defaultRules.push({
  relevant: ResponsiveBreakpoints.maybeXS,
  state: function(target, stateId) {
    if (target instanceof XYChart && target.scrollbarY) {
      var state = target.states.create(stateId);
      var sbstate = target.scrollbarY.states.create(stateId);
      sbstate.properties.disabled = true;
      return state;
    }
    return null;
  }
});

// node_modules/@amcharts/amcharts4/.internal/charts/series/LineSeriesSegment.js
var LineSeriesSegment = (
  /** @class */
  function(_super) {
    __extends(LineSeriesSegment2, _super);
    function LineSeriesSegment2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "LineSeriesSegment";
      _this.isMeasured = false;
      _this.interactionsEnabled = false;
      _this.layout = "none";
      var fillSprite = _this.createChild(Sprite);
      _this.fillSprite = fillSprite;
      fillSprite.shouldClone = false;
      fillSprite.setElement(_this.paper.add("path"));
      fillSprite.isMeasured = false;
      _this._disposers.push(fillSprite);
      var strokeSprite = _this.createChild(Sprite);
      _this.strokeSprite = strokeSprite;
      strokeSprite.shouldClone = false;
      strokeSprite.fill = color();
      strokeSprite.setElement(_this.paper.add("path"));
      strokeSprite.isMeasured = false;
      _this._disposers.push(strokeSprite);
      return _this;
    }
    LineSeriesSegment2.prototype.drawSegment = function(points, closePoints, smoothnessX, smoothnessY) {
      if (!this.disabled) {
        if (points.length > 0 && closePoints.length > 0 && isNumber(points[0].x) && isNumber(points[0].y)) {
          var path = moveTo({ x: points[0].x - 0.2, y: points[0].y - 0.2 }) + moveTo(points[0]);
          var series = this.series;
          if (series.smoothing == "bezier") {
            path += new Tension(smoothnessX, smoothnessY).smooth(points);
          } else if (series.smoothing == "monotoneX") {
            path += new MonotoneX({ closed: false }).smooth(points);
          } else if (series.smoothing == "monotoneY") {
            path += new MonotoneY({ closed: false }).smooth(points);
          }
          if (this.strokeOpacity == 0 || this.strokeSprite.strokeOpacity == 0) {
          } else {
            this.strokeSprite.path = path;
          }
          if (this.fillOpacity > 0 || this.fillSprite.fillOpacity > 0) {
            if (isNumber(closePoints[0].x) && isNumber(closePoints[0].y)) {
              path += lineTo(closePoints[0]);
              if (series.smoothing == "bezier") {
                path += new Tension(smoothnessX, smoothnessY).smooth(closePoints);
              } else if (series.smoothing == "monotoneX") {
                path += new MonotoneX({ closed: false }).smooth(closePoints);
              } else if (series.smoothing == "monotoneY") {
                path += new MonotoneY({ closed: false }).smooth(closePoints);
              }
              path += lineTo(points[0]);
              path += closePath();
              this.fillSprite.path = path;
            }
          }
        } else {
          this.fillSprite.path = "";
          this.strokeSprite.path = "";
        }
      }
    };
    LineSeriesSegment2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      var lineElement = this.strokeSprite;
      copyProperties(source, lineElement.properties, visualProperties);
      lineElement.events.copyFrom(source.strokeSprite.events);
      lineElement.fillOpacity = 0;
      var fillElement = this.fillSprite;
      copyProperties(source, fillElement.properties, visualProperties);
      fillElement.events.copyFrom(source.fillSprite.events);
      fillElement.strokeOpacity = 0;
    };
    return LineSeriesSegment2;
  }(Container)
);
registry.registeredClasses["LineSeriesSegment"] = LineSeriesSegment;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/DurationAxis.js
var DurationAxisDataItem = (
  /** @class */
  function(_super) {
    __extends(DurationAxisDataItem2, _super);
    function DurationAxisDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "DurationAxisDataItem";
      _this.applyTheme();
      return _this;
    }
    return DurationAxisDataItem2;
  }(ValueAxisDataItem)
);
var DurationAxis = (
  /** @class */
  function(_super) {
    __extends(DurationAxis2, _super);
    function DurationAxis2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._baseUnit = "second";
      _this.className = "DurationAxis";
      _this.setPropertyValue("maxZoomFactor", 1e6);
      _this.applyTheme();
      return _this;
    }
    DurationAxis2.prototype.formatLabel = function(value, format) {
      return this.durationFormatter.format(value, format || this.axisDurationFormat);
    };
    DurationAxis2.prototype.adjustMinMax = function(min2, max2, difference, gridCount, strictMode) {
      var e_1, _a;
      var minMaxStep;
      var timeUnit = this.baseUnit;
      this.setPropertyValue("maxPrecision", 0);
      if (timeUnit == "millisecond" || timeUnit == "second" || timeUnit == "minute" || timeUnit == "hour") {
        if (gridCount <= 1) {
          gridCount = 1;
        }
        gridCount = Math.round(gridCount);
        var initialMin = min2;
        var initialMax = max2;
        if (difference === 0) {
          difference = Math.abs(max2);
        }
        var step = difference / gridCount;
        var divisors = [60, 30, 20, 15, 10, 2, 1];
        var realDivisor = 1;
        if (timeUnit == "hour") {
          divisors = [24, 12, 6, 4, 2, 1];
        }
        try {
          for (var divisors_1 = __values(divisors), divisors_1_1 = divisors_1.next(); !divisors_1_1.done; divisors_1_1 = divisors_1.next()) {
            var divisor = divisors_1_1.value;
            if (difference / divisor > gridCount) {
              realDivisor = divisor;
              break;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (divisors_1_1 && !divisors_1_1.done && (_a = divisors_1.return))
              _a.call(divisors_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var count = Math.ceil((max2 - min2) / realDivisor / gridCount);
        var exponent = Math.log(Math.abs(count)) * Math.LOG10E;
        var power = Math.pow(10, Math.floor(exponent)) / 10;
        var reducedCount = count / power;
        var closest2 = closest(divisors, reducedCount);
        count = closest2 * power;
        step = realDivisor * count;
        this.durationFormatter.getValueUnit(step, this.baseUnit);
        min2 = Math.floor(min2 / step) * step;
        max2 = Math.ceil(max2 / step) * step;
        if (strictMode) {
          min2 -= step;
          if (min2 < 0 && initialMin >= 0) {
            min2 = 0;
          }
          max2 += step;
          if (max2 > 0 && initialMax <= 0) {
            max2 = 0;
          }
        }
        minMaxStep = { min: min2, max: max2, step };
      } else {
        minMaxStep = _super.prototype.adjustMinMax.call(this, min2, max2, difference, gridCount, strictMode);
      }
      this.axisDurationFormat = this.durationFormatter.getFormat(minMaxStep.step, minMaxStep.max, this.baseUnit);
      return minMaxStep;
    };
    Object.defineProperty(DurationAxis2.prototype, "tooltipDurationFormat", {
      /**
       * @return Duration format for axis labels
       */
      get: function() {
        return this._tooltipDurationFormat;
      },
      /**
       * A special duration format to apply axis tooltips.
       *
       * Will use same format as for labels, if not set.
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/} for mor information.
       * @param value  Duration format for axis labels
       */
      set: function(value) {
        this._tooltipDurationFormat = value;
      },
      enumerable: true,
      configurable: true
    });
    DurationAxis2.prototype.getTooltipText = function(position) {
      var value = round(this.positionToValue(position), this._stepDecimalPlaces);
      var valueStr = this.formatLabel(value, this.tooltipDurationFormat);
      if (!this._adapterO) {
        return valueStr;
      } else {
        return this._adapterO.apply("getTooltipText", valueStr);
      }
    };
    Object.defineProperty(DurationAxis2.prototype, "baseUnit", {
      /**
       * @return Base unit
       */
      get: function() {
        return this._baseUnit;
      },
      /**
       * A base unit (granularity) of data.
       *
       * Used to indicate what are the base units of your data.
       *
       * Available options: "millisecond", "second" (default), "minute", "hour",
       * "day", "week", "month", "year".
       *
       * @default "second"
       * @param timeUnit
       */
      set: function(timeUnit) {
        if (this._baseUnit != timeUnit) {
          this._baseUnit = timeUnit;
          this.durationFormatter.baseUnit = timeUnit;
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    DurationAxis2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.baseUnit = source.baseUnit;
    };
    return DurationAxis2;
  }(ValueAxis)
);
registry.registeredClasses["DurationAxis"] = DurationAxis;
registry.registeredClasses["DurationAxisDataItem"] = DurationAxisDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/series/LineSeries.js
var LineSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(LineSeriesDataItem2, _super);
    function LineSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "LineSeriesDataItem";
      return _this;
    }
    return LineSeriesDataItem2;
  }(XYSeriesDataItem)
);
var LineSeries = (
  /** @class */
  function(_super) {
    __extends(LineSeries2, _super);
    function LineSeries2() {
      var _this = _super.call(this) || this;
      _this.minDistance = 0.5;
      _this.segments = new ListTemplate(_this.createSegment());
      _this.segments.template.applyOnClones = true;
      _this._disposers.push(new ListDisposer(_this.segments));
      _this._disposers.push(_this.segments.template);
      _this._segmentsIterator = new ListIterator(_this.segments, function() {
        return _this.segments.create();
      });
      _this._segmentsIterator.createNewItems = true;
      _this.className = "LineSeries";
      _this.strokeOpacity = 1;
      _this.fillOpacity = 0;
      _this.connect = true;
      _this.tensionX = 1;
      _this.tensionY = 1;
      _this.autoGapCount = 1.1;
      _this.smoothing = "bezier";
      _this.segmentsContainer = _this.mainContainer.createChild(Container);
      _this.segmentsContainer.isMeasured = false;
      _this.bulletsContainer.toFront();
      _this.applyTheme();
      return _this;
    }
    LineSeries2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Line Series");
      }
    };
    LineSeries2.prototype.createSegment = function() {
      return new LineSeriesSegment();
    };
    LineSeries2.prototype.createDataItem = function() {
      return new LineSeriesDataItem();
    };
    LineSeries2.prototype.setInitialWorkingValues = function(dataItem) {
      var yAxis = this._yAxis.get();
      var xAxis = this._xAxis.get();
      if (this.appeared && this.visible) {
        var previousDataItem = this.dataItems.getIndex(dataItem.index - 1);
        dataItem.component = this;
        if (this.baseAxis == xAxis) {
          if (yAxis instanceof ValueAxis) {
            var initialY = yAxis.minZoomed;
            if (previousDataItem) {
              initialY = previousDataItem.values["valueY"].workingValue;
            }
            dataItem.setWorkingValue("valueY", initialY, 0);
            dataItem.setWorkingValue("valueY", dataItem.values.valueY.value);
            if (xAxis instanceof DateAxis) {
              dataItem.setWorkingLocation("dateX", dataItem.locations.dateX - 1, 0);
              dataItem.setWorkingLocation("dateX", dataItem.locations.dateX);
            } else if (xAxis instanceof DurationAxis) {
              if (previousDataItem) {
                var value = dataItem.valueX;
                dataItem.setWorkingValue("valueX", previousDataItem.valueX, 0);
                dataItem.setWorkingValue("valueX", value);
              }
            }
          }
        }
        if (this.baseAxis == yAxis) {
          if (xAxis instanceof ValueAxis) {
            var initialX = xAxis.minZoomed;
            if (previousDataItem) {
              initialX = previousDataItem.values["valueX"].workingValue;
            }
            dataItem.setWorkingValue("valueX", initialX, 0);
            dataItem.setWorkingValue("valueX", dataItem.values.valueX.value);
            if (yAxis instanceof DateAxis) {
              dataItem.setWorkingLocation("dateY", dataItem.locations.dateX - 1, 0);
              dataItem.setWorkingLocation("dateY", dataItem.locations.dateY);
            } else if (yAxis instanceof DurationAxis) {
              if (previousDataItem) {
                var value = dataItem.valueY;
                dataItem.setWorkingValue("valueY", previousDataItem.valueY, 0);
                dataItem.setWorkingValue("valueY", value);
              }
            }
          }
        }
      } else {
        if (this.baseAxis == xAxis) {
          if (yAxis instanceof ValueAxis) {
            if (xAxis instanceof DateAxis) {
              dataItem.setWorkingLocation("dateX", dataItem.locations.dateX);
            }
            if (xAxis instanceof CategoryAxis) {
              dataItem.setWorkingLocation("categoryX", dataItem.locations.categoryX);
            }
          }
        }
        if (this.baseAxis == yAxis) {
          if (xAxis instanceof ValueAxis) {
            if (yAxis instanceof DateAxis) {
              dataItem.setWorkingLocation("dateY", dataItem.locations.dateY);
            }
            if (yAxis instanceof CategoryAxis) {
              dataItem.setWorkingLocation("categoryY", dataItem.locations.categoryY);
            }
          }
        }
      }
    };
    LineSeries2.prototype.updateLegendValue = function(dataItem, notRange) {
      _super.prototype.updateLegendValue.call(this, dataItem, notRange);
      if (dataItem && dataItem.segment) {
        this.tooltipColorSource = dataItem.segment;
      }
    };
    LineSeries2.prototype.validate = function() {
      var _this = this;
      _super.prototype.validate.call(this);
      if (this.xAxis && this.yAxis) {
        this._segmentsIterator.reset();
        this.openSegmentWrapper(this._adjustedStartIndex);
        each3(this.axisRanges.iterator(), function(range) {
          _this.openSegmentWrapper(_this._adjustedStartIndex, range);
        });
        each3(this._segmentsIterator.iterator(), function(segment) {
          segment.__disabled = true;
        });
      }
    };
    LineSeries2.prototype.sliceData = function() {
      var startIndex = this.startIndex;
      var endIndex = this.endIndex;
      for (var i = this.startIndex - 1; i >= 0; i--) {
        var dataItem = this.dataItems.getIndex(i);
        if (dataItem && dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {
          startIndex = i;
          break;
        }
      }
      this._adjustedStartIndex = this.findAdjustedIndex(startIndex, ["stroke", "strokeWidth", "strokeDasharray", "strokeOpacity", "fill", "fillOpacity", "opacity"]);
      for (var i = this.endIndex, len = this.dataItems.length; i < len; i++) {
        var dataItem = this.dataItems.getIndex(i);
        if (dataItem && dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {
          endIndex = i + 1;
          break;
        }
      }
      this._workingStartIndex = startIndex;
      this._workingEndIndex = endIndex;
    };
    LineSeries2.prototype.findAdjustedIndex = function(adjustedIndex, properties) {
      var _this = this;
      var propertyFields = this.propertyFields;
      var startIndex = adjustedIndex;
      each(properties, function(property) {
        if (hasValue(propertyFields[property])) {
          for (var i = startIndex; i >= 0; i--) {
            var dataItem = _this.dataItems.getIndex(i);
            if (dataItem) {
              if (hasValue(dataItem.properties[property])) {
                if (adjustedIndex > i) {
                  adjustedIndex = i;
                }
                break;
              }
            }
          }
        }
      });
      return adjustedIndex;
    };
    LineSeries2.prototype.openSegmentWrapper = function(openIndex, axisRange) {
      var params = {
        "index": openIndex,
        "axisRange": axisRange
      };
      do {
        params = this.openSegment(params.index, params.axisRange);
      } while (params);
    };
    LineSeries2.prototype.getSegment = function() {
      var segment = this._segmentsIterator.getFirst();
      segment.series = this;
      if (segment.isDisposed()) {
        this.segments.removeValue(segment);
        return this.getSegment();
      }
      return segment;
    };
    LineSeries2.prototype.openSegment = function(openIndex, axisRange) {
      var addToClose = false;
      var points = [];
      openIndex = Math.min(openIndex, this.dataItems.length);
      var endIndex = Math.min(this._workingEndIndex, this.dataItems.length);
      this._workingEndIndex = Math.min(this._workingEndIndex, this.dataItems.length);
      var closeIndex;
      var propertiesChanged = false;
      var segment = this.getSegment();
      segment.strokeDasharray = void 0;
      segment.__disabled = false;
      if (axisRange) {
        segment.parent = axisRange.contents;
        copyProperties(axisRange.contents, segment, visualProperties);
      } else {
        copyProperties(this, segment, visualProperties);
        segment.filters.clear();
        segment.parent = this.segmentsContainer;
      }
      this.group.node.removeAttribute("fill");
      var connect = this.connect;
      var valuesFound = false;
      for (var i = openIndex; i < endIndex; i++) {
        var dataItem = this.dataItems.getIndex(i);
        dataItem.segment = segment;
        if (dataItem.hasProperties) {
          if (i == openIndex) {
            this.updateSegmentProperties(dataItem.properties, segment);
          } else {
            propertiesChanged = this.updateSegmentProperties(dataItem.properties, segment, true);
          }
        }
        if (dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {
          this.addPoints(points, dataItem, this.xField, this.yField);
          valuesFound = true;
        } else {
          if (i == openIndex) {
            continue;
          } else {
            if (!connect && valuesFound) {
              closeIndex = i;
              break;
            }
          }
        }
        closeIndex = i;
        if (this.baseAxis instanceof DateAxis) {
          var next = this.dataItems.getIndex(i + 1);
          if (next && this.baseAxis.makeGap(next, dataItem)) {
            addToClose = true;
            break;
          }
        }
        if (propertiesChanged) {
          break;
        }
      }
      return this.closeSegment(segment, points, openIndex, closeIndex, axisRange, addToClose);
    };
    LineSeries2.prototype.addPoints = function(points, dataItem, xField, yField, backwards) {
      var point = this.getPoint(dataItem, xField, yField, dataItem.workingLocations[xField], dataItem.workingLocations[yField]);
      if (!backwards) {
        dataItem.point = point;
      }
      points.push(point);
    };
    LineSeries2.prototype.closeSegment = function(segment, points, openIndex, closeIndex, axisRange, add2) {
      var closePoints = [];
      if (this.dataFields[this._xOpenField] || this.dataFields[this._yOpenField] || this.stacked) {
        for (var i = closeIndex; i >= openIndex; i--) {
          var dataItem = this.dataItems.getIndex(i);
          if (dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {
            this.addPoints(closePoints, dataItem, this.xOpenField, this.yOpenField, true);
          }
        }
      } else {
        var baseAxis = this.baseAxis;
        var count = points.length;
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if (count > 0) {
          if (baseAxis == xAxis) {
            closePoints.push({ x: points[count - 1].x, y: yAxis.basePoint.y });
            closePoints.push({ x: points[0].x, y: yAxis.basePoint.y });
          } else {
            closePoints.push({ x: xAxis.basePoint.x, y: points[count - 1].y });
            closePoints.push({ x: xAxis.basePoint.x, y: points[0].y });
          }
        }
      }
      this.drawSegment(segment, points, closePoints);
      if (add2) {
        closeIndex++;
      }
      if (closeIndex < this._workingEndIndex - 1) {
        return { "index": closeIndex, "axisRange": axisRange };
      } else {
        return null;
      }
    };
    LineSeries2.prototype.drawSegment = function(segment, points, closePoints) {
      segment.drawSegment(points, closePoints, this.tensionX, this.tensionY);
    };
    LineSeries2.prototype.updateSegmentProperties = function(itemProperties, segment, checkOnly) {
      var changed = false;
      each2(itemProperties, function(propertyName, value) {
        if (hasValue(value)) {
          var currentValue = segment[propertyName];
          var currentValueStr = void 0;
          if (currentValue) {
            if (currentValue.toString) {
              currentValueStr = currentValue.toString();
            } else {
              currentValueStr = currentValue;
            }
          }
          var valueStr = void 0;
          if (value) {
            if (value.toString) {
              valueStr = value.toString();
            } else {
              valueStr = value;
            }
          }
          if (currentValue == value || currentValueStr != void 0 && valueStr != void 0 && currentValueStr == valueStr) {
          } else {
            if (!checkOnly) {
              segment[propertyName] = value;
            }
            changed = true;
          }
        }
      });
      return changed;
    };
    Object.defineProperty(LineSeries2.prototype, "connect", {
      /**
       * @return Connect?
       */
      get: function() {
        return this.getPropertyValue("connect");
      },
      /**
       * Connect the lines over empty data points?
       *
       * If set to `true` the line will connect two adjacent data points by a
       * straight line. Even if there are data points with missing values
       * in-between.
       *
       * If you set this to `false`, the line will break when there are missing
       * values.
       *
       * @see {@link https://www.amcharts.com/docs/v4/chart-types/xy-chart/#Line_series_with_gaps} for more information about this feature
       * @default true
       * @param value  Connect?
       */
      set: function(value) {
        if (this.setPropertyValue("connect", value)) {
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(LineSeries2.prototype, "tensionX", {
      /**
       * @return Horizontal tension (0-1)
       */
      get: function() {
        return this.getPropertyValue("tensionX");
      },
      /**
       * Horizontal tension setting of the line (0-1).
       *
       * Can be used to create smoothed lines. It works like this:
       *
       * Accepted values are in the range between 0 and 1. The biggest value (1)
       * will mean that the "tension" is very high, so the line is maximally
       * attracted to the points it connects, hence the straight line.
       *
       * Using smaller numbers will "relax" the tension, creating some curving.
       *
       * The smaller the tension setting, the more relaxed the line and the more
       * wide the curve.
       *
       * This setting is for horizontal tension, meaning the curve will bend in
       * such way that it never goes below or above connecting points. To enable
       * vertical bending as well, use `tensionY`.
       *
       * IMPORTANT: line smoothing works best when data items are placed at regular
       * intervals. For setups where data items are spaced erratically, enabling
       * smoothing might result in awkwardly looking lines.
       *
       * @default 1
       * @param value  Horizontal tension (0-1)
       */
      set: function(value) {
        this.setPropertyValue("tensionX", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(LineSeries2.prototype, "tensionY", {
      /**
       * @return Vertical tension (0-1)
       */
      get: function() {
        return this.getPropertyValue("tensionY");
      },
      /**
       * Can be used to create smoothed lines. It works like this:
       *
       * Accepted values are in the range between 0 and 1. The biggest value (1)
       * will mean that the "tension" is very high, so the line is maximally
       * attracted to the points it connects, hence the straight line.
       *
       * Using smaller numbers will "relax" the tension, creating some curving.
       *
       * The smaller the tension setting, the more relaxed the line and the more
       * wide the curve.
       *
       * This setting is for vertical tension, meaning the curve might bend in
       * such way that it will go below or above connected points.
       *
       * Combine this setting with `tensionX` to create beautifully looking
       * smoothed line series.
       *
       * @default 1
       * @param value  Vertical tension (0-1)
       */
      set: function(value) {
        this.setPropertyValue("tensionY", value, true);
      },
      enumerable: true,
      configurable: true
    });
    LineSeries2.prototype.createLegendMarker = function(marker) {
      var _this = this;
      var w = marker.pixelWidth;
      var h = marker.pixelHeight;
      marker.disposeChildren();
      var line = marker.createChild(Line);
      line.shouldClone = false;
      copyProperties(this, line, visualProperties);
      line.x2 = w;
      line.y = h / 2;
      line.y2 = 1e-5;
      line.visible = true;
      if (this.fillOpacity > 0) {
        var fill = marker.createChild(Rectangle);
        copyProperties(this, fill, visualProperties);
        fill.width = w;
        fill.height = h;
        fill.y = 0;
        fill.strokeOpacity = 0;
        fill.visible = true;
        line.y = 0;
      }
      var legendDataItem = marker.dataItem;
      legendDataItem.color = this.stroke;
      legendDataItem.colorOrig = this.fill;
      eachContinue2(this.bullets.iterator(), function(bullet) {
        if (bullet instanceof Bullet && !bullet.copyToLegendMarker) {
          return false;
        }
        var hasLabels = false;
        if (bullet instanceof Container) {
          each3(bullet.children.iterator(), function(child) {
            if (child instanceof Label) {
              hasLabels = true;
              return true;
            }
          });
        }
        if (!hasLabels) {
          var clone = bullet.clone();
          clone.parent = marker;
          clone.isMeasured = true;
          clone.tooltipText = void 0;
          clone.x = w / 2;
          if (_this.fillOpacity > 0) {
            clone.y = 0;
          } else {
            clone.y = h / 2;
          }
          clone.visible = true;
          if (!hasValue(clone.fill)) {
            clone.fill = _this.fill;
          }
          if (!hasValue(clone.stroke)) {
            clone.stroke = _this.stroke;
          }
          return false;
        }
      });
    };
    LineSeries2.prototype.disposeData = function() {
      _super.prototype.disposeData.call(this);
      this.segments.clear();
    };
    Object.defineProperty(LineSeries2.prototype, "autoGapCount", {
      /**
       * @return Gap count
       */
      get: function() {
        return this.getPropertyValue("autoGapCount");
      },
      /**
       * If `connect = false` and distance between two data points is bigger
       * than `baseInterval * autoGapCount`, a line will break automatically.
       *
       * @since 4.2.4
       * @param  value  Gap count
       */
      set: function(value) {
        this.setPropertyValue("autoGapCount", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(LineSeries2.prototype, "smoothing", {
      /**
       * @return Smoothing algorithm
       */
      get: function() {
        return this.getPropertyValue("smoothing");
      },
      /**
       * Smoothing algorithm to be used for lines.
       *
       * Available options: `"bezier"` (default), `"monotoneX"`, and `"monotoneY"`.
       *
       * Monotone options are best suited for data with irregular intervals. Use `"monotoneX"` for
       * horizontal lines, and `"monotoneY"` vertical ones.
       *
       * NOTE: Both "monotone" algorithms will ignore `tensionX` and `tensionY` settings.
       *
       * @since 4.10.0
       * @param  value  Smoothing algorithm
       */
      set: function(value) {
        this.setPropertyValue("smoothing", value, true);
      },
      enumerable: true,
      configurable: true
    });
    return LineSeries2;
  }(XYSeries)
);
registry.registeredClasses["LineSeries"] = LineSeries;
registry.registeredClasses["LineSeriesDataItem"] = LineSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/series/RadarSeries.js
var RadarSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(RadarSeriesDataItem2, _super);
    function RadarSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "RadarSeriesDataItem";
      _this.setLocation("dateX", 0, 0);
      _this.setLocation("dateY", 0, 0);
      _this.setLocation("categoryX", 0, 0);
      _this.setLocation("categoryY", 0, 0);
      _this.applyTheme();
      return _this;
    }
    return RadarSeriesDataItem2;
  }(LineSeriesDataItem)
);
var RadarSeries = (
  /** @class */
  function(_super) {
    __extends(RadarSeries2, _super);
    function RadarSeries2() {
      var _this = _super.call(this) || this;
      _this.className = "RadarSeries";
      _this.connectEnds = true;
      _this.applyTheme();
      return _this;
    }
    RadarSeries2.prototype.validate = function() {
      if (this.chart.invalid) {
        this.chart.validate();
      }
      _super.prototype.validate.call(this);
    };
    RadarSeries2.prototype.createDataItem = function() {
      return new RadarSeriesDataItem();
    };
    RadarSeries2.prototype.getPoint = function(dataItem, xKey, yKey, locationX, locationY, stackKeyX, stackKeyY) {
      if (!stackKeyX) {
        stackKeyX = "valueX";
      }
      if (!stackKeyY) {
        stackKeyY = "valueY";
      }
      var x = this.yAxis.getX(dataItem, yKey, locationY, stackKeyY);
      var y = this.yAxis.getY(dataItem, yKey, locationY, stackKeyY);
      var radius = getDistance({ x, y });
      if (radius == 0) {
        radius = 1e-5;
      }
      var angle = this.xAxis.getAngle(dataItem, xKey, locationX, stackKeyX);
      var startAngle = this.chart.startAngle;
      var endAngle = this.chart.endAngle;
      if (angle < startAngle || angle > endAngle) {
        return void 0;
      } else {
        return { x: radius * cos(angle), y: radius * sin(angle) };
      }
    };
    RadarSeries2.prototype.addPoints = function(points, dataItem, xField, yField, backwards) {
      var point = this.getPoint(dataItem, xField, yField, dataItem.locations[xField], dataItem.locations[yField]);
      if (point) {
        points.push(point);
      }
    };
    RadarSeries2.prototype.getMaskPath = function() {
      var renderer = this.yAxis.renderer;
      return arc(renderer.startAngle, renderer.endAngle - renderer.startAngle, renderer.pixelRadius, renderer.pixelInnerRadius);
    };
    RadarSeries2.prototype.drawSegment = function(segment, points, closePoints) {
      var axis = this.yAxis;
      var renderer = axis.renderer;
      if (this.connectEnds && Math.abs(renderer.endAngle - renderer.startAngle) == 360) {
        if (this.dataFields[this._xOpenField] || this.dataFields[this._yOpenField] || this.stacked) {
          points.push(points[0]);
          if (closePoints.length > 0) {
            closePoints.unshift(closePoints[closePoints.length - 1]);
          }
        }
      }
      _super.prototype.drawSegment.call(this, segment, points, closePoints);
    };
    Object.defineProperty(RadarSeries2.prototype, "connectEnds", {
      /**
       * @return Connect?
       */
      get: function() {
        return this.getPropertyValue("connectEnds");
      },
      /**
       * Should the last and and first data points be connected, forming a complete
       * closed circle?
       *
       * @default true
       * @param value  Connect?
       */
      set: function(value) {
        this.setPropertyValue("connectEnds", value, true);
      },
      enumerable: true,
      configurable: true
    });
    RadarSeries2.prototype.positionBulletReal = function(bullet, positionX, positionY) {
      var xAxis = this.xAxis;
      var yAxis = this.yAxis;
      if (positionX < xAxis.start || positionX > xAxis.end || positionY < yAxis.start || positionY > yAxis.end) {
        bullet.visible = false;
      }
      bullet.moveTo(this.xAxis.renderer.positionToPoint(positionX, positionY));
    };
    RadarSeries2.prototype.setXAxis = function(axis) {
      _super.prototype.setXAxis.call(this, axis);
      this.updateRendererRefs();
    };
    RadarSeries2.prototype.setYAxis = function(axis) {
      _super.prototype.setYAxis.call(this, axis);
      this.updateRendererRefs();
    };
    RadarSeries2.prototype.updateRendererRefs = function() {
      var rendererX = this.xAxis.renderer;
      var rendererY = this.yAxis.renderer;
      rendererX.axisRendererY = rendererY;
    };
    return RadarSeries2;
  }(LineSeries)
);
registry.registeredClasses["RadarSeries"] = RadarSeries;
registry.registeredClasses["RadarSeriesDataItem"] = RadarSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisFillCircular.js
var AxisFillCircular = (
  /** @class */
  function(_super) {
    __extends(AxisFillCircular2, _super);
    function AxisFillCircular2(axis) {
      var _this = _super.call(this, axis) || this;
      _this.className = "AxisFillCircular";
      _this.element = _this.paper.add("path");
      _this.radius = percent(100);
      _this.applyTheme();
      return _this;
    }
    AxisFillCircular2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      if (this.__disabled || this.disabled) {
        return;
      }
      if (this.axis) {
        var renderer = this.axis.renderer;
        this.fillPath = renderer.getPositionRangePath(this.startPosition, this.endPosition, this.radius, hasValue(this.innerRadius) ? this.innerRadius : renderer.innerRadius, this.cornerRadius);
        this.path = this.fillPath;
      }
    };
    Object.defineProperty(AxisFillCircular2.prototype, "innerRadius", {
      /**
       * @return Inner radius
       */
      get: function() {
        return this.getPropertyValue("innerRadius");
      },
      /**
       * Inner radius of the fill. Relative ([[Percent]]) or absolute (pixels).
       *
       * @param value  Inner radius
       */
      set: function(value) {
        this.setPercentProperty("innerRadius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisFillCircular2.prototype, "radius", {
      /**
       * @return Outer radius
       */
      get: function() {
        return this.getPropertyValue("radius");
      },
      /**
       * Outer radius of the fill. Relative ([[Percent]]) or absolute (pixels).
       *
       * @param value  Outer radius
       */
      set: function(value) {
        this.setPercentProperty("radius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisFillCircular2.prototype, "cornerRadius", {
      /**
       * @return Corner radius (px)
       */
      get: function() {
        return this.getPropertyValue("cornerRadius");
      },
      /**
       * Corner radius for the fill. In pixels.
       *
       * @param value  Corner radius (px)
       */
      set: function(value) {
        this.setPropertyValue("cornerRadius", value, true);
      },
      enumerable: true,
      configurable: true
    });
    return AxisFillCircular2;
  }(AxisFill)
);
registry.registeredClasses["AxisFillCircular"] = AxisFillCircular;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/GridCircular.js
var GridCircular = (
  /** @class */
  function(_super) {
    __extends(GridCircular2, _super);
    function GridCircular2() {
      var _this = _super.call(this) || this;
      _this.className = "GridCircular";
      _this.pixelPerfect = false;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(GridCircular2.prototype, "innerRadius", {
      /**
       * @return Inner radius
       */
      get: function() {
        return this.getPropertyValue("innerRadius");
      },
      /**
       * Inner radius of the circular grid. (absolute or relative)
       *
       * @param value Inner radius
       */
      set: function(value) {
        this.setPercentProperty("innerRadius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(GridCircular2.prototype, "radius", {
      /**
       * @return Outer radius
       */
      get: function() {
        return this.getPropertyValue("radius");
      },
      /**
       * Outer radius of the circular grid. (absolute or relative)
       *
       * @param value Outer radius
       */
      set: function(value) {
        this.setPercentProperty("radius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    return GridCircular2;
  }(Grid)
);
registry.registeredClasses["GridCircular"] = GridCircular;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisLabelCircular.js
var AxisLabelCircular = (
  /** @class */
  function(_super) {
    __extends(AxisLabelCircular2, _super);
    function AxisLabelCircular2() {
      var _this = _super.call(this) || this;
      _this.fdx = 0;
      _this.fdy = 0;
      _this.className = "AxisLabelCircular";
      _this.padding(0, 0, 0, 0);
      _this.location = 0.5;
      _this.locationOnPath = 0.5;
      _this.radius = 0;
      _this.isMeasured = false;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(AxisLabelCircular2.prototype, "relativeRotation", {
      /**
       * @return Rotation angle
       */
      get: function() {
        return this.getPropertyValue("relativeRotation");
      },
      /**
       * Relative rotation of the label.
       *
       * It is an angle to circle. In case 90, labels will be positioned like rays
       * of light, if 0 - positioned along the circle.
       *
       * @param value Rotation angle
       */
      set: function(value) {
        this.setPropertyValue("relativeRotation", value, true);
        if (!hasValue(value)) {
          this.rotation = void 0;
          var dataItem = this.dataItem;
          if (dataItem && dataItem.component) {
            dataItem.component.invalidateDataItems();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisLabelCircular2.prototype, "radius", {
      /**
       * @return Distance (px)
       */
      get: function() {
        return this.getPropertyValue("radius");
      },
      /**
       * Distance from axis circle to label in pixels or percent.
       *
       * @param value Distance (px or percent)
       */
      set: function(value) {
        this.setPercentProperty("radius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisLabelCircular2.prototype, "bent", {
      /**
       * @return Bent?
       */
      get: function() {
        return this.getPropertyValue("bent");
      },
      /**
       * Specifies if label should be bent along the circle.
       *
       * IMPORTANT: Use this with caution, since it is quite CPU-greedy.
       *
       * @since 4.1.2
       * @default false
       * @param  value  Bent?
       */
      set: function(value) {
        this.setPropertyValue("bent", value, true);
        this.setPropertyValue("wrap", false);
        this.setPropertyValue("horizontalCenter", "none");
        this.setPropertyValue("verticalCenter", "none");
        if (value) {
          this.setPropertyValue("dx", 0);
          this.setPropertyValue("dy", 0);
          this.setPropertyValue("x", 0);
          this.setPropertyValue("y", 0);
          this.setPropertyValue("rotation", 0);
          this.fdx = 0;
          this.fdy = 0;
          this.textAlign = "middle";
        } else {
          if (this.textPathElement) {
            this.textPathElement.dispose();
            this.textPathElement = void 0;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    AxisLabelCircular2.prototype.pixelRadius = function(axisRadius) {
      var sign = 1;
      if (this.inside) {
        sign = -1;
      }
      return relativeToValue(this.radius, axisRadius) * sign;
    };
    AxisLabelCircular2.prototype.pixelRadiusY = function(axisRadius, axisRadiusY) {
      var sign = 1;
      if (this.inside) {
        sign = -1;
      }
      var radius = this.radius;
      if (isNumber(radius)) {
        radius *= axisRadiusY / axisRadius;
        return relativeToValue(radius, axisRadius) * sign;
      } else {
        return relativeToValue(radius, axisRadiusY) * sign;
      }
    };
    AxisLabelCircular2.prototype.fixPosition = function(angle, axisRadius, axisRadiusY, dx, dy) {
      if (!isNumber(axisRadiusY)) {
        axisRadiusY = axisRadius;
      }
      if (!isNumber(dx)) {
        dx = 0;
      }
      if (!isNumber(dy)) {
        dy = 0;
      }
      var point = { x: axisRadius * cos(angle), y: axisRadiusY * sin(angle) };
      if (this.invalid) {
        this.validate();
      }
      var isNegative = false;
      var realRadius = this.radius;
      if (realRadius instanceof Percent && realRadius.value < 0) {
        isNegative = true;
      } else if (realRadius < 0) {
        isNegative = true;
      }
      var relativeRotation = this.relativeRotation;
      var labelRadius = this.pixelRadius(axisRadius);
      if (this.bent) {
        var point_1 = { x: (axisRadius + labelRadius) * cos(angle + 180), y: (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * sin(angle + 180) };
        this.path = moveTo(point_1) + arcTo(angle + 180, 360, axisRadius + labelRadius, axisRadiusY + labelRadius * axisRadiusY / axisRadius);
        if (this.textPathElement) {
          this.textPathElement.attr({ "startOffset": this.locationOnPath * 100 + "%" });
        }
        return;
      }
      if (isNumber(relativeRotation)) {
        this.horizontalCenter = "none";
        this.verticalCenter = "none";
        angle = fitAngleToRange(angle, -180, 180);
        var pixelWidth = this.bbox.width;
        var pixelHeight = this.bbox.height;
        var pixelPaddingBottom = this.pixelPaddingBottom;
        var pixelPaddingTop = this.pixelPaddingTop;
        var pixelPaddingLeft = this.pixelPaddingLeft;
        var pixelPaddingRight = this.pixelPaddingRight;
        if (angle > 90 || angle < -90) {
          if (relativeRotation == -90) {
            relativeRotation = 90;
            pixelWidth = 0;
          }
        } else {
          if (relativeRotation == -90) {
            pixelHeight = -pixelHeight;
          }
          if (relativeRotation == 90) {
            relativeRotation = -90;
            pixelWidth = -pixelPaddingLeft - pixelPaddingRight;
            pixelHeight = -pixelHeight - pixelPaddingTop - pixelPaddingBottom;
          }
        }
        this.rotation = relativeRotation + angle + 90;
        var dH = sin(relativeRotation) / 2;
        var dW = cos(relativeRotation) / 2;
        var rotation = this.rotation;
        this.dx = pixelHeight * dH * sin(rotation) - pixelWidth * dW * cos(rotation);
        this.dy = -pixelHeight * dH * cos(rotation) - pixelWidth * dW * sin(rotation);
        if (!this.inside) {
          labelRadius += (pixelHeight + pixelPaddingBottom + pixelPaddingTop) * cos(relativeRotation) + (pixelWidth + pixelPaddingLeft + pixelPaddingRight) * sin(relativeRotation);
        } else {
          if (angle > 90 || angle < -90) {
            labelRadius -= (pixelPaddingBottom + pixelPaddingTop) * cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight) * sin(relativeRotation);
          } else {
            labelRadius += (pixelPaddingBottom + this.bbox.height + pixelPaddingTop) * cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight + this.bbox.width) * sin(relativeRotation);
          }
        }
        point.x += cos(angle) * labelRadius;
        point.y += sin(angle) * labelRadius * axisRadiusY / axisRadius;
      } else {
        this.horizontalCenter = "middle";
        this.verticalCenter = "middle";
        if (isNegative) {
          this.dx = 0;
          this.dy = 0;
          point.x = (axisRadius + labelRadius) * cos(angle);
          point.y = (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * sin(angle);
        } else {
          this.dy = this._measuredHeight / 2 * sin(angle);
          this.dx = this._measuredWidth / 2 * cos(angle);
          point.x += cos(angle) * labelRadius;
          point.y += sin(angle) * labelRadius * axisRadiusY / axisRadius;
        }
      }
      point.x += dx;
      point.y += dy;
      this.fdx = this.dx;
      this.fdy = this.dy;
      this.moveTo(point);
    };
    return AxisLabelCircular2;
  }(AxisLabel)
);
registry.registeredClasses["AxisLabelCircular"] = AxisLabelCircular;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererCircular.js
var AxisRendererCircular = (
  /** @class */
  function(_super) {
    __extends(AxisRendererCircular2, _super);
    function AxisRendererCircular2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.pixelRadiusReal = 0;
      _this.layout = "none";
      _this.className = "AxisRendererCircular";
      _this.isMeasured = false;
      _this.startAngle = -90;
      _this.endAngle = 270;
      _this.useChartAngles = true;
      _this.radius = percent(100);
      _this.isMeasured = false;
      _this.grid.template.location = 0;
      _this.labels.template.location = 0;
      _this.labels.template.radius = 15;
      _this.ticks.template.location = 0;
      _this.ticks.template.pixelPerfect = false;
      _this.tooltipLocation = 0;
      _this.line.strokeOpacity = 0;
      _this.applyTheme();
      return _this;
    }
    AxisRendererCircular2.prototype.setAxis = function(axis) {
      var _this = this;
      _super.prototype.setAxis.call(this, axis);
      axis.isMeasured = false;
      var tooltip = axis.tooltip;
      tooltip.adapter.add("dx", function(x, target) {
        var point = svgPointToSprite({ x: target.pixelX, y: target.pixelY }, _this);
        return _this.pixelRadius * Math.cos(Math.atan2(point.y, point.x)) - point.x;
      });
      tooltip.adapter.add("dy", function(y, target) {
        var point = svgPointToSprite({ x: target.pixelX, y: target.pixelY }, _this);
        return _this.pixelRadius * Math.sin(Math.atan2(point.y, point.x)) - point.y;
      });
    };
    AxisRendererCircular2.prototype.validate = function() {
      if (this.chart && this.chart.invalid) {
        this.chart.validate();
      }
      _super.prototype.validate.call(this);
    };
    Object.defineProperty(AxisRendererCircular2.prototype, "axisLength", {
      /**
       * Returns actual length of the Axis, in pixels.
       *
       * @return Length (px)
       */
      get: function() {
        return 2 * Math.PI * this.pixelRadius;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRendererCircular2.prototype, "radius", {
      /**
       * @return Outer radius
       */
      get: function() {
        return this.getPropertyValue("radius");
      },
      /**
       * Outer radius of the axis.
       *
       * Can be absolute (px) or relative ([[Percent]]).
       *
       * @param value  Outer radius
       */
      set: function(value) {
        if (this.setPercentProperty("radius", value, false, false, 10, false)) {
          if (this.axis) {
            this.axis.invalidate();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRendererCircular2.prototype, "pixelRadius", {
      /**
       * Outer radius in pixels.
       *
       * @return Outer radius (px)
       */
      get: function() {
        return relativeRadiusToValue(this.radius, this.pixelRadiusReal) || 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRendererCircular2.prototype, "innerRadius", {
      /**
       * @return Inner radius
       */
      get: function() {
        var chart = this.chart;
        var innerRadius = this.getPropertyValue("innerRadius");
        if (chart) {
          if (!hasValue(innerRadius)) {
            innerRadius = chart.innerRadius;
            if (innerRadius instanceof Percent && chart) {
              innerRadius = percent(innerRadius.value * chart.innerRadiusModifyer * 100);
            }
          } else {
            if (innerRadius instanceof Percent && chart) {
              var mr = chart.mr;
              var value = innerRadius.value;
              value = Math.max(mr * value, mr - Math.min(chart.plotContainer.innerHeight, chart.plotContainer.innerWidth)) / mr;
              innerRadius = percent(value * 100);
            }
          }
          return innerRadius;
        }
      },
      /**
       * Inner radius of the axis.
       *
       * Can be absolute (px) or relative ([[Percent]]).
       *
       * @param value  Inner radius
       */
      set: function(value) {
        if (this.setPercentProperty("innerRadius", value, false, false, 10, false)) {
          if (this.axis) {
            this.axis.invalidate();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRendererCircular2.prototype, "useChartAngles", {
      /**
       * @return Use chart angles
       */
      get: function() {
        return this.getPropertyValue("useChartAngles");
      },
      /**
       * Specifies if axis should use its own `startAngle` and `endAngle` or
       * inherit them from relative properties from chart.
       *
       * @default false
       * @param value  Use chart's angles
       */
      set: function(value) {
        this.setPropertyValue("useChartAngles", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRendererCircular2.prototype, "pixelInnerRadius", {
      /**
       * Inner radius in pixels.
       *
       * @return Inner radius (px)
       */
      get: function() {
        return relativeRadiusToValue(this.innerRadius, this.pixelRadiusReal) || 0;
      },
      enumerable: true,
      configurable: true
    });
    AxisRendererCircular2.prototype.positionToPoint = function(position, position2) {
      if (!isNumber(position2)) {
        position2 = 1;
      }
      var coordinate = this.positionToCoordinate(position);
      var angle = this.startAngle + (this.endAngle - this.startAngle) * coordinate / this.axisLength;
      var radius = this.pixelRadius;
      var innerRadius = this.pixelInnerRadius;
      if (this.axisRendererY) {
        var realRadius = fitToRange(this.axisRendererY.positionToCoordinate(position2), 0, Infinity);
        if (realRadius == 0) {
          realRadius = 1e-6;
        }
        var point = { x: realRadius * cos(angle), y: realRadius * sin(angle) };
        return point;
      }
      return { x: cos(angle) * innerRadius + (radius - innerRadius) * cos(angle) * position2, y: sin(angle) * innerRadius + (radius - innerRadius) * sin(angle) * position2 };
    };
    AxisRendererCircular2.prototype.positionToAngle = function(position) {
      var axis = this.axis;
      var arc2 = (this.endAngle - this.startAngle) / (axis.end - axis.start);
      var angle;
      if (axis.renderer.inversed) {
        angle = this.startAngle + (axis.end - position) * arc2;
      } else {
        angle = this.startAngle + (position - axis.start) * arc2;
      }
      return round(angle, 3);
    };
    AxisRendererCircular2.prototype.angleToPosition = function(angle) {
      var axis = this.axis;
      var arc2 = (this.endAngle - this.startAngle) / (axis.end - axis.start);
      var position;
      if (axis.renderer.inversed) {
        position = axis.end - (angle - this.startAngle) / arc2;
      } else {
        position = (angle - this.startAngle) / arc2 + axis.start;
      }
      return round(position, 5);
    };
    AxisRendererCircular2.prototype.updateAxisLine = function() {
      var radius = this.pixelRadius;
      var startAngle = this.startAngle;
      var endAngle = this.endAngle;
      var arc2 = min(360, endAngle - startAngle);
      this.line.path = moveTo({ x: radius * cos(startAngle), y: radius * sin(startAngle) }) + arcTo(startAngle, arc2, radius, radius);
    };
    AxisRendererCircular2.prototype.updateGridElement = function(grid, position, endPosition) {
      position = position + (endPosition - position) * grid.location;
      var point = this.positionToPoint(position);
      if (isNumber(point.x) && isNumber(point.y) && grid.element) {
        var angle = DEGREES * Math.atan2(point.y, point.x);
        var radius = relativeRadiusToValue(hasValue(grid.radius) ? grid.radius : percent(100), this.pixelRadius);
        var gridInnerRadius = relativeRadiusToValue(grid.innerRadius, this.pixelRadius);
        grid.zIndex = 0;
        var innerRadius = relativeRadiusToValue(isNumber(gridInnerRadius) ? gridInnerRadius : this.innerRadius, this.pixelRadiusReal, true);
        if (!isNumber(innerRadius)) {
          innerRadius = 0;
        }
        grid.path = moveTo({ x: innerRadius * cos(angle), y: innerRadius * sin(angle) }) + lineTo({ x: radius * cos(angle), y: radius * sin(angle) });
      }
      this.toggleVisibility(grid, position, 0, 1);
    };
    AxisRendererCircular2.prototype.updateTickElement = function(tick, position, endPosition) {
      position = position + (endPosition - position) * tick.location;
      var point = this.positionToPoint(position);
      if (tick.element) {
        var radius = this.pixelRadius;
        var angle = DEGREES * Math.atan2(point.y, point.x);
        var tickLength = tick.length;
        if (tick.inside) {
          tickLength = -tickLength;
        }
        tick.zIndex = 1;
        tick.path = moveTo({ x: radius * cos(angle), y: radius * sin(angle) }) + lineTo({ x: (radius + tickLength) * cos(angle), y: (radius + tickLength) * sin(angle) });
      }
      this.toggleVisibility(tick, position, 0, 1);
    };
    AxisRendererCircular2.prototype.updateBullet = function(bullet, position, endPosition) {
      var location = 0.5;
      if (bullet instanceof AxisBullet) {
        location = bullet.location;
      }
      position = position + (endPosition - position) * location;
      var point = this.positionToPoint(position);
      var radius = this.pixelRadius;
      var angle = DEGREES * Math.atan2(point.y, point.x);
      point = { x: radius * cos(angle), y: radius * sin(angle) };
      this.positionItem(bullet, point);
      this.toggleVisibility(bullet, position, 0, 1);
    };
    AxisRendererCircular2.prototype.updateLabelElement = function(label, position, endPosition, location) {
      if (!hasValue(location)) {
        location = label.location;
      }
      position = position + (endPosition - position) * location;
      label.fixPosition(this.positionToAngle(position), this.pixelRadius);
      label.zIndex = 2;
      this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);
    };
    AxisRendererCircular2.prototype.fitsToBounds = function(point) {
      return true;
    };
    Object.defineProperty(AxisRendererCircular2.prototype, "startAngle", {
      /**
       * @return Start angle
       */
      get: function() {
        return this.getPropertyValue("startAngle");
      },
      /**
       * Start angle of the axis in degrees (0-360).
       *
       * @param value  Start angle
       */
      set: function(value) {
        if (this.setPropertyValue("startAngle", value)) {
          this.invalidateAxisItems();
          if (this.axis) {
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRendererCircular2.prototype, "endAngle", {
      /**
       * @return End angle
       */
      get: function() {
        return this.getPropertyValue("endAngle");
      },
      /**
       * End angle of the axis in degrees (0-360).
       *
       * @param value  End angle
       */
      set: function(value) {
        if (this.setPropertyValue("endAngle", value)) {
          this.invalidateAxisItems();
          if (this.axis) {
            this.axis.invalidateSeries();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    AxisRendererCircular2.prototype.getPositionRangePath = function(startPosition, endPosition, radius, innerRadius, cornerRadius) {
      var path = "";
      if (isNumber(startPosition) && isNumber(endPosition)) {
        if (!hasValue(radius)) {
          radius = this.radius;
        }
        startPosition = max(startPosition, this.axis.start);
        endPosition = min(endPosition, this.axis.end);
        if (endPosition < startPosition) {
          endPosition = startPosition;
        }
        var pixelRadius = relativeRadiusToValue(radius, this.pixelRadius);
        var pixelInnerRadius = relativeRadiusToValue(innerRadius, this.pixelRadius, true);
        var startAngle = this.positionToAngle(startPosition);
        var endAngle = this.positionToAngle(endPosition);
        var arc2 = endAngle - startAngle;
        path = arc(startAngle, arc2, pixelRadius, pixelInnerRadius, pixelRadius, cornerRadius);
      }
      return path;
    };
    AxisRendererCircular2.prototype.createGrid = function() {
      return new GridCircular();
    };
    AxisRendererCircular2.prototype.createFill = function(axis) {
      return new AxisFillCircular(axis);
    };
    AxisRendererCircular2.prototype.createLabel = function() {
      return new AxisLabelCircular();
    };
    AxisRendererCircular2.prototype.pointToPosition = function(point) {
      var angle = fitAngleToRange(getAngle(point), this.startAngle, this.endAngle);
      return this.coordinateToPosition((angle - this.startAngle) / 360 * this.axisLength);
    };
    return AxisRendererCircular2;
  }(AxisRenderer)
);
registry.registeredClasses["AxisRendererCircular"] = AxisRendererCircular;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererRadial.js
var AxisRendererRadial = (
  /** @class */
  function(_super) {
    __extends(AxisRendererRadial2, _super);
    function AxisRendererRadial2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._chart = new MutableValueDisposer();
      _this.pixelRadiusReal = 0;
      _this.className = "AxisRendererRadial";
      _this.isMeasured = false;
      _this.startAngle = -90;
      _this.endAngle = 270;
      _this.minGridDistance = 30;
      _this.gridType = "circles";
      _this.axisAngle = -90;
      _this.isMeasured = false;
      _this.layout = "none";
      _this.radius = percent(100);
      _this.line.strokeOpacity = 0;
      _this.labels.template.horizontalCenter = "middle";
      _this._disposers.push(_this._chart);
      _this.applyTheme();
      return _this;
    }
    AxisRendererRadial2.prototype.validate = function() {
      if (this.chart && this.chart.invalid) {
        this.chart.validate();
      }
      _super.prototype.validate.call(this);
    };
    Object.defineProperty(AxisRendererRadial2.prototype, "axisLength", {
      /**
       * Returns actual length of the Axis, in pixels.
       *
       * @return Length (px)
       */
      get: function() {
        return this.pixelRadius - this.pixelInnerRadius;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRendererRadial2.prototype, "radius", {
      /**
       * @return Outer radius
       */
      get: function() {
        return this.getPropertyValue("radius");
      },
      /**
       * Outer radius of the axis.
       *
       * Can be absolute (px) or relative ([[Percent]]).
       *
       * @param value  Outer radius
       */
      set: function(value) {
        this.setPercentProperty("radius", value, false, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRendererRadial2.prototype, "pixelRadius", {
      /**
       * Outer radius in pixels.
       *
       * @return Outer radius (px)
       */
      get: function() {
        return relativeRadiusToValue(this.radius, this.pixelRadiusReal) || 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRendererRadial2.prototype, "innerRadius", {
      /**
       * @return Inner radius
       */
      get: function() {
        var chart = this.chart;
        var innerRadius = this.getPropertyValue("innerRadius");
        if (chart) {
          if (!hasValue(innerRadius)) {
            innerRadius = chart.innerRadius;
            if (innerRadius instanceof Percent && chart) {
              innerRadius = percent(innerRadius.value * chart.innerRadiusModifyer * 100);
            }
          } else {
            if (innerRadius instanceof Percent && chart) {
              var mr = chart.mr;
              var value = innerRadius.value;
              value = Math.max(mr * value, mr - Math.min(chart.plotContainer.innerHeight, chart.plotContainer.innerWidth)) / mr;
              innerRadius = percent(value * 100);
            }
          }
        }
        return innerRadius;
      },
      /**
       * Inner radius of the axis.
       *
       * Can be absolute (px) or relative ([[Percent]]).
       *
       * @param value  Outer radius
       */
      set: function(value) {
        this.setPercentProperty("innerRadius", value, false, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRendererRadial2.prototype, "pixelInnerRadius", {
      /**
       * Inner radius in pixels.
       *
       * @return Inner radius (px)
       */
      get: function() {
        return relativeRadiusToValue(this.innerRadius, this.pixelRadiusReal) || 0;
      },
      enumerable: true,
      configurable: true
    });
    AxisRendererRadial2.prototype.positionToPoint = function(position, position2) {
      var radius = fitToRange(this.positionToCoordinate(position), 0, Infinity);
      return { x: radius * cos(this.axisAngle), y: radius * sin(this.axisAngle) };
    };
    AxisRendererRadial2.prototype.updateAxisLine = function() {
      this.line.path = moveTo({ x: this.pixelInnerRadius * cos(this.axisAngle), y: this.pixelInnerRadius * sin(this.axisAngle) }) + lineTo({ x: this.pixelRadius * cos(this.axisAngle), y: this.pixelRadius * sin(this.axisAngle) });
      var title = this.axis.title;
      title.valign = "none";
      title.horizontalCenter = "middle";
      title.verticalCenter = "bottom";
      title.y = -this.axisLength / 2;
      var rotation = 90;
      if (this.opposite) {
        if (!this.inside) {
          rotation = -90;
        }
      } else {
        if (this.inside) {
          rotation = -90;
        }
      }
      title.rotation = rotation;
    };
    AxisRendererRadial2.prototype.updateGridElement = function(grid, position, endPosition) {
      position = position + (endPosition - position) * grid.location;
      var point = this.positionToPoint(position);
      var path;
      var radius = getDistance(point);
      var startAngle = this.startAngle;
      var endAngle = this.endAngle;
      var chart = this.chart;
      if (isNumber(radius) && grid.element && chart) {
        var xAxis = chart.xAxes.getIndex(0);
        var count = 0;
        var series = chart.series.getIndex(0);
        if (series) {
          count = series.dataItems.length;
        }
        if (this.gridType == "polygons" && count > 0 && series && xAxis && xAxis instanceof CategoryAxis) {
          var gridLocation = xAxis.renderer.grid.template.location;
          var angle = xAxis.getAngle(series.dataItems.getIndex(0), "categoryX", gridLocation);
          path = moveTo({ x: radius * cos(angle), y: radius * sin(angle) });
          for (var i = 1; i < count; i++) {
            angle = xAxis.getAngle(series.dataItems.getIndex(i), "categoryX", gridLocation);
            path += lineTo({ x: radius * cos(angle), y: radius * sin(angle) });
          }
          angle = xAxis.getAngle(series.dataItems.getIndex(count - 1), "categoryX", xAxis.renderer.cellEndLocation);
          path += lineTo({ x: radius * cos(angle), y: radius * sin(angle) });
        } else {
          path = moveTo({ x: radius * cos(startAngle), y: radius * sin(startAngle) }) + arcTo(startAngle, endAngle - startAngle, radius, radius);
        }
        grid.path = path;
      }
      this.toggleVisibility(grid, position, 0, 1);
    };
    AxisRendererRadial2.prototype.updateLabelElement = function(label, position, endPosition, location) {
      if (!hasValue(location)) {
        location = label.location;
      }
      position = position + (endPosition - position) * location;
      var point = this.positionToPoint(position);
      this.positionItem(label, point);
      this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);
    };
    AxisRendererRadial2.prototype.updateBaseGridElement = function() {
    };
    AxisRendererRadial2.prototype.fitsToBounds = function(point) {
      return true;
    };
    Object.defineProperty(AxisRendererRadial2.prototype, "startAngle", {
      /**
       * @return Start angle
       */
      get: function() {
        return this.getPropertyValue("startAngle");
      },
      /**
       * Start angle of the axis in degrees. (0-360)
       *
       * @param value  Start angle
       */
      set: function(value) {
        if (this.setPropertyValue("startAngle", value)) {
          this.invalidateAxisItems();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRendererRadial2.prototype, "endAngle", {
      /**
       * @return End angle
       */
      get: function() {
        return this.getPropertyValue("endAngle");
      },
      /**
       * End angle of the axis in degrees. (0-360)
       *
       * @param value  End angle
       */
      set: function(value) {
        if (this.setPropertyValue("endAngle", value)) {
          this.invalidateAxisItems();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRendererRadial2.prototype, "axisAngle", {
      /**
       * @return Axis angle
       */
      get: function() {
        return this.getPropertyValue("axisAngle");
      },
      /**
       * Angle of the radial axis in degrees. (0-360)
       *
       * @param value  Axis angle
       */
      set: function(value) {
        this.setPropertyValue("axisAngle", normalizeAngle(value));
        this.invalidateAxisItems();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AxisRendererRadial2.prototype, "gridType", {
      /**
       * Grid type
       */
      get: function() {
        var axis = this.chart.xAxes.getIndex(0);
        if (axis instanceof CategoryAxis) {
          return this.getPropertyValue("gridType");
        } else {
          return "circles";
        }
      },
      // polygons grid type is only possible under these conditions: xAxis is available and it is CategoryAxis, also at least one series should be added to a chart
      /**
       * Grid type for radial axis.
       *
       * A grid on radia axis can either be perfect circles ("circles"), or
       * straight lines ("polygons").
       *
       * @default "circles"
       * @param value  Grid type
       */
      set: function(value) {
        this.setPropertyValue("gridType", value, true);
      },
      enumerable: true,
      configurable: true
    });
    AxisRendererRadial2.prototype.getPositionRangePath = function(startPosition, endPosition) {
      var pixelInnerRadius = this.pixelInnerRadius;
      var pixelRadius = this.axisLength + pixelInnerRadius;
      var innerRadius = fitToRange(this.positionToCoordinate(startPosition), pixelInnerRadius, pixelRadius);
      var radius = fitToRange(this.positionToCoordinate(endPosition), pixelInnerRadius, pixelRadius);
      var startAngle = this.startAngle;
      var endAngle = this.endAngle;
      var arc2 = endAngle - startAngle;
      var path;
      var chart = this.chart;
      var xAxis = chart.xAxes.getIndex(0);
      var series = chart.series.getIndex(0);
      var count = 0;
      if (series) {
        count = series.dataItems.length;
      }
      if (this.gridType == "polygons" && count > 0 && series && xAxis && xAxis instanceof CategoryAxis) {
        var gridLocation = xAxis.renderer.grid.template.location;
        var angle = xAxis.getAngle(series.dataItems.getIndex(0), "categoryX", gridLocation);
        path = moveTo({ x: radius * cos(angle), y: radius * sin(angle) });
        for (var i = 1; i < count; i++) {
          angle = xAxis.getAngle(series.dataItems.getIndex(i), "categoryX", gridLocation);
          path += lineTo({ x: radius * cos(angle), y: radius * sin(angle) });
        }
        angle = xAxis.getAngle(series.dataItems.getIndex(count - 1), "categoryX", xAxis.renderer.cellEndLocation);
        path += lineTo({ x: radius * cos(angle), y: radius * sin(angle) });
        path += moveTo({ x: innerRadius * cos(angle), y: innerRadius * sin(angle) });
        for (var i = count - 1; i >= 0; i--) {
          angle = xAxis.getAngle(series.dataItems.getIndex(i), "categoryX", gridLocation);
          path += lineTo({ x: innerRadius * cos(angle), y: innerRadius * sin(angle) });
        }
      } else {
        path = arc(startAngle, arc2, radius, innerRadius);
      }
      return path;
    };
    AxisRendererRadial2.prototype.updateBreakElement = function(axisBreak) {
      var startLine = axisBreak.startLine;
      var endLine = axisBreak.endLine;
      var fillShape = axisBreak.fillShape;
      var startPoint = axisBreak.startPoint;
      var endPoint = axisBreak.endPoint;
      startLine.radius = Math.abs(startPoint.y);
      endLine.radius = Math.abs(endPoint.y);
      fillShape.radius = Math.abs(endPoint.y);
      fillShape.innerRadius = Math.abs(startPoint.y);
    };
    AxisRendererRadial2.prototype.createBreakSprites = function(axisBreak) {
      axisBreak.startLine = new WavedCircle();
      axisBreak.endLine = new WavedCircle();
      axisBreak.fillShape = new WavedCircle();
    };
    AxisRendererRadial2.prototype.updateTooltip = function() {
      var axis = this.axis;
      if (axis) {
        var bigNum = 4e3;
        var bbx = -4e3;
        var bby = -4e3;
        var bbw = bigNum * 2;
        var bbh = bigNum * 2;
        var axisAngle = this.axisAngle;
        if (axisAngle < 0) {
          axisAngle += 360;
        }
        var tooltipOrientation = "vertical";
        if (axisAngle > 45 && axisAngle < 135 || axisAngle > 225 && axisAngle < 315) {
          tooltipOrientation = "horizontal";
        }
        this.axis.updateTooltip(tooltipOrientation, { x: bbx, y: bby, width: bbw, height: bbh });
      }
    };
    AxisRendererRadial2.prototype.updateTickElement = function(tick, position, endPosition) {
      position = position + (endPosition - position) * tick.location;
      var point = this.positionToPoint(position);
      if (tick.element) {
        var angle = normalizeAngle(this.axisAngle + 90);
        if (angle / 90 != Math.round(angle / 90)) {
          tick.pixelPerfect = false;
        } else {
          tick.pixelPerfect = true;
        }
        var tickLength = -tick.length;
        if (tick.inside) {
          tickLength *= -1;
        }
        tick.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: tickLength * cos(angle), y: tickLength * sin(angle) });
      }
      this.positionItem(tick, point);
      this.toggleVisibility(tick, position, 0, 1);
    };
    AxisRendererRadial2.prototype.updateBullet = function(bullet, position, endPosition) {
      var location = 0.5;
      if (bullet instanceof AxisBullet) {
        location = bullet.location;
      }
      position = position + (endPosition - position) * location;
      var point = this.positionToPoint(position);
      this.positionItem(bullet, point);
      this.toggleVisibility(bullet, position, 0, 1);
    };
    AxisRendererRadial2.prototype.positionToCoordinate = function(position) {
      var coordinate;
      var axis = this.axis;
      var axisFullLength = axis.axisFullLength;
      var innerRadius = this.pixelInnerRadius;
      if (axis.renderer.inversed) {
        coordinate = (axis.end - position) * axisFullLength + innerRadius;
      } else {
        coordinate = (position - axis.start) * axisFullLength + innerRadius;
      }
      return round(coordinate, 1);
    };
    AxisRendererRadial2.prototype.pointToPosition = function(point) {
      var coordinate = getDistance(point) - this.pixelInnerRadius;
      return this.coordinateToPosition(coordinate);
    };
    Object.defineProperty(AxisRendererRadial2.prototype, "chart", {
      /**
       * @ignore Exclude from docs
       * @return Chart
       */
      get: function() {
        return this._chart.get();
      },
      /**
       * A chart, associated with the Axis.
       *
       * @ignore Exclude from docs
       * @param value  Chart
       */
      set: function(value) {
        this._chart.set(value, null);
      },
      enumerable: true,
      configurable: true
    });
    return AxisRendererRadial2;
  }(AxisRendererY)
);
registry.registeredClasses["AxisRendererRadial"] = AxisRendererRadial;

// node_modules/@amcharts/amcharts4/.internal/charts/types/RadarChart.js
var RadarChartDataItem = (
  /** @class */
  function(_super) {
    __extends(RadarChartDataItem2, _super);
    function RadarChartDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "RadarChartDataItem";
      _this.applyTheme();
      return _this;
    }
    return RadarChartDataItem2;
  }(XYChartDataItem)
);
var RadarChart = (
  /** @class */
  function(_super) {
    __extends(RadarChart2, _super);
    function RadarChart2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._axisRendererX = AxisRendererCircular;
      _this._axisRendererY = AxisRendererRadial;
      _this.innerRadiusModifyer = 1;
      _this.mr = 1;
      _this.className = "RadarChart";
      _this.startAngle = -90;
      _this.endAngle = 270;
      _this.radius = percent(80);
      _this.innerRadius = 0;
      var radarContainer = _this.plotContainer.createChild(Container);
      radarContainer.shouldClone = false;
      radarContainer.layout = "absolute";
      radarContainer.align = "center";
      radarContainer.valign = "middle";
      _this.seriesContainer.parent = radarContainer;
      _this.radarContainer = radarContainer;
      _this.bulletsContainer.parent = radarContainer;
      _this.axisBulletsContainer = radarContainer;
      _this._cursorContainer = radarContainer;
      _this.chartContainer.events.on("maxsizechanged", _this.invalidate, _this, false);
      _this._bulletMask = radarContainer.createChild(Circle);
      _this._bulletMask.shouldClone = false;
      _this._bulletMask.element = _this.paper.add("path");
      _this._bulletMask.opacity = 0;
      _this.applyTheme();
      return _this;
    }
    RadarChart2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Radar chart");
      }
    };
    RadarChart2.prototype.processAxis = function(axis) {
      _super.prototype.processAxis.call(this, axis);
      var renderer = axis.renderer;
      renderer.gridContainer.parent = renderer;
      renderer.breakContainer.parent = renderer;
      axis.parent = this.radarContainer;
      renderer.toBack();
    };
    RadarChart2.prototype.handleXAxisRangeChange = function() {
      _super.prototype.handleXAxisRangeChange.call(this);
      each3(this.yAxes.iterator(), function(axis) {
        axis.invalidate();
      });
    };
    RadarChart2.prototype.handleYAxisRangeChange = function() {
      _super.prototype.handleYAxisRangeChange.call(this);
      each3(this.xAxes.iterator(), function(axis) {
        axis.invalidate();
      });
    };
    RadarChart2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config.cursor) && !hasValue(config.cursor.type)) {
          config.cursor.type = "RadarCursor";
        }
        if (hasValue(config.series) && isArray(config.series)) {
          for (var i = 0, len = config.series.length; i < len; i++) {
            config.series[i].type = config.series[i].type || "RadarSeries";
          }
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    RadarChart2.prototype.beforeDraw = function() {
      _super.prototype.beforeDraw.call(this);
      var plotContainer = this.plotContainer;
      var rect = getArcRect(this.startAngle, this.endAngle, 1);
      var innerRect = { x: 0, y: 0, width: 0, height: 0 };
      var wr = plotContainer.innerWidth / rect.width;
      var hr = plotContainer.innerHeight / rect.height;
      var innerRadius = this.innerRadius;
      if (innerRadius instanceof Percent) {
        var value = innerRadius.value;
        var mr = Math.min(wr, hr);
        this.mr = mr;
        value = Math.max(mr * value, mr - Math.min(plotContainer.innerHeight, plotContainer.innerWidth)) / mr;
        innerRect = getArcRect(this.startAngle, this.endAngle, value);
        this.innerRadiusModifyer = value / innerRadius.value;
        innerRadius = percent(value * 100);
      }
      rect = getCommonRectangle([rect, innerRect]);
      var maxRadius = Math.min(plotContainer.innerWidth / rect.width, plotContainer.innerHeight / rect.height);
      var diameter = relativeRadiusToValue(this.radius, maxRadius) * 2 || 0;
      var radius = diameter / 2;
      var startAngle = this.startAngle;
      var endAngle = this.endAngle;
      this._pixelInnerRadius = relativeRadiusToValue(innerRadius, radius);
      this._bulletMask.path = arc(startAngle, endAngle - startAngle, radius, this._pixelInnerRadius);
      each3(this.xAxes.iterator(), function(axis) {
        if (axis.renderer.useChartAngles) {
          axis.renderer.startAngle = startAngle;
          axis.renderer.endAngle = endAngle;
        }
        axis.width = diameter;
        axis.height = diameter;
        axis.renderer.pixelRadiusReal = radius;
      });
      each3(this.yAxes.iterator(), function(axis) {
        axis.renderer.startAngle = startAngle;
        axis.renderer.endAngle = endAngle;
        axis.width = diameter;
        axis.height = diameter;
        axis.renderer.pixelRadiusReal = radius;
      });
      var cursor = this.cursor;
      if (cursor) {
        cursor.width = diameter;
        cursor.height = diameter;
        cursor.startAngle = startAngle;
        cursor.endAngle = endAngle;
      }
      this.radarContainer.definedBBox = { x: radius * rect.x, y: radius * rect.y, width: radius * rect.width, height: radius * rect.height };
      this.radarContainer.validatePosition();
    };
    RadarChart2.prototype.createSeries = function() {
      return new RadarSeries();
    };
    Object.defineProperty(RadarChart2.prototype, "startAngle", {
      /**
       * @return Start angle (degrees)
       */
      get: function() {
        return this.getPropertyValue("startAngle");
      },
      /**
       * Starting angle of the Radar face. (degrees)
       *
       * Normally, a circular radar face begins (the radial axis is drawn) at the
       * top center. (at -90 degrees)
       *
       * You can use `startAngle` to change this setting.
       *
       * E.g. setting this to 0 will make the radial axis start horizontally to
       * the right, as opposed to vertical.
       *
       * For a perfect circle the absolute sum of `startAngle` and `endAngle`
       * needs to be 360.
       *
       * However, it's **not** necessary to do so. You can set those to lesser
       * numbers, to create semi-circles.
       *
       * E.g. `startAngle = -90` with `endAngle = 0` will create a radar face that
       * looks like a quarter of a circle.
       *
       * @default -90
       * @param value  Start angle (degrees)
       */
      set: function(value) {
        this.setPropertyValue("startAngle", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RadarChart2.prototype, "endAngle", {
      /**
       * @return End angle (degrees)
       */
      get: function() {
        return this.getPropertyValue("endAngle");
      },
      /**
       * Starting angle of the Radar face. (degrees)
       *
       * Normally, a circular radar face ends (the radial axis is drawn) exactly
       * where it has started, forming a full 360 circle. (at 270 degrees)
       *
       * You can use `endAngle` to end the circle somewhere else.
       *
       * E.g. setting this to 180 will make the radar face end at horizontal line
       * to the left off the center.
       *
       * For a perfect circle the absolute sum of `startAngle` and `endAngle`
       * needs to be 360.
       *
       * However, it's **not** necessary to do so. You can set those to lesser
       * numbers, to create semi-circles.
       *
       * E.g. `startAngle = -90` with `endAngle = 0` will create a radar face that
       * looks like a quarter of a circle.
       *
       * @default -90
       * @param value  End angle (degrees)
       */
      set: function(value) {
        this.setPropertyValue("endAngle", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RadarChart2.prototype, "radius", {
      /**
       * @return Outer radius
       */
      get: function() {
        return this.getPropertyValue("radius");
      },
      /**
       * Outer radius of the Radar face.
       *
       * This can either be in absolute pixel value, or relative [[Percent]].
       *
       * @param value  Outer radius
       */
      set: function(value) {
        this.setPercentProperty("radius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RadarChart2.prototype, "pixelInnerRadius", {
      /**
       * @return Inner radius in pixels
       */
      get: function() {
        return this._pixelInnerRadius;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RadarChart2.prototype, "innerRadius", {
      /**
       * @return Inner radius
       */
      get: function() {
        return this.getPropertyValue("innerRadius");
      },
      /**
       * Inner radius of the radar face.
       *
       * This can either be in absolute pixel value, or relative [[Percent]].
       *
       * If set in Percent, it will be relative to `radius`. (outer radius)
       *
       * @param value Inner radius
       */
      set: function(value) {
        this.setPercentProperty("innerRadius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    RadarChart2.prototype.updateXAxis = function(renderer) {
      if (renderer) {
        renderer.processRenderer();
      }
    };
    RadarChart2.prototype.updateYAxis = function(renderer) {
      if (renderer) {
        renderer.processRenderer();
      }
    };
    return RadarChart2;
  }(XYChart)
);
registry.registeredClasses["RadarChart"] = RadarChart;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/ClockHand.js
var ClockHand = (
  /** @class */
  function(_super) {
    __extends(ClockHand2, _super);
    function ClockHand2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._axis = new MutableValueDisposer();
      _this.className = "ClockHand";
      var interfaceColors = new InterfaceColorSet();
      _this.fill = interfaceColors.getFor("alternativeBackground");
      _this.stroke = _this.fill;
      var pin = new Circle();
      pin.radius = 5;
      _this.pin = pin;
      _this.isMeasured = false;
      _this.startWidth = 5;
      _this.endWidth = 1;
      _this.width = percent(100);
      _this.height = percent(100);
      _this.radius = percent(100);
      _this.innerRadius = percent(0);
      var hand = new Trapezoid();
      _this.hand = hand;
      _this._disposers.push(_this._axis);
      _this.applyTheme();
      return _this;
    }
    ClockHand2.prototype.validate = function() {
      _super.prototype.validate.call(this);
      var hand = this.hand;
      hand.width = this.pixelWidth;
      var h = Math.max(this.startWidth, this.endWidth);
      hand.height = h;
      hand.leftSide = percent(this.startWidth / h * 100);
      hand.rightSide = percent(this.endWidth / h * 100);
      if (this.axis) {
        var renderer = this.axis.renderer;
        var x0 = relativeRadiusToValue(this.innerRadius, renderer.pixelRadius);
        var x1 = relativeRadiusToValue(this.radius, renderer.pixelRadius);
        hand.x = x0;
        hand.y = -h / 2;
        hand.width = x1 - x0;
      }
    };
    Object.defineProperty(ClockHand2.prototype, "pin", {
      /**
       * @return Pin element
       */
      get: function() {
        return this._pin;
      },
      /**
       * A circle element used as hand's base. (pin)
       *
       * @param pin  Pin element
       */
      set: function(pin) {
        if (this._pin) {
          this.removeDispose(this._pin);
        }
        if (pin) {
          this._pin = pin;
          pin.parent = this;
          this._disposers.push(pin);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ClockHand2.prototype, "hand", {
      /**
       * @return Hand element
       */
      get: function() {
        return this._hand;
      },
      /**
       * A trapezoid shape used for hand itself.
       *
       * The shape of the trapezoid is controlled by ClockHand's `startWidth` and
       * `endWidth` properties.
       *
       * Set `endWidth` to 1 (px) to make it pointy.
       *
       * @param hand  Hand element
       */
      set: function(hand) {
        if (this._hand) {
          this.removeDispose(this._hand);
        }
        if (hand) {
          this._hand = hand;
          hand.parent = this;
          this._disposers.push(hand);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ClockHand2.prototype, "radius", {
      /**
       * @return Radius
       */
      get: function() {
        return this.getPropertyValue("radius");
      },
      /**
       * Radius of the hand's outer end. (tip)
       *
       * Absolute (px) or relative ([[Percent]]).
       *
       * @default Percent(0)
       * @param value  Radius
       */
      set: function(value) {
        this.setPercentProperty("radius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ClockHand2.prototype, "innerRadius", {
      /**
       * @return Radius
       */
      get: function() {
        return this.getPropertyValue("innerRadius");
      },
      /**
       * Radius of the hand's inner end. (base)
       *
       * Absolute (px) or relative ([[Percent]]).
       *
       * @default Percent(0)
       * @param value  Radius
       */
      set: function(value) {
        this.setPercentProperty("innerRadius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ClockHand2.prototype, "startWidth", {
      /**
       * @return Width (px)
       */
      get: function() {
        return this.getPropertyValue("startWidth");
      },
      /**
       * Width, in pixels, of the clock hand's inner end. (base)
       *
       * @default 5
       * @param value  Width (px)
       */
      set: function(value) {
        this.setPropertyValue("startWidth", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ClockHand2.prototype, "endWidth", {
      /**
       * @return Width (px)
       */
      get: function() {
        return this.getPropertyValue("endWidth");
      },
      /**
       * Width, in pixels, of the clock hand's outer end. (tip)
       *
       * @default 1
       * @param value  Width (px)
       */
      set: function(value) {
        this.setPropertyValue("endWidth", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ClockHand2.prototype, "rotationDirection", {
      /**
       * @return rotationDirection
       */
      get: function() {
        return this.getPropertyValue("rotationDirection");
      },
      /**
       * Rotation direction
       *
       * @default any
       * @param value
       */
      set: function(value) {
        this.setPropertyValue("rotationDirection", value);
      },
      enumerable: true,
      configurable: true
    });
    ClockHand2.prototype.showValue = function(value, duration, easing) {
      this._value = value;
      if (value != void 0) {
        if (!isNumber(duration)) {
          duration = 0;
        }
        if (this.axis) {
          var renderer = this.axis.renderer;
          var newAngle = renderer.positionToAngle(this.axis.anyToPosition(value));
          var currentAngle = this.rotation;
          if (this.rotationDirection == "clockWise") {
            if (newAngle < currentAngle) {
              this.rotation = currentAngle - 360;
            }
          }
          if (this.rotationDirection == "counterClockWise") {
            if (newAngle > currentAngle) {
              this.rotation = currentAngle + 360;
            }
          }
          this.animate({ property: "rotation", to: newAngle }, duration, easing);
        }
      }
    };
    Object.defineProperty(ClockHand2.prototype, "currentPosition", {
      /**
       * Returns hand's relative position on axis
       */
      get: function() {
        if (this.axis) {
          var renderer = this.axis.renderer;
          return renderer.angleToPosition(this.rotation);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ClockHand2.prototype, "value", {
      /**
       * @return Value
       */
      get: function() {
        return this._value;
      },
      /**
       * A current value clock hand is pointing to.
       *
       * @param value  Value
       */
      set: function(value) {
        this.showValue(value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ClockHand2.prototype, "axis", {
      /**
       * @return Axis
       */
      get: function() {
        return this._axis.get();
      },
      /**
       * An Axis clock hand is associated with.
       *
       * Hand's `value` relates to values on the Axis.
       *
       * @param axis  Axis
       */
      set: function(axis) {
        if (this.axis != axis) {
          this._axis.set(axis, new MultiDisposer([
            axis.events.on("datavalidated", this.updateValue, this, false),
            axis.events.on("datarangechanged", this.updateValue, this, false),
            axis.events.on("dataitemsvalidated", this.updateValue, this, false),
            axis.events.on("propertychanged", this.invalidate, this, false)
          ]));
        }
        if (axis) {
          var chart = axis.chart;
          if (chart) {
            this.rotation = chart.startAngle;
          }
        }
        this.parent = axis.renderer;
        this.zIndex = 5;
      },
      enumerable: true,
      configurable: true
    });
    ClockHand2.prototype.updateValue = function() {
      this.value = this.value;
    };
    ClockHand2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config.axis) && isString(config.axis) && this.map.hasKey(config.axis)) {
          config.axis = this.map.getKey(config.axis);
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    return ClockHand2;
  }(Container)
);
registry.registeredClasses["ClockHand"] = ClockHand;

// node_modules/@amcharts/amcharts4/.internal/charts/types/GaugeChart.js
var GaugeChartDataItem = (
  /** @class */
  function(_super) {
    __extends(GaugeChartDataItem2, _super);
    function GaugeChartDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "GaugeChartDataItem";
      _this.applyTheme();
      return _this;
    }
    return GaugeChartDataItem2;
  }(RadarChartDataItem)
);
var GaugeChart = (
  /** @class */
  function(_super) {
    __extends(GaugeChart2, _super);
    function GaugeChart2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "GaugeChart";
      _this.startAngle = 180;
      _this.endAngle = 360;
      _this.hands = new ListTemplate(new ClockHand());
      _this.hands.events.on("inserted", _this.processHand, _this, false);
      _this._disposers.push(new ListDisposer(_this.hands));
      _this._disposers.push(_this.hands.template);
      _this.applyTheme();
      return _this;
    }
    GaugeChart2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Gauge chart");
      }
    };
    GaugeChart2.prototype.processHand = function(event) {
      var hand = event.newValue;
      if (!hand.axis) {
        hand.axis = this.xAxes.getIndex(0);
      }
    };
    GaugeChart2.prototype.configOrder = function(a, b) {
      if (a == b) {
        return 0;
      } else if (a == "hands") {
        return 1;
      } else if (b == "hands") {
        return -1;
      } else {
        return _super.prototype.configOrder.call(this, a, b);
      }
    };
    return GaugeChart2;
  }(RadarChart)
);
registry.registeredClasses["GaugeChart"] = GaugeChart;

// node_modules/@amcharts/amcharts4/.internal/charts/series/PercentSeries.js
var PercentSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(PercentSeriesDataItem2, _super);
    function PercentSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "PercentSeriesDataItem";
      _this.applyTheme();
      return _this;
    }
    PercentSeriesDataItem2.prototype.uidAttr = function() {
      return this.slice.uidAttr();
    };
    PercentSeriesDataItem2.prototype.hide = function(duration, delay, toValue, fields) {
      if (!fields) {
        fields = ["value"];
      }
      return _super.prototype.hide.call(this, duration, delay, 0, fields);
    };
    PercentSeriesDataItem2.prototype.setVisibility = function(value, noChangeValues) {
      if (!noChangeValues) {
        if (value) {
          this.setWorkingValue("value", this.values["value"].value, 0, 0);
        } else {
          this.setWorkingValue("value", 0, 0, 0);
        }
      }
      _super.prototype.setVisibility.call(this, value, noChangeValues);
    };
    PercentSeriesDataItem2.prototype.show = function(duration, delay, fields) {
      if (!fields) {
        fields = ["value"];
      }
      return _super.prototype.show.call(this, duration, delay, fields);
    };
    Object.defineProperty(PercentSeriesDataItem2.prototype, "category", {
      /**
       * @return Category
       */
      get: function() {
        return this.properties.category;
      },
      /**
       * Category.
       *
       * @param value  Category
       */
      set: function(value) {
        this.setProperty("category", value);
      },
      enumerable: true,
      configurable: true
    });
    PercentSeriesDataItem2.prototype.createLegendMarker = function(marker) {
      this.component.createLegendMarker(marker, this);
    };
    Object.defineProperty(PercentSeriesDataItem2.prototype, "legendDataItem", {
      /**
       * @return Legend data item
       */
      get: function() {
        return this._legendDataItem;
      },
      /**
       * A legend's data item, that corresponds to this data item.
       *
       * @param value  Legend data item
       */
      set: function(value) {
        this._legendDataItem = value;
        if (value.label) {
          value.label.dataItem = this;
        }
        if (value.valueLabel) {
          value.valueLabel.dataItem = this;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PercentSeriesDataItem2.prototype, "tick", {
      /**
       * A Tick element, related to this data item. (slice)
       *
       * @readonly
       * @return Tick element
       */
      get: function() {
        var _this = this;
        if (!this._tick) {
          var tick_1 = this.component.ticks.create();
          this._tick = tick_1;
          this.addSprite(tick_1);
          this._disposers.push(tick_1);
          tick_1.parent = this.component.ticksContainer;
          this._disposers.push(new Disposer(function() {
            if (_this.component) {
              _this.component.ticks.removeValue(tick_1);
            }
          }));
          tick_1.visible = this.visible;
        }
        return this._tick;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PercentSeriesDataItem2.prototype, "label", {
      /**
       * A Label element, related to this data item. (slice)
       *
       * @readonly
       * @return Label element
       */
      get: function() {
        var _this = this;
        if (!this._label) {
          var label_1 = this.component.labels.create();
          this.addSprite(label_1);
          this._label = label_1;
          this._disposers.push(label_1);
          label_1.parent = this.component.labelsContainer;
          this._disposers.push(new Disposer(function() {
            if (_this.component) {
              _this.component.labels.removeValue(label_1);
            }
          }));
          label_1.visible = this.visible;
        }
        return this._label;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PercentSeriesDataItem2.prototype, "slice", {
      /**
       * An element, related to this data item. (slice)
       *
       * @readonly
       * @return Slice element
       */
      get: function() {
        var _this = this;
        if (!this._slice) {
          var component_1 = this.component;
          var slice_1 = component_1.slices.create();
          this.addSprite(slice_1);
          this._slice = slice_1;
          this._disposers.push(slice_1);
          slice_1.parent = component_1.slicesContainer;
          this._disposers.push(new Disposer(function() {
            component_1.slices.removeValue(slice_1);
          }));
          slice_1.visible = this.visible;
          if (component_1.itemsFocusable()) {
            if (!hasValue(this.component.role)) {
              this.component.role = "menu";
            }
            if (!hasValue(slice_1.role)) {
              slice_1.role = "menuitem";
            }
            slice_1.focusable = true;
          } else {
            if (!hasValue(this.component.role)) {
              this.component.role = "list";
            }
            if (!hasValue(slice_1.role)) {
              slice_1.role = "listitem";
            }
            slice_1.focusable = false;
          }
          if (slice_1.focusable) {
            slice_1.events.on("focus", function(ev) {
              slice_1.readerTitle = component_1.populateString(component_1.itemReaderText, _this);
            }, void 0, false);
            slice_1.events.on("blur", function(ev) {
              slice_1.readerTitle = "";
            }, void 0, false);
          }
          if (slice_1.hoverable) {
            slice_1.events.on("over", function(ev) {
              slice_1.readerTitle = component_1.populateString(component_1.itemReaderText, _this);
            }, void 0, false);
            slice_1.events.on("out", function(ev) {
              slice_1.readerTitle = "";
            }, void 0, false);
          }
        }
        return this._slice;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PercentSeriesDataItem2.prototype, "hiddenInLegend", {
      /**
       * @return Disabled in legend?
       */
      get: function() {
        return this.properties.hiddenInLegend;
      },
      /**
       * Should dataItem (slice) be hidden in legend?
       *
       * @param value Visible in legend?
       */
      set: function(value) {
        this.setProperty("hiddenInLegend", value);
      },
      enumerable: true,
      configurable: true
    });
    return PercentSeriesDataItem2;
  }(SeriesDataItem)
);
var PercentSeries = (
  /** @class */
  function(_super) {
    __extends(PercentSeries2, _super);
    function PercentSeries2() {
      var _this = _super.call(this) || this;
      _this.className = "PercentSeries";
      _this._addAllDataItems = false;
      _this.colors = new ColorSet();
      _this.colors.step = 1;
      _this.isMeasured = true;
      _this.calculatePercent = true;
      var slicesContainer = _this.createChild(Container);
      slicesContainer.shouldClone = false;
      slicesContainer.isMeasured = false;
      _this.slicesContainer = slicesContainer;
      var ticksContainer = _this.createChild(Container);
      ticksContainer.shouldClone = false;
      ticksContainer.isMeasured = false;
      ticksContainer.layout = "none";
      _this.ticksContainer = ticksContainer;
      var labelsContainer = _this.createChild(Container);
      labelsContainer.shouldClone = false;
      labelsContainer.isMeasured = false;
      labelsContainer.layout = "none";
      _this.labelsContainer = labelsContainer;
      _this.alignLabels = false;
      _this.bulletsContainer.toFront();
      _this.skipFocusThreshold = 50;
      var defaultState = _this.defaultState;
      defaultState.transitionEasing = sinOut;
      _this.itemReaderText = "{category}: {value.percent.formatNumber('#.#p')}";
      _this.applyTheme();
      return _this;
    }
    PercentSeries2.prototype.createSlice = function() {
      return new Sprite();
    };
    PercentSeries2.prototype.createTick = function() {
      return new Tick();
    };
    PercentSeries2.prototype.createLabel = function() {
      return new Label();
    };
    Object.defineProperty(PercentSeries2.prototype, "slices", {
      /**
       * A list of slice elements for the series.
       *
       * Use its `template` to configure look and behavior of the slices. E.g.:
       *
       * ```TypeScript
       * series.slices.template.stroke = am4core.color("#fff");
       * series.slices.template.strokeWidth = 2;
       * ```
       * ```JavaScript
       * series.slices.template.stroke = am4core.color("#fff");
       * series.slices.template.strokeWidth = 2;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "series": [{
       *     // ...
       *     "slices": {
       *       "stroke": "#fff",
       *       "strokeWidth": 2
       *     }
       *   }]
       * }
       * ```
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/list-templates/} for more information about list templates
       * @return Slices
       */
      get: function() {
        if (!this._slices) {
          var slice = this.createSlice();
          slice.applyOnClones = true;
          this._disposers.push(slice);
          this.initSlice(slice);
          this._slices = new ListTemplate(slice);
          this._disposers.push(new ListDisposer(this._slices));
        }
        return this._slices;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PercentSeries2.prototype, "ticks", {
      /**
       * A list of tick elements for the series. Ticks connect slice to its label.
       *
       * Use its `template` to configure look and behavior of the ticks. E.g.:
       *
       * ```TypeScript
       * series.ticks.template.strokeWidth = 2;
       * ```
       * ```JavaScript
       * series.ticks.template.strokeWidth = 2;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "series": [{
       *     // ...
       *     "ticks": {
       *       "strokeWidth": 2
       *     }
       *   }]
       * }
       * ```
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/list-templates/} for more information about list templates
       * @return Ticks
       */
      get: function() {
        if (!this._ticks) {
          var tick = this.createTick();
          tick.applyOnClones = true;
          this._disposers.push(tick);
          this.initTick(tick);
          this._ticks = new ListTemplate(tick);
          this._disposers.push(new ListDisposer(this._ticks));
        }
        return this._ticks;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PercentSeries2.prototype, "labels", {
      /**
       * A list of slice label elements for the series.
       *
       * Use its `template` to configure look and behavior of the labels. E.g.:
       *
       * ```TypeScript
       * series.labels.template.fill = am4core.color("#c00");
       * series.labels.template.fontSize = 20;
       * ```
       * ```JavaScript
       * series.labels.template.fill = am4core.color("#c00");
       * series.labels.template.fontSize = 20;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "series": [{
       *     // ...
       *     "labels": {
       *       "stroke": "#c00",
       *       "fontSize": 20
       *     }
       *   }]
       * }
       * ```
       *
       * @see {@link https://www.amcharts.com/docs/v4/concepts/list-templates/} for more information about list templates
       * @return Labels
       */
      get: function() {
        if (!this._labels) {
          var label = this.createLabel();
          label.applyOnClones = true;
          this._disposers.push(label);
          this.initLabel(label);
          this._labels = new ListTemplate(label);
          this._disposers.push(new ListDisposer(this._labels));
        }
        return this._labels;
      },
      enumerable: true,
      configurable: true
    });
    PercentSeries2.prototype.createDataItem = function() {
      return new PercentSeriesDataItem();
    };
    PercentSeries2.prototype.initSlice = function(slice) {
    };
    PercentSeries2.prototype.initLabel = function(label) {
      label.text = "{category}: {value.percent.formatNumber('#.0p')}";
      label.isMeasured = false;
      label.padding(5, 5, 5, 5);
    };
    PercentSeries2.prototype.initTick = function(label) {
    };
    PercentSeries2.prototype.validateDataItems = function() {
      this.colors.reset();
      if (this.patterns) {
        this.patterns.reset();
      }
      _super.prototype.validateDataItems.call(this);
    };
    PercentSeries2.prototype.validateDataElement = function(dataItem) {
      var slice = dataItem.slice;
      if (slice) {
        if (slice.fill == void 0) {
          if (this.patterns) {
            if (!hasValue(slice.stroke)) {
              slice.stroke = this.colors.next();
            }
            slice.fill = this.patterns.next();
            if (hasValue(slice.fillOpacity)) {
              slice.fill.backgroundOpacity = slice.fillOpacity;
            }
            if (slice.stroke instanceof Color) {
              slice.fill.stroke = slice.stroke;
              slice.fill.fill = slice.stroke;
            }
          } else {
            slice.fill = this.colors.next();
          }
        } else {
          this.colors.currentStep += this.colors.step;
        }
        if (slice.stroke == void 0) {
          slice.stroke = slice.fill;
        }
      }
      _super.prototype.validateDataElement.call(this, dataItem);
      if (slice) {
        dataItem.bullets.each(function(key, bullet) {
          if (bullet.fill == void 0) {
            bullet.fill = slice.fill;
          }
          if (bullet.stroke == void 0) {
            bullet.stroke = slice.stroke;
          }
        });
      }
      this.updateLegendValue(dataItem);
    };
    PercentSeries2.prototype.validateData = function() {
      _super.prototype.validateData.call(this);
      if (this.chart) {
        this.chart.feedLegend();
      }
    };
    PercentSeries2.prototype.arrangeLabels = function(dataItems) {
      for (var i = 0, len = dataItems.length; i < len; i++) {
        var dataItem = dataItems[i];
        var label = dataItem.label;
        if (label) {
          if (label.invalid) {
            label.validate();
          }
          var lh = label.measuredHeight;
          if (!label.visible) {
            lh = 0;
          }
          if (label.pixelY - lh / 2 < -this.maxHeight / 2) {
            label.y = -this.maxHeight / 2 + lh / 2;
          }
          var nextLabel = this.getNextLabel(i + 1, dataItems);
          var bottom = label.pixelY + lh / 2;
          if (nextLabel) {
            if (nextLabel.invalid) {
              nextLabel.validate();
            }
            var nextLabelHeight = nextLabel.measuredHeight;
            if (!nextLabel.visible) {
              nextLabelHeight = 0;
            }
            var nextLabelY = nextLabel.pixelY;
            if (nextLabelY == null) {
              nextLabelY = 0;
            }
            if (nextLabelY - nextLabelHeight / 2 < bottom) {
              nextLabel.y = bottom + nextLabelHeight / 2;
            }
          }
        }
      }
    };
    PercentSeries2.prototype.arrangeLabels2 = function(dataItems) {
      var previousTop = this.maxHeight / 2;
      for (var i = dataItems.length - 1; i >= 0; i--) {
        var dataItem = dataItems[i];
        var label = dataItem.label;
        if (label) {
          if (label.invalid) {
            label.validate();
          }
          var lh = label.measuredHeight;
          if (!label.visible) {
            lh = 0;
          }
          if (label.pixelY + lh / 2 > previousTop) {
            label.y = previousTop - lh / 2;
            previousTop = label.y - lh / 2;
          }
        }
      }
    };
    PercentSeries2.prototype.getNextLabel = function(index, dataItems) {
      if (dataItems.length >= index) {
        var nextDataItem = dataItems[index];
        if (nextDataItem) {
          if (nextDataItem.label) {
            if (nextDataItem.visible) {
              return nextDataItem.label;
            } else {
              return this.getNextLabel(index + 1, dataItems);
            }
          } else {
            return this.getNextLabel(index + 1, dataItems);
          }
        }
      }
    };
    Object.defineProperty(PercentSeries2.prototype, "colors", {
      /**
       * @return Color set
       */
      get: function() {
        return this.getPropertyValue("colors");
      },
      /**
       * A color set to be used for slices.
       *
       * For each new subsequent slice, the chart will assign the next color in
       * this set.
       *
       * @param value  Color set
       */
      set: function(value) {
        this.setPropertyValue("colors", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PercentSeries2.prototype, "patterns", {
      /**
       * @return Pattern set
       */
      get: function() {
        return this.getPropertyValue("patterns");
      },
      /**
       * A [[PatternSet]] to use when creating patterned fills for slices.
       *
       * @since 4.7.5
       * @param value  Pattern set
       */
      set: function(value) {
        this.setPropertyValue("patterns", value, true);
      },
      enumerable: true,
      configurable: true
    });
    PercentSeries2.prototype.createLegendMarker = function(marker, dataItem) {
      each3(marker.children.iterator(), function(child) {
        var slice = dataItem.slice;
        child.defaultState.properties.fill = slice.fill;
        child.defaultState.properties.stroke = slice.stroke;
        child.defaultState.properties.fillOpacity = slice.fillOpacity;
        child.defaultState.properties.strokeOpacity = slice.strokeOpacity;
        child.fill = slice.fill;
        child.stroke = slice.stroke;
        child.fillOpacity = slice.fillOpacity;
        child.strokeOpacity = slice.strokeOpacity;
        if (child.fill == void 0) {
          child.__disabled = true;
        }
        var legendDataItem = marker.dataItem;
        legendDataItem.color = slice.fill;
        legendDataItem.colorOrig = slice.fill;
        child.addDisposer(slice.events.on("propertychanged", function(ev) {
          if (ev.property == "fill") {
            child.__disabled = false;
            if (!child.isActive) {
              child.fill = slice.fill;
            }
            child.defaultState.properties.fill = slice.fill;
            legendDataItem.color = slice.fill;
            legendDataItem.colorOrig = slice.fill;
          }
          if (ev.property == "stroke") {
            if (!child.isActive) {
              child.stroke = slice.stroke;
            }
            child.defaultState.properties.stroke = slice.stroke;
          }
          if (ev.property == "strokeOpacity") {
            if (!child.isActive) {
              child.strokeOpacity = slice.strokeOpacity;
            }
            child.defaultState.properties.strokeOpacity = slice.strokeOpacity;
          }
        }, void 0, false));
      });
    };
    PercentSeries2.prototype.handleSliceScale = function(event) {
      var _this = this;
      var slice = event.target;
      var dataItem = slice.dataItem;
      if (dataItem && dataItem.bullets) {
        each3(dataItem.bullets.iterator(), function(a) {
          var value = a[1];
          _this.positionBullet(value);
        });
      }
    };
    PercentSeries2.prototype.handleSliceMove = function(event) {
    };
    PercentSeries2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.slices.template.copyFrom(source.slices.template);
      this.labels.template.copyFrom(source.labels.template);
      this.ticks.template.copyFrom(source.ticks.template);
      this.colors = source.colors.clone();
    };
    Object.defineProperty(PercentSeries2.prototype, "alignLabels", {
      /**
       * @return Align labels?
       */
      get: function() {
        return this.getPropertyValue("alignLabels");
      },
      /**
       * Align labels into nice vertical columns?
       *
       * This will ensure that labels never overlap with each other.
       *
       * Arranging labels into columns makes them more readble, and better user
       * experience.
       *
       * If set to `false` labels will be positioned at `label.radius` distance,
       * and may, in some cases, overlap.
       *
       * @default true
       * @param value  Align labels?
       */
      set: function(value) {
        this.setAlignLabels(value);
      },
      enumerable: true,
      configurable: true
    });
    PercentSeries2.prototype.setAlignLabels = function(value) {
      this.setPropertyValue("alignLabels", value, true);
    };
    Object.defineProperty(PercentSeries2.prototype, "ignoreZeroValues", {
      /**
       * @return Ignore zero values
       */
      get: function() {
        return this.getPropertyValue("ignoreZeroValues");
      },
      /**
       * If set to `true` the chart will not show slices with zero values.
       *
       * @default false
       * @since 4.7.9
       * @param  value  Ignore zero values
       */
      set: function(value) {
        this.setPropertyValue("ignoreZeroValues", value, true);
      },
      enumerable: true,
      configurable: true
    });
    PercentSeries2.prototype.updateLegendValue = function(dataItem) {
      if (dataItem) {
        var legendDataItem = dataItem.legendDataItem;
        var legendSettings = dataItem.legendSettings;
        if (legendDataItem && legendSettings) {
          if (legendSettings) {
            if (legendSettings.labelText) {
              legendDataItem.label.text = legendSettings.labelText;
            }
            if (legendSettings.itemLabelText) {
              legendDataItem.label.text = legendSettings.itemLabelText;
            }
            if (legendSettings.valueText) {
              legendDataItem.valueLabel.text = legendSettings.valueText;
            }
            if (legendSettings.itemValueText) {
              legendDataItem.valueLabel.text = legendSettings.itemValueText;
            }
          }
        }
      }
    };
    return PercentSeries2;
  }(Series)
);
registry.registeredClasses["PercentSeries"] = PercentSeries;
registry.registeredClasses["PercentSeriesDataItem"] = PercentSeriesDataItem;
defaultRules.push({
  relevant: ResponsiveBreakpoints.maybeXS,
  state: function(target, stateId) {
    if (target instanceof PercentSeries) {
      var state = target.states.create(stateId);
      var labelState = target.labels.template.states.create(stateId);
      labelState.properties.disabled = true;
      var tickState = target.ticks.template.states.create(stateId);
      tickState.properties.disabled = true;
      return state;
    }
    return null;
  }
});

// node_modules/@amcharts/amcharts4/.internal/charts/types/PercentChart.js
var PercentChartDataItem = (
  /** @class */
  function(_super) {
    __extends(PercentChartDataItem2, _super);
    function PercentChartDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "PercentChartDataItem";
      _this.applyTheme();
      return _this;
    }
    return PercentChartDataItem2;
  }(SerialChartDataItem)
);
var PercentChart = (
  /** @class */
  function(_super) {
    __extends(PercentChart2, _super);
    function PercentChart2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "PercentChart";
      _this.align = "none";
      _this.valign = "none";
      _this.chartContainer.minHeight = 50;
      _this.chartContainer.minWidth = 50;
      _this.applyTheme();
      return _this;
    }
    PercentChart2.prototype.validateData = function() {
      _super.prototype.validateData.call(this);
      this.feedLegend();
    };
    PercentChart2.prototype.feedLegend = function() {
      var legend = this.legend;
      if (legend) {
        var legendData_1 = [];
        each3(this.series.iterator(), function(series) {
          if (!series.hiddenInLegend) {
            each3(series.dataItems.iterator(), function(dataItem) {
              if (!dataItem.hiddenInLegend) {
                legendData_1.push(dataItem);
                if (!dataItem.legendSettings) {
                  dataItem.legendSettings = series.legendSettings;
                }
              }
            });
          }
        });
        legend.data = legendData_1;
        legend.dataFields.name = "category";
      }
    };
    PercentChart2.prototype.createSeries = function() {
      return new PercentSeries();
    };
    PercentChart2.prototype.setLegend = function(legend) {
      _super.prototype.setLegend.call(this, legend);
      if (legend) {
        legend.labels.template.text = "{category}";
        legend.valueLabels.template.text = "{value.percent.formatNumber('#.0p')}";
        legend.itemContainers.template.events.on("over", function(event) {
          var percentSeriesDataItem = event.target.dataItem.dataContext;
          if (percentSeriesDataItem.visible && !percentSeriesDataItem.isHiding) {
            var slice = percentSeriesDataItem.slice;
            slice.dispatchImmediately("over");
            slice.isHover = true;
            slice.interactions.isRealHover = true;
          }
        });
        legend.itemContainers.template.events.on("out", function(event) {
          var percentSeriesDataItem = event.target.dataItem.dataContext;
          var slice = percentSeriesDataItem.slice;
          slice.dispatchImmediately("out");
          slice.isHover = false;
        });
      }
    };
    return PercentChart2;
  }(SerialChart)
);
registry.registeredClasses["PercentChart"] = PercentChart;
registry.registeredClasses["PercentChartDataItem"] = PercentChartDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/PieTick.js
var PieTick = (
  /** @class */
  function(_super) {
    __extends(PieTick2, _super);
    function PieTick2() {
      var _this = _super.call(this) || this;
      _this._label = new MutableValueDisposer();
      _this._slice = new MutableValueDisposer();
      _this.className = "PieTick";
      _this.element = _this.paper.add("polyline");
      _this._disposers.push(_this._label);
      _this._disposers.push(_this._slice);
      _this.applyTheme();
      return _this;
    }
    PieTick2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      var slice = this.slice;
      var label = this.label;
      var series = slice.dataItem.component;
      if (slice && slice.radius > 0 && label && label.text) {
        var x0 = slice.dx + slice.slice.dx + slice.pixelX + slice.ix * slice.radius * slice.scale;
        var y0 = slice.dy + slice.slice.dy + slice.pixelY + slice.iy * slice.radiusY * slice.scale;
        var x1 = void 0;
        var y1 = void 0;
        var x2 = void 0;
        var y2 = void 0;
        if (series.alignLabels) {
          x1 = label.pixelX - this.length;
          y1 = label.pixelY;
          x2 = label.pixelX;
          y2 = y1;
          if (label.horizontalCenter == "right") {
            x1 += 2 * this.length;
            x2 = x1 - this.length;
          }
        } else {
          var r = label.pixelRadius(slice.radius);
          x1 = x0 + r * slice.ix;
          y1 = y0 + r * slice.iy;
          x2 = x1;
          y2 = y1;
        }
        this.element.attr({ "points": [x0, y0, x1, y1, x2, y2] });
      }
    };
    Object.defineProperty(PieTick2.prototype, "slice", {
      /**
       * @return Slice
       */
      get: function() {
        return this._slice.get();
      },
      /**
       * Slice element tick is attached to.
       *
       * @param slice  Slice
       */
      set: function(slice) {
        this._slice.set(slice, new MultiDisposer([
          slice.events.on("transformed", this.invalidate, this),
          slice.events.on("validated", this.invalidate, this)
        ]));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PieTick2.prototype, "label", {
      /**
       * @return Label
       */
      get: function() {
        return this._label.get();
      },
      /**
       * Label element tick is attached to.
       *
       * @param label  Label
       */
      set: function(label) {
        this._label.set(label, label.events.on("transformed", this.invalidate, this, false));
      },
      enumerable: true,
      configurable: true
    });
    return PieTick2;
  }(Tick)
);
registry.registeredClasses["PieTick"] = PieTick;

// node_modules/@amcharts/amcharts4/.internal/charts/series/PieSeries.js
var PieSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(PieSeriesDataItem2, _super);
    function PieSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "PieSeriesDataItem";
      _this.values.radiusValue = {};
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(PieSeriesDataItem2.prototype, "radiusValue", {
      /**
       * @return Radius
       */
      get: function() {
        return this.values.radiusValue.value;
      },
      /**
       * Slice's radius, if other than default.
       *
       * @param value  Radius
       */
      set: function(value) {
        this.setValue("radiusValue", value);
      },
      enumerable: true,
      configurable: true
    });
    PieSeriesDataItem2.prototype.hide = function(duration, delay, toValue, fields) {
      return _super.prototype.hide.call(this, duration, delay, 0, ["value", "radiusValue"]);
    };
    PieSeriesDataItem2.prototype.show = function(duration, delay, fields) {
      return _super.prototype.show.call(this, duration, delay, ["value", "radiusValue"]);
    };
    return PieSeriesDataItem2;
  }(PercentSeriesDataItem)
);
var PieSeries = (
  /** @class */
  function(_super) {
    __extends(PieSeries2, _super);
    function PieSeries2() {
      var _this = _super.call(this) || this;
      _this.className = "PieSeries";
      _this.alignLabels = true;
      _this.layout = "none";
      _this.labels.template.radius = percent(5);
      _this.addDisposer(_this.labels.template.events.on("enabled", _this.invalidate, _this, false));
      _this.applyTheme();
      return _this;
    }
    PieSeries2.prototype.createSlice = function() {
      return new Slice();
    };
    PieSeries2.prototype.createTick = function() {
      return new PieTick();
    };
    PieSeries2.prototype.createLabel = function() {
      return new AxisLabelCircular();
    };
    PieSeries2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Pie Slice Series");
      }
    };
    PieSeries2.prototype.createDataItem = function() {
      return new PieSeriesDataItem();
    };
    PieSeries2.prototype.initSlice = function(slice) {
      slice.isMeasured = false;
      slice.defaultState.properties.scale = 1;
      slice.observe("scale", this.handleSliceScale, this);
      slice.observe(["dx", "dy", "x", "y", "shiftRadius"], this.handleSliceMove, this);
      slice.tooltipText = "{category}: {value.percent.formatNumber('#.#p')} ({value.value})";
      var hoverState = slice.states.create("hover");
      hoverState.properties.scale = 1.05;
      var defaultState = slice.defaultState;
      defaultState.properties.shiftRadius = 0;
      slice.togglable = true;
      slice.events.on("toggled", function(event) {
        event.target.hideTooltip();
        if (event.target.interactions.lastHitPointer && event.target.interactions.lastHitPointer.touch && !event.target.isActive) {
          event.target.isHover = false;
        }
      });
      var activeState = slice.states.create("active");
      activeState.properties.shiftRadius = 0.1;
    };
    PieSeries2.prototype.validate = function() {
      this._leftItems = [];
      this._rightItems = [];
      this._currentStartAngle = this.startAngle;
      this._arcRect = getArcRect(this.startAngle, this.endAngle);
      this._maxRadiusPercent = 0;
      for (var i = this.startIndex; i < this.endIndex; i++) {
        var dataItem = this.dataItems.getIndex(i);
        var radiusValuePercent = dataItem.values.radiusValue.percent;
        if (radiusValuePercent > this._maxRadiusPercent) {
          this._maxRadiusPercent = radiusValuePercent;
        }
      }
      _super.prototype.validate.call(this);
      if (this.alignLabels) {
        if (this.startAngle > this.endAngle) {
          this._rightItems.reverse();
        } else {
          this._leftItems.reverse();
        }
        this._rightItems.sort(function(a, b) {
          var aAngle = (a.slice.middleAngle + 360) % 360;
          var bAngle = (b.slice.middleAngle + 360) % 360;
          if (aAngle > 270) {
            aAngle -= 360;
          }
          if (bAngle > 270) {
            bAngle -= 360;
          }
          if (aAngle < bAngle) {
            return -1;
          } else if (aAngle > bAngle) {
            return 1;
          } else {
            return 0;
          }
        });
        this._leftItems.sort(function(a, b) {
          var aAngle = (a.slice.middleAngle + 360) % 360;
          var bAngle = (b.slice.middleAngle + 360) % 360;
          if (aAngle < bAngle) {
            return 1;
          } else if (aAngle > bAngle) {
            return -1;
          } else {
            return 0;
          }
        });
        this.arrangeLabels(this._rightItems);
        this.arrangeLabels2(this._rightItems);
        this.arrangeLabels(this._leftItems);
        this.arrangeLabels2(this._leftItems);
      }
    };
    PieSeries2.prototype.validateDataElement = function(dataItem) {
      if (this.pixelRadius > 0) {
        if (this.ignoreZeroValues && (dataItem.value == 0 || dataItem.value == null)) {
          dataItem.__disabled = true;
        } else {
          dataItem.__disabled = false;
        }
        var slice = dataItem.slice;
        slice.radius = this.pixelRadius;
        if (isNumber(dataItem.radiusValue)) {
          slice.radius = this.pixelInnerRadius + (this.pixelRadius - this.pixelInnerRadius) * dataItem.values.radiusValue.percent / this._maxRadiusPercent;
        }
        if (!(slice.innerRadius instanceof Percent)) {
          slice.innerRadius = this.pixelInnerRadius;
        }
        slice.startAngle = this._currentStartAngle;
        slice.arc = Math.abs(dataItem.values.value.percent) * (this.endAngle - this.startAngle) / 100;
        if (!this.labels.template.disabled) {
          var label = dataItem.label;
          var tick = dataItem.tick;
          tick.slice = slice;
          tick.label = label;
          var normalizedMiddleAngle = (slice.middleAngle + 360) % 360;
          var point = void 0;
          if (this.alignLabels) {
            var labelRadius = label.pixelRadius(slice.radius);
            var x = tick.length + labelRadius;
            label.dx = 0;
            label.dy = 0;
            label.verticalCenter = "middle";
            var arcRect = this._arcRect;
            if (normalizedMiddleAngle > 270 || normalizedMiddleAngle <= 90) {
              x += (arcRect.width + arcRect.x) * this.pixelRadius;
              label.horizontalCenter = "left";
              this._rightItems.push(dataItem);
            } else {
              x -= arcRect.x * this.pixelRadius;
              label.horizontalCenter = "right";
              this._leftItems.push(dataItem);
              x *= -1;
            }
            var distance = slice.radius + tick.length + labelRadius;
            point = { x, y: slice.iy * distance };
            label.moveTo(point);
          } else {
            var depth = slice["depth"];
            if (!isNumber(depth)) {
              depth = 0;
            }
            label.fixPosition(slice.middleAngle, slice.radius, slice.radiusY, 0, -depth);
          }
        }
        this._currentStartAngle += slice.arc;
        _super.prototype.validateDataElement.call(this, dataItem);
      }
    };
    Object.defineProperty(PieSeries2.prototype, "radius", {
      /**
       * @return Radius
       */
      get: function() {
        return this.getPropertyValue("radius");
      },
      /**
       * Outer radius for the series' slices in pixels or [[Percent]].
       *
       * @param value  Radius
       */
      set: function(value) {
        if (this.setPercentProperty("radius", value, true, false, 10, false)) {
          this.invalidateDataItems();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PieSeries2.prototype, "pixelRadius", {
      /**
       * @return Radius
       * @ignore
       */
      get: function() {
        return this._pixelRadius;
      },
      /**
       * @ignore
       */
      set: function(value) {
        if (this._pixelRadius != value) {
          this._pixelRadius = value;
          this.invalidateDataItems();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PieSeries2.prototype, "pixelInnerRadius", {
      /**
       * @return Pixel inner radius
       * @ignore
       */
      get: function() {
        return this._pixelInnerRadius;
      },
      /**
       * @ignore
       */
      set: function(value) {
        if (this._pixelInnerRadius != value) {
          this._pixelInnerRadius = value;
          this.invalidateDataItems();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PieSeries2.prototype, "innerRadius", {
      /**
       * @ignore Exclude from docs
       * @return Radius
       */
      get: function() {
        return this.getPropertyValue("innerRadius");
      },
      /**
       * Inner radius for the series' slices in pixels.
       *
       * @ignore Exclude from docs
       * @todo Redo so that users can set it
       * @param value  Radius
       */
      set: function(value) {
        this.setPercentProperty("innerRadius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PieSeries2.prototype, "startAngle", {
      /**
       * @return Angle
       */
      get: function() {
        var startAngle = this.getPropertyValue("startAngle");
        if (isNumber(startAngle)) {
          return startAngle;
        } else {
          return this._startAngleInternal;
        }
      },
      /**
       * Start angle for the series' slices in degrees. (0-360)
       *
       * @param value  Angle
       */
      set: function(value) {
        this.setPropertyValue("startAngle", normalizeAngle(value), true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PieSeries2.prototype, "endAngle", {
      /**
       * @return Angle
       */
      get: function() {
        var endAngle = this.getPropertyValue("endAngle");
        if (isNumber(endAngle)) {
          return endAngle;
        } else {
          return this._endAngleInternal;
        }
      },
      /**
       * End angle for the series' slices in degrees. (0-360)
       *
       * @param value  Angle
       */
      set: function(value) {
        this.setPropertyValue("endAngle", value, true);
      },
      enumerable: true,
      configurable: true
    });
    PieSeries2.prototype.positionBullet = function(bullet) {
      _super.prototype.positionBullet.call(this, bullet);
      var dataItem = bullet.dataItem;
      var slice = dataItem.slice;
      var locationX = bullet.locationX;
      if (!isNumber(locationX)) {
        locationX = 0.5;
      }
      var locationY = bullet.locationY;
      if (!isNumber(locationY)) {
        locationY = 1;
      }
      var angle = slice.startAngle + slice.arc * locationX;
      bullet.x = locationY * slice.radius * cos(angle);
      bullet.y = locationY * slice.radiusY * sin(angle);
    };
    PieSeries2.prototype.handleSliceMove = function(event) {
      if (!this.alignLabels) {
        var slice = event.target;
        var dataItem = slice.dataItem;
        if (dataItem) {
          var label = dataItem.label;
          if (label) {
            label.dx = label.fdx + slice.dx + slice.pixelX;
            label.dy = label.fdy + slice.dy + slice.pixelY;
          }
        }
      }
    };
    Object.defineProperty(PieSeries2.prototype, "bbox", {
      /**
       * Returns bounding box (square) for this element.
       *
       * @ignore Exclude from docs
       */
      get: function() {
        if (this.definedBBox) {
          return this.definedBBox;
        }
        var chart = this.chart;
        if (chart) {
          return getArcRect(chart.startAngle, chart.endAngle, this.pixelRadius);
        }
        return getArcRect(this.startAngle, this.endAngle, this.pixelRadius);
      },
      enumerable: true,
      configurable: true
    });
    return PieSeries2;
  }(PercentSeries)
);
registry.registeredClasses["PieSeries"] = PieSeries;
registry.registeredClasses["PieSeriesDataItem"] = PieSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/types/PieChart.js
var PieChartDataItem = (
  /** @class */
  function(_super) {
    __extends(PieChartDataItem2, _super);
    function PieChartDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "PieChartDataItem";
      _this.applyTheme();
      return _this;
    }
    return PieChartDataItem2;
  }(PercentChartDataItem)
);
var PieChart = (
  /** @class */
  function(_super) {
    __extends(PieChart2, _super);
    function PieChart2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "PieChart";
      _this.innerRadius = 0;
      _this.radius = percent(80);
      _this.align = "none";
      _this.valign = "none";
      _this.startAngle = -90;
      _this.endAngle = 270;
      var seriesContainer = _this.seriesContainer;
      seriesContainer.isMeasured = true;
      seriesContainer.valign = "middle";
      seriesContainer.align = "center";
      seriesContainer.layout = "absolute";
      seriesContainer.width = void 0;
      seriesContainer.height = void 0;
      _this.chartContainer.minHeight = 50;
      _this.chartContainer.minWidth = 50;
      _this.chartContainer.events.on("maxsizechanged", _this.updateRadius, _this, false);
      _this._disposers.push(_this.seriesContainer.events.on("positionchanged", function() {
        _this.bulletsContainer.x = _this.seriesContainer.x;
        _this.bulletsContainer.y = _this.seriesContainer.y;
      }));
      _this.applyTheme();
      return _this;
    }
    PieChart2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Pie chart");
      }
    };
    PieChart2.prototype.validateLayout = function() {
      _super.prototype.validateLayout.call(this);
      this.updateRadius();
    };
    PieChart2.prototype.handleSeriesAdded = function(event) {
      _super.prototype.handleSeriesAdded.call(this, event);
      this._chartPixelRadius = void 0;
      this.updateSeriesAngles();
    };
    PieChart2.prototype.updateSeriesAngles = function() {
      var _this = this;
      this.series.each(function(series) {
        series._startAngleInternal = _this.startAngle;
        series._endAngleInternal = _this.endAngle;
      });
    };
    PieChart2.prototype.updateRadius = function() {
      var chartCont = this.chartContainer;
      var rect = getArcRect(this.startAngle, this.endAngle, 1);
      var innerRect = { x: 0, y: 0, width: 0, height: 0 };
      var innerRadius = this.innerRadius;
      if (innerRadius instanceof Percent) {
        innerRect = getArcRect(this.startAngle, this.endAngle, innerRadius.value);
      }
      rect = getCommonRectangle([rect, innerRect]);
      var maxRadius = Math.min(chartCont.innerWidth / rect.width, chartCont.innerHeight / rect.height);
      if (!isNumber(maxRadius)) {
        maxRadius = 0;
      }
      var chartRadius = relativeRadiusToValue(this.radius, maxRadius);
      var chartPixelInnerRadius = relativeRadiusToValue(this.innerRadius, maxRadius);
      var seriesRadius = (chartRadius - chartPixelInnerRadius) / this.series.length;
      if (chartRadius != this._chartPixelRadius || chartPixelInnerRadius != this._chartPixelInnerRadius) {
        this._chartPixelRadius = chartRadius;
        this._chartPixelInnerRadius = chartPixelInnerRadius;
        each3(indexed(this.series.iterator()), function(a) {
          var i = a[0];
          var series = a[1];
          var radius = chartPixelInnerRadius + relativeRadiusToValue(series.radius, chartRadius - chartPixelInnerRadius);
          var innerRadius2 = chartPixelInnerRadius + relativeRadiusToValue(series.innerRadius, chartRadius - chartPixelInnerRadius);
          if (!isNumber(radius)) {
            radius = chartPixelInnerRadius + seriesRadius * (i + 1);
          }
          if (!isNumber(innerRadius2)) {
            innerRadius2 = chartPixelInnerRadius + seriesRadius * i;
          }
          series.pixelRadius = radius;
          series.pixelInnerRadius = innerRadius2;
        });
        this.seriesContainer.definedBBox = { x: chartRadius * rect.x, y: chartRadius * rect.y, width: chartRadius * rect.width, height: chartRadius * rect.height };
        this.seriesContainer.invalidateLayout();
      }
    };
    Object.defineProperty(PieChart2.prototype, "radius", {
      /**
       * @return Radius (px or relative)
       */
      get: function() {
        return this.getPropertyValue("radius");
      },
      /**
       * Sets radius of the pie chart.
       *
       * Setting to a number will mean a fixed pixel radius.
       *
       * Setting to an instance of [[Percent]] will mean a relative radius to
       * available space.
       *
       * E.g.:
       *
       * ```TypeScript
       * // Set pie chart to be at 50% of the available space
       * pieChart.radius = am4core.percent(50);
       * ```
       * ```JavaScript
       * // Set pie chart to be at 50% of the available space
       * pieChart.radius = am4core.percent(50);
       * ```
       * ```JSON
       * {
       *   // Set pie chart to be at 50% of the available space
       *   "radius": "50%"
       * }
       * ```
       *
       * @default 80%
       * @param value  Radius (px or relative)
       */
      set: function(value) {
        if (this.setPercentProperty("radius", value, true, false, 10, false)) {
          this.invalidateLayout();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PieChart2.prototype, "innerRadius", {
      /**
       * @return Relative inner radius (0-1)
       */
      get: function() {
        return this.getPropertyValue("innerRadius");
      },
      /**
       * Sets relative inner radius (to create a donut chart).
       *
       * Setting to a number will mean a fixed pixel radius.
       *
       * Setting to an instance of [[Percent]] will mean a relative radius to
       * available space.
       *
       * NOTE: it's not related to `radius`.
       *
       * E.g.:
       *
       * ```TypeScript
       * // Set pie chart to be at 50% of the available space
       * pieChart.innerRadius = am4core.percent(50);
       * ```
       * ```JavaScript
       * // Set pie chart to be at 50% of the available space
       * pieChart.innerRadius = am4core.percent(50);
       * ```
       * ```JSON
       * {
       *   // Set pie chart to be at 50% of the available space
       *   "innerRadius": "50%"
       * }
       * ```
       *
       * @default 0
       * @param value  Relative inner radius (0-1)
       * @todo Setting things like `innerRadius` modifies `slice.radius` and it then looks like it is not the same value as in default state
       */
      set: function(value) {
        this.setPercentProperty("innerRadius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    PieChart2.prototype.createSeries = function() {
      return new PieSeries();
    };
    Object.defineProperty(PieChart2.prototype, "startAngle", {
      /**
       * @return Start angle (degrees)
       */
      get: function() {
        return this.getPropertyValue("startAngle");
      },
      /**
       * Starting angle of the Pie circle. (degrees)
       *
       * Normally, a pie chart begins (the left side of the first slice is drawn)
       * at the top center. (at -90 degrees)
       *
       * You can use `startAngle` to change this setting.
       *
       * E.g. setting this to 0 will make the first slice be drawn to the right.
       *
       * For a perfect circle the absolute sum of `startAngle` and `endAngle`
       * needs to be 360.
       *
       * However, it's **not** necessary to do so. You can set to those lesser
       * numbers, to create semi-circles.
       *
       * E.g. `startAngle = -90` with `endAngle = 0` will create a Pie chart that
       * looks like a quarter of a circle.
       *
       * NOTE: This setting is not supported in a 3D pie chart.
       *
       * @default -90
       * @param value  Start angle (degrees)
       */
      set: function(value) {
        if (this.setPropertyValue("startAngle", value)) {
          this.updateRadius();
          this.updateSeriesAngles();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PieChart2.prototype, "endAngle", {
      /**
       * @return End angle (degrees)
       */
      get: function() {
        return this.getPropertyValue("endAngle");
      },
      /**
       * End angle of the Pie circle. (degrees)
       *
       * Normally, a pie chart ends (the right side of the last slice is drawn)
       * at the top center. (at 270 degrees)
       *
       * You can use `endAngle` to change this setting.
       *
       * For a perfect circle the absolute sum of `startAngle` and `endAngle`
       * needs to be 360.
       *
       * However, it's **not** necessary to do so. You can set to those lesser
       * numbers, to create semi-circles.
       *
       * E.g. `startAngle = -90` with `endAngle = 0` will create a Pie chart that
       * looks like a quarter of a circle.
       *
       * NOTE: This setting is not supported in a 3D pie chart.
       *
       * @default 270
       * @param value  End angle (degrees)
       */
      set: function(value) {
        if (this.setPropertyValue("endAngle", value)) {
          this.updateRadius();
          this.updateSeriesAngles();
        }
      },
      enumerable: true,
      configurable: true
    });
    return PieChart2;
  }(PercentChart)
);
registry.registeredClasses["PieChart"] = PieChart;
registry.registeredClasses["PieChartDataItem"] = PieChartDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/series/PieSeries3D.js
var PieSeries3DDataItem = (
  /** @class */
  function(_super) {
    __extends(PieSeries3DDataItem2, _super);
    function PieSeries3DDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "PieSeries3DDataItem";
      _this.values.depthValue = {};
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(PieSeries3DDataItem2.prototype, "depthValue", {
      /**
       * @return Depth
       */
      get: function() {
        return this.values["depthValue"].value;
      },
      /**
       * Slice depth (height).
       *
       * @param value  Depth
       */
      set: function(value) {
        this.setValue("depthValue", value);
      },
      enumerable: true,
      configurable: true
    });
    return PieSeries3DDataItem2;
  }(PieSeriesDataItem)
);
var PieSeries3D = (
  /** @class */
  function(_super) {
    __extends(PieSeries3D2, _super);
    function PieSeries3D2() {
      var _this = _super.call(this) || this;
      _this.className = "PieSeries3D";
      _this.applyTheme();
      return _this;
    }
    PieSeries3D2.prototype.createDataItem = function() {
      return new PieSeries3DDataItem();
    };
    PieSeries3D2.prototype.createSlice = function() {
      return new Slice3D();
    };
    PieSeries3D2.prototype.validateDataElement = function(dataItem) {
      var slice = dataItem.slice;
      var depth = this.depth;
      if (!isNumber(depth)) {
        depth = this.chart.depth;
      }
      var depthPercent = dataItem.values.depthValue.percent;
      if (!isNumber(depthPercent)) {
        depthPercent = 100;
      }
      slice.depth = depthPercent * depth / 100;
      var angle = this.angle;
      if (!isNumber(angle)) {
        angle = this.chart.angle;
      }
      slice.angle = angle;
      _super.prototype.validateDataElement.call(this, dataItem);
    };
    PieSeries3D2.prototype.validate = function() {
      _super.prototype.validate.call(this);
      for (var i = this._workingStartIndex; i < this._workingEndIndex; i++) {
        var dataItem = this.dataItems.getIndex(i);
        var slice = dataItem.slice;
        var startAngle = slice.startAngle;
        if (startAngle >= -90 && startAngle < 90) {
          slice.toFront();
        } else if (startAngle >= 90) {
          slice.toBack();
        }
      }
    };
    Object.defineProperty(PieSeries3D2.prototype, "depth", {
      /**
       * @return Depth (px)
       */
      get: function() {
        return this.getPropertyValue("depth");
      },
      /**
       * Depth (height) of the pie slice in pixels.
       *
       * @param value  Depth (px)
       */
      set: function(value) {
        this.setPropertyValue("depth", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PieSeries3D2.prototype, "angle", {
      /**
       * @return Angle
       */
      get: function() {
        return this.getPropertyValue("angle");
      },
      /**
       * Angle of the view point of the 3D pie. (0-360)
       *
       * @param value  Angle
       */
      set: function(value) {
        this.setPropertyValue("angle", value);
      },
      enumerable: true,
      configurable: true
    });
    PieSeries3D2.prototype.positionBullet = function(bullet) {
      _super.prototype.positionBullet.call(this, bullet);
      var dataItem = bullet.dataItem;
      var slice = dataItem.slice;
      bullet.y = bullet.pixelY - slice.depth;
    };
    return PieSeries3D2;
  }(PieSeries)
);
registry.registeredClasses["PieSeries3D"] = PieSeries3D;
registry.registeredClasses["PieSeries3DDataItem"] = PieSeries3DDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/types/PieChart3D.js
var PieChart3DDataItem = (
  /** @class */
  function(_super) {
    __extends(PieChart3DDataItem2, _super);
    function PieChart3DDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "PieChart3DDataItem";
      _this.applyTheme();
      return _this;
    }
    return PieChart3DDataItem2;
  }(PieChartDataItem)
);
var PieChart3D = (
  /** @class */
  function(_super) {
    __extends(PieChart3D2, _super);
    function PieChart3D2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "PieChart3D";
      _this.depth = 20;
      _this.angle = 10;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(PieChart3D2.prototype, "depth", {
      /**
       * @return Depth (px)
       */
      get: function() {
        return this.getPropertyValue("depth");
      },
      /**
       * Depth of the 3D pie in pixels.
       *
       * This will determine "height" of the pie.
       *
       * @default 20
       * @param value  Depth (px)
       */
      set: function(value) {
        if (this.setPropertyValue("depth", value)) {
          this.invalidateDataUsers();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PieChart3D2.prototype, "angle", {
      /**
       * @return Angle (degrees)
       */
      get: function() {
        return this.getPropertyValue("angle");
      },
      /**
       * An angle of a "point of view" in degrees. Possible range 0 - 90.
       *
       * @default 10
       * @param value  Angle (degrees)
       */
      set: function(value) {
        value = fitToRange(value, 0, 90);
        if (this.setPropertyValue("angle", value)) {
          this.invalidateDataUsers();
        }
      },
      enumerable: true,
      configurable: true
    });
    PieChart3D2.prototype.createSeries = function() {
      return new PieSeries3D();
    };
    return PieChart3D2;
  }(PieChart)
);
registry.registeredClasses["PieChart3D"] = PieChart3D;

// node_modules/@amcharts/amcharts4/.internal/charts/types/SlicedChart.js
var SlicedChartDataItem = (
  /** @class */
  function(_super) {
    __extends(SlicedChartDataItem2, _super);
    function SlicedChartDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "SlicedChartDataItem";
      _this.applyTheme();
      return _this;
    }
    return SlicedChartDataItem2;
  }(PercentChartDataItem)
);
var SlicedChart = (
  /** @class */
  function(_super) {
    __extends(SlicedChart2, _super);
    function SlicedChart2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "SlicedChart";
      _this.seriesContainer.layout = "horizontal";
      _this.padding(15, 15, 15, 15);
      _this.applyTheme();
      return _this;
    }
    SlicedChart2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Sliced chart");
      }
    };
    SlicedChart2.prototype.validate = function() {
      _super.prototype.validate.call(this);
    };
    return SlicedChart2;
  }(PercentChart)
);
registry.registeredClasses["SlicedChart"] = SlicedChart;
registry.registeredClasses["SlicedChartDataItem"] = SlicedChartDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/FlowDiagramNode.js
var FlowDiagramNode = (
  /** @class */
  function(_super) {
    __extends(FlowDiagramNode2, _super);
    function FlowDiagramNode2() {
      var _this = _super.call(this) || this;
      _this.legendSettings = new LegendSettings();
      _this.className = "FlowDiagramNode";
      _this.isMeasured = false;
      new InterfaceColorSet();
      _this.draggable = true;
      _this.inert = true;
      _this.setStateOnChildren = true;
      _this.events.on("positionchanged", _this.invalidateLinks, _this, false);
      _this.events.on("sizechanged", _this.invalidateLinks, _this, false);
      return _this;
    }
    FlowDiagramNode2.prototype.handleHit = function(event) {
      if (this.isHidden || this.isHiding) {
        this.show();
      } else {
        this.hide();
      }
    };
    FlowDiagramNode2.prototype.show = function(duration) {
      var animation = _super.prototype.show.call(this, duration);
      this.outgoingDataItems.each(function(dataItem) {
        if (!dataItem.toNode || dataItem.toNode && !dataItem.toNode.isHidden) {
          dataItem.setWorkingValue("value", dataItem.getValue("value"), duration);
          dataItem.link.show();
        }
      });
      this.incomingDataItems.each(function(dataItem) {
        if (!dataItem.fromNode || dataItem.fromNode && !dataItem.fromNode.isHidden) {
          dataItem.setWorkingValue("value", dataItem.getValue("value"), duration);
          dataItem.link.show();
        }
      });
      return animation;
    };
    FlowDiagramNode2.prototype.hide = function(duration) {
      var animation = _super.prototype.hide.call(this, duration);
      this.outgoingDataItems.each(function(dataItem) {
        dataItem.setWorkingValue("value", 0, duration);
        dataItem.link.hide();
      });
      this.incomingDataItems.each(function(dataItem) {
        dataItem.setWorkingValue("value", 0, duration);
        dataItem.link.hide();
      });
      return animation;
    };
    FlowDiagramNode2.prototype.validate = function() {
      if (!this.isDisposed()) {
        _super.prototype.validate.call(this);
        this.invalidateLinks();
      }
    };
    FlowDiagramNode2.prototype.invalidateLinks = function() {
      var _this = this;
      this.outgoingDataItems.each(function(dataItem) {
        var link = dataItem.link;
        if (link.colorMode == "fromNode") {
          link.fill = link.dataItem.fromNode.color;
        }
        if (link.colorMode == "gradient") {
          link.fill = link.gradient;
          link.stroke = link.gradient;
          var stop_1 = link.gradient.stops.getIndex(0);
          if (stop_1) {
            stop_1.color = _this.color;
            link.gradient.validate();
          }
        }
      });
      this.incomingDataItems.each(function(dataItem) {
        var link = dataItem.link;
        if (link.colorMode == "toNode") {
          link.fill = link.dataItem.toNode.color;
        }
        if (link.colorMode == "gradient") {
          link.fill = link.gradient;
          link.stroke = link.gradient;
          var stop_2 = link.gradient.stops.getIndex(1);
          if (stop_2) {
            stop_2.color = _this.color;
            link.gradient.validate();
          }
        }
      });
    };
    Object.defineProperty(FlowDiagramNode2.prototype, "incomingDataItems", {
      /**
       * List of incoming items (links).
       *
       * @readonly
       * @return Incoming items
       */
      get: function() {
        var _this = this;
        if (!this._incomingDataItems) {
          var incomingDataItems = new List();
          incomingDataItems.events.on("inserted", function() {
            if (_this.chart.sortBy == "name") {
              _this._incomingSorted = sort(_this._incomingDataItems.iterator(), function(x, y) {
                return order(x.fromName, y.fromName);
              });
            } else if (_this.chart.sortBy == "value") {
              _this._incomingSorted = sort(_this._incomingDataItems.iterator(), function(x, y) {
                return reverse(order2(x.value, y.value));
              });
            } else {
              _this._incomingSorted = _this._incomingDataItems.iterator();
            }
          }, void 0, false);
          this._incomingDataItems = incomingDataItems;
        }
        return this._incomingDataItems;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramNode2.prototype, "outgoingDataItems", {
      /**
       * List of outgoing items (links).
       *
       * @readonly
       * @return Outgoing items
       */
      get: function() {
        var _this = this;
        if (!this._outgoingDataItems) {
          var outgoingDataItems = new List();
          outgoingDataItems.events.on("inserted", function() {
            if (_this.chart.sortBy == "name") {
              _this._outgoingSorted = sort(_this._outgoingDataItems.iterator(), function(x, y) {
                return order(x.fromName, y.fromName);
              });
            } else if (_this.chart.sortBy == "value") {
              _this._outgoingSorted = sort(_this._outgoingDataItems.iterator(), function(x, y) {
                return reverse(order2(x.value, y.value));
              });
            } else {
              _this._outgoingSorted = _this._outgoingDataItems.iterator();
            }
          }, void 0, false);
          this._outgoingDataItems = outgoingDataItems;
        }
        return this._outgoingDataItems;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramNode2.prototype, "name", {
      /**
       * @return Name
       */
      get: function() {
        return this.getPropertyValue("name");
      },
      /**
       * A name of the node.
       *
       * @param value  Name
       */
      set: function(value) {
        this.setPropertyValue("name", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramNode2.prototype, "total", {
      /**
       * @return Value
       */
      get: function() {
        return this.getPropertyValue("total");
      },
      /**
       * Sum of all incoming+outgoing link values
       *
       * @param value  Value
       */
      set: function(value) {
        this.setPropertyValue("total", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramNode2.prototype, "totalIncoming", {
      /**
       * @return Value
       */
      get: function() {
        return this.getPropertyValue("totalIncoming");
      },
      /**
       * Sum of all incomming link values.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setPropertyValue("totalIncoming", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramNode2.prototype, "totalOutgoing", {
      /**
       * @return Value
       */
      get: function() {
        return this.getPropertyValue("totalOutgoing");
      },
      /**
       * Sum of all outgoing link values.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setPropertyValue("totalOutgoing", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramNode2.prototype, "color", {
      /**
       * @return Color
       */
      get: function() {
        return this.getPropertyValue("color");
      },
      /**
       * Node's color.
       *
       * @param value  Color
       */
      set: function(value) {
        this.setColorProperty("color", value);
        if (this._background) {
          this._background.fill = value;
        }
        this.fill = value;
      },
      enumerable: true,
      configurable: true
    });
    FlowDiagramNode2.prototype.createLegendMarker = function(marker) {
      var w = marker.pixelWidth;
      var h = marker.pixelHeight;
      marker.removeChildren();
      var column = marker.createChild(RoundedRectangle);
      column.shouldClone = false;
      copyProperties(this, column, visualProperties);
      column.stroke = this.fill;
      column.copyFrom(this);
      column.padding(0, 0, 0, 0);
      column.width = w;
      column.height = h;
      var legendDataItem = marker.dataItem;
      legendDataItem.color = column.fill;
      legendDataItem.colorOrig = column.fill;
    };
    Object.defineProperty(FlowDiagramNode2.prototype, "legendDataItem", {
      /**
       * @return Data item
       */
      get: function() {
        return this._legendDataItem;
      },
      /**
       * Legend data item that corresponds to this series.
       *
       * @param value  Data item
       */
      set: function(value) {
        this._legendDataItem = value;
        this._legendDataItem.itemContainer.deepInvalidate();
      },
      enumerable: true,
      configurable: true
    });
    return FlowDiagramNode2;
  }(Container)
);
registry.registeredClasses["FlowDiagramNode"] = FlowDiagramNode;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/FlowDiagramLink.js
var FlowDiagramLink = (
  /** @class */
  function(_super) {
    __extends(FlowDiagramLink2, _super);
    function FlowDiagramLink2() {
      var _this = _super.call(this) || this;
      _this.className = "FlowDiagramLink";
      var interfaceColors = new InterfaceColorSet();
      _this.maskBullets = false;
      _this.colorMode = "fromNode";
      _this.layout = "none";
      _this.isMeasured = false;
      _this.startAngle = 0;
      _this.endAngle = 0;
      _this.strokeOpacity = 0;
      _this.verticalCenter = "none";
      _this.horizontalCenter = "none";
      _this.tooltipText = "{fromName}→{toName}:{value.value}";
      _this.tooltipLocation = 0.5;
      _this.link = _this.createChild(Sprite);
      _this.link.shouldClone = false;
      _this.link.setElement(_this.paper.add("path"));
      _this.link.isMeasured = false;
      _this.fillOpacity = 0.2;
      _this.fill = interfaceColors.getFor("alternativeBackground");
      _this.applyTheme();
      return _this;
    }
    FlowDiagramLink2.prototype.positionBullets = function() {
      var _this = this;
      each3(this.bullets.iterator(), function(bullet) {
        bullet.parent = _this.bulletsContainer;
        bullet.maxWidth = _this.maxWidth;
        bullet.maxHeight = _this.maxHeight;
        _this.positionBullet(bullet);
      });
    };
    Object.defineProperty(FlowDiagramLink2.prototype, "bulletsContainer", {
      /**
       * Bullets container
       */
      get: function() {
        if (!this._bulletsContainer) {
          var bulletsContainer = this.createChild(Container);
          bulletsContainer.shouldClone = false;
          bulletsContainer.layout = "none";
          this._bulletsContainer = bulletsContainer;
        }
        return this._bulletsContainer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramLink2.prototype, "bulletsMask", {
      /**
       * Bullets mask sprite
       */
      get: function() {
        if (!this._bulletsMask) {
          var bulletsMask = this.createChild(Sprite);
          bulletsMask.shouldClone = false;
          bulletsMask.setElement(this.paper.add("path"));
          bulletsMask.isMeasured = false;
          this._bulletsMask = bulletsMask;
        }
        return this._bulletsMask;
      },
      enumerable: true,
      configurable: true
    });
    FlowDiagramLink2.prototype.positionBullet = function(bullet) {
      var location = bullet.locationX;
      if (!isNumber(location)) {
        location = bullet.locationY;
      }
      if (!isNumber(location)) {
        location = 0.5;
      }
      var point = this.middleLine.positionToPoint(location);
      bullet.moveTo(point);
      var rotationField = bullet.propertyFields.rotation;
      var angle;
      if (bullet.dataItem) {
        var dataContext = bullet.dataItem.dataContext;
        angle = dataContext[rotationField];
      }
      if (!isNumber(angle)) {
        angle = point.angle;
      }
      bullet.rotation = angle;
    };
    Object.defineProperty(FlowDiagramLink2.prototype, "startAngle", {
      /**
       * @return Start angle
       */
      get: function() {
        return this.getPropertyValue("startAngle");
      },
      /**
       * [startAngle description]
       *
       * @todo Description
       * @param value  Start angle
       */
      set: function(value) {
        this.setPropertyValue("startAngle", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramLink2.prototype, "endAngle", {
      /**
       * @return End angle
       */
      get: function() {
        return this.getPropertyValue("endAngle");
      },
      /**
       * [endAngle description]
       *
       * @todo Description
       * @param value  End angle
       */
      set: function(value) {
        this.setPropertyValue("endAngle", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramLink2.prototype, "colorMode", {
      /**
       * Fill mode
       */
      get: function() {
        return this.getPropertyValue("colorMode");
      },
      /**
       * Should link be filled with a solid color, color of from node, color of toNode or gradient between node colors.
       * Some of the links, like ChordLink does not support gradiens well.
       *
       * @param value  Fill mode
       */
      set: function(value) {
        if (value == "gradient") {
          var color2 = this.fill;
          this.gradient.stops.clear();
          if (color2 instanceof Color) {
            this.gradient.addColor(color2);
            this.gradient.addColor(color2);
          }
          this.fill = this.gradient;
          this.stroke = this.gradient;
        }
        this.setPropertyValue("colorMode", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramLink2.prototype, "maskBullets", {
      /**
       * @return mask bullets value
       */
      get: function() {
        return this.getPropertyValue("maskBullets");
      },
      /**
       * Should link bullets be masked or not
       *
       * @param value
       * @default false
       */
      set: function(value) {
        this.setPropertyValue("maskBullets", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramLink2.prototype, "tooltipLocation", {
      /**
       * Tooltip location value
       */
      get: function() {
        return this.getPropertyValue("tooltipLocation");
      },
      /**
       * Relative location of a tooltip.
       * @default 0.5
       *
       * @param value
       */
      set: function(value) {
        this.setPropertyValue("tooltipLocation", value, true);
      },
      enumerable: true,
      configurable: true
    });
    FlowDiagramLink2.prototype.setFill = function(value) {
      _super.prototype.setFill.call(this, value);
      var gradient = this._gradient;
      if (gradient && value instanceof Color) {
        gradient.stops.clear();
        gradient.addColor(value);
        gradient.addColor(value);
      }
    };
    FlowDiagramLink2.prototype.measureElement = function() {
    };
    Object.defineProperty(FlowDiagramLink2.prototype, "bullets", {
      /**
       * List of bullets
       *
       * @return [description]
       */
      get: function() {
        var _this = this;
        if (!this._bullets) {
          this._bullets = new ListTemplate(new Bullet());
          this._disposers.push(new ListDisposer(this._bullets));
          this._disposers.push(this._bullets.template);
          this._bullets.events.on("inserted", function(event) {
            event.newValue.events.on("propertychanged", function(event2) {
              if (event2.property == "locationX" || event2.property == "locationY") {
                _this.positionBullet(event2.target);
              }
            }, void 0, false);
          }, void 0, false);
        }
        return this._bullets;
      },
      enumerable: true,
      configurable: true
    });
    FlowDiagramLink2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.bullets.copyFrom(source.bullets);
      var middleLine = this.middleLine;
      if (middleLine) {
        if (middleLine instanceof Line && source.middleLine instanceof Line) {
          middleLine.copyFrom(source.middleLine);
        }
        if (middleLine instanceof Polyline && source.middleLine instanceof Polyline) {
          middleLine.copyFrom(source.middleLine);
        }
      }
      this.link.copyFrom(source.link);
    };
    FlowDiagramLink2.prototype.getTooltipX = function() {
      if (this.middleLine) {
        return this.middleLine.positionToPoint(this.tooltipLocation).x;
      }
    };
    FlowDiagramLink2.prototype.getTooltipY = function() {
      if (this.middleLine) {
        return this.middleLine.positionToPoint(this.tooltipLocation).y;
      }
    };
    Object.defineProperty(FlowDiagramLink2.prototype, "gradient", {
      /**
       * A gradiend instance that is used to provided colored gradient fills for
       * the Flow link.
       */
      get: function() {
        if (!this._gradient) {
          this._gradient = new LinearGradient();
        }
        return this._gradient;
      },
      enumerable: true,
      configurable: true
    });
    return FlowDiagramLink2;
  }(Container)
);
registry.registeredClasses["FlowDiagramLink"] = FlowDiagramLink;

// node_modules/@amcharts/amcharts4/.internal/charts/types/FlowDiagram.js
var FlowDiagramDataItem = (
  /** @class */
  function(_super) {
    __extends(FlowDiagramDataItem2, _super);
    function FlowDiagramDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "FlowDiagramDataItem";
      _this.values.value = {};
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(FlowDiagramDataItem2.prototype, "fromName", {
      /**
       * @return name
       */
      get: function() {
        return this.properties.fromName;
      },
      /**
       * Source node's name.
       *
       * @param value  Name
       */
      set: function(value) {
        this.setProperty("fromName", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramDataItem2.prototype, "toName", {
      /**
       * @return name
       */
      get: function() {
        return this.properties.toName;
      },
      /**
       * Destination node's name.
       *
       * @param value  Name
       */
      set: function(value) {
        this.setProperty("toName", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramDataItem2.prototype, "color", {
      /**
       * @return color
       */
      get: function() {
        return this.properties.color;
      },
      /**
       * Node color
       *
       * @param value  Name
       */
      set: function(value) {
        this.setProperty("color", toColor(value));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramDataItem2.prototype, "value", {
      /**
       * @return Value
       */
      get: function() {
        return this.values.value.value;
      },
      /**
       * Link's value.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("value", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagramDataItem2.prototype, "link", {
      /**
       * A visual element, representing link between the source and target nodes.
       *
       * Link's actual thickness will be determined by `value` of this link and
       * `value` of the source node.
       *
       * @readonly
       * @return Link element
       */
      get: function() {
        var _this = this;
        if (!this._link) {
          var link_1 = this.component.links.create();
          this._link = link_1;
          this.addSprite(link_1);
          this._disposers.push(new Disposer(function() {
            if (_this.component) {
              _this.component.links.removeValue(link_1);
            }
          }));
        }
        return this._link;
      },
      enumerable: true,
      configurable: true
    });
    return FlowDiagramDataItem2;
  }(ChartDataItem)
);
var FlowDiagram = (
  /** @class */
  function(_super) {
    __extends(FlowDiagram2, _super);
    function FlowDiagram2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.colors = new ColorSet();
      _this.className = "FlowDiagram";
      _this.nodePadding = 20;
      _this.sortBy = "none";
      _this.sequencedInterpolation = true;
      _this.colors.step = 2;
      _this.minNodeSize = 0.02;
      var linksContainer = _this.chartContainer.createChild(Container);
      linksContainer.shouldClone = false;
      linksContainer.layout = "none";
      linksContainer.isMeasured = false;
      _this.linksContainer = linksContainer;
      var nodesContainer = _this.chartContainer.createChild(Container);
      nodesContainer.shouldClone = false;
      nodesContainer.layout = "none";
      nodesContainer.isMeasured = false;
      _this.nodesContainer = nodesContainer;
      _this.dataItem = _this.createDataItem();
      _this.dataItem.component = _this;
      _this.applyTheme();
      return _this;
    }
    FlowDiagram2.prototype.dispose = function() {
      _super.prototype.dispose.call(this);
      this.dataItem.dispose();
    };
    FlowDiagram2.prototype.validateData = function() {
      var _this = this;
      if (this._parseDataFrom == 0) {
        this.nodes.clear();
      }
      this.sortNodes();
      this.colors.reset();
      _super.prototype.validateData.call(this);
      var sum = 0;
      var count = 0;
      var low;
      var high;
      each3(this.dataItems.iterator(), function(dataItem) {
        var fromName = dataItem.fromName;
        if (fromName) {
          var node = _this.nodes.getKey(fromName);
          if (!node) {
            node = _this.nodes.create(fromName);
            node.name = fromName;
            node.chart = _this;
            node.dataItem = dataItem;
          }
          dataItem.fromNode = node;
          dataItem.fromNode.outgoingDataItems.push(dataItem);
        }
        var toName = dataItem.toName;
        if (toName) {
          var node = _this.nodes.getKey(toName);
          if (!node) {
            node = _this.nodes.create(toName);
            node.name = toName;
            node.chart = _this;
            node.dataItem = dataItem;
          }
          dataItem.toNode = node;
          dataItem.toNode.incomingDataItems.push(dataItem);
        }
        if (!dataItem.fromNode) {
          var strokeModifier = new LinearGradientModifier();
          strokeModifier.opacities = [0, 1];
          dataItem.link.strokeModifier = strokeModifier;
        }
        if (!dataItem.toNode) {
          var fillModifier = new LinearGradientModifier();
          fillModifier.opacities = [1, 0];
          dataItem.link.strokeModifier = fillModifier;
        }
        var value = dataItem.value;
        if (isNumber(value)) {
          sum += value;
          count++;
          if (low > value || !isNumber(low)) {
            low = value;
          }
          if (high < value || !isNumber(high)) {
            high = value;
          }
        }
      });
      var key = "value";
      this.dataItem.setCalculatedValue(key, high, "high");
      this.dataItem.setCalculatedValue(key, low, "low");
      this.dataItem.setCalculatedValue(key, sum, "sum");
      this.dataItem.setCalculatedValue(key, sum / count, "average");
      this.dataItem.setCalculatedValue(key, count, "count");
      each3(this.nodes.iterator(), function(strNode) {
        var node = strNode[1];
        if (node.fill instanceof Color) {
          node.color = node.fill;
        }
        if (node.color == void 0) {
          node.color = _this.colors.next();
        }
        if (node.dataItem.color != void 0) {
          node.color = node.dataItem.color;
        }
        if (!node.dataItem.visible) {
          node.hide(0);
        }
        _this.getNodeValue(node);
      });
      this.sortNodes();
      this.feedLegend();
    };
    FlowDiagram2.prototype.handleDataItemWorkingValueChange = function(dataItem, name) {
      this.invalidate();
    };
    FlowDiagram2.prototype.sortNodes = function() {
      if (this.sortBy == "name") {
        this._sorted = this.nodes.sortedIterator();
      } else if (this.sortBy == "value") {
        this._sorted = sort(this.nodes.iterator(), function(x, y) {
          return reverse(order2(x[1].total, y[1].total));
        });
      } else {
        this._sorted = this.nodes.iterator();
      }
    };
    FlowDiagram2.prototype.getNodeValue = function(node) {
      var incomingTotal = 0;
      var outgoingTotal = 0;
      each3(node.incomingDataItems.iterator(), function(dataItem) {
        var value = dataItem.getWorkingValue("value");
        if (isNumber(value)) {
          incomingTotal += value;
        }
      });
      each3(node.outgoingDataItems.iterator(), function(dataItem) {
        var value = dataItem.getWorkingValue("value");
        if (isNumber(value)) {
          outgoingTotal += value;
        }
      });
      node.total = incomingTotal + outgoingTotal;
      node.totalIncoming = incomingTotal;
      node.totalOutgoing = outgoingTotal;
    };
    ;
    FlowDiagram2.prototype.changeSorting = function() {
      this.sortNodes();
    };
    FlowDiagram2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Flow diagram");
      }
    };
    FlowDiagram2.prototype.createDataItem = function() {
      return new FlowDiagramDataItem();
    };
    Object.defineProperty(FlowDiagram2.prototype, "nodePadding", {
      /**
       * @return Padding (px)
       */
      get: function() {
        return this.getPropertyValue("nodePadding");
      },
      /**
       * Padding for node square in pixels.
       *
       * Padding will add extra space around node's name label.
       *
       * @param value Padding (px)
       */
      set: function(value) {
        this.setPropertyValue("nodePadding", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagram2.prototype, "sortBy", {
      /**
       * @returns Node sorting
       */
      get: function() {
        return this.getPropertyValue("sortBy");
      },
      /**
       * Sort nodes by "name" or "value" or do not sort at all. If not sorted, nodes will appear in the same order as they are in the data.
       * @default "none"
       * @param value  Node sorting
       */
      set: function(value) {
        this.setPropertyValue("sortBy", value);
        this.changeSorting();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagram2.prototype, "minNodeSize", {
      /**
       * @returns min node size
       */
      get: function() {
        return this.getPropertyValue("minNodeSize");
      },
      /**
       * Sometimes nodes can get very small if their value is little. With this setting you
       * can set min size of a node (this is relative value from the total size of all nodes)
       * @default 0.02
       * @param value  Node sorting
       */
      set: function(value) {
        this.setPropertyValue("minNodeSize", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FlowDiagram2.prototype, "nodes", {
      /**
       * A list of chart's nodes.
       *
       * @param {DictionaryTemplate<string, this["_node"]>}
       */
      get: function() {
        if (!this._nodes) {
          var template = this.createNode();
          template.events.on("hit", function(event) {
            event.target.handleHit(event);
          });
          this._nodes = new DictionaryTemplate(template);
          this._disposers.push(new DictionaryDisposer(this._nodes));
        }
        return this._nodes;
      },
      enumerable: true,
      configurable: true
    });
    FlowDiagram2.prototype.createNode = function() {
      var node = new FlowDiagramNode();
      this._disposers.push(node);
      return node;
    };
    Object.defineProperty(FlowDiagram2.prototype, "links", {
      /**
       * A list of chart's links.
       *
       * @param {ListTemplate<this["_link"]>}
       */
      get: function() {
        if (!this._links) {
          this._links = new ListTemplate(this.createLink());
          this._disposers.push(new ListDisposer(this._links));
        }
        return this._links;
      },
      enumerable: true,
      configurable: true
    });
    FlowDiagram2.prototype.createLink = function() {
      var link = new FlowDiagramLink();
      this._disposers.push(link);
      return link;
    };
    FlowDiagram2.prototype.feedLegend = function() {
      var legend = this.legend;
      if (legend) {
        var legendData_1 = [];
        this.nodes.each(function(key, node) {
          legendData_1.push(node);
        });
        legend.data = legendData_1;
        legend.dataFields.name = "name";
      }
    };
    FlowDiagram2.prototype.disposeData = function() {
      _super.prototype.disposeData.call(this);
      this.nodes.clear();
    };
    return FlowDiagram2;
  }(Chart)
);
registry.registeredClasses["FlowDiagram"] = FlowDiagram;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/LabelBullet.js
var LabelBullet = (
  /** @class */
  function(_super) {
    __extends(LabelBullet2, _super);
    function LabelBullet2() {
      var _this = _super.call(this) || this;
      _this.className = "LabelBullet";
      var label = _this.createChild(Label);
      label.shouldClone = false;
      label.verticalCenter = "middle";
      label.horizontalCenter = "middle";
      label.truncate = true;
      label.hideOversized = false;
      label.maxWidth = 500;
      label.maxHeight = 500;
      label.stroke = color();
      label.strokeOpacity = 0;
      label.fill = new InterfaceColorSet().getFor("text");
      _this.events.on("maxsizechanged", _this.handleMaxSize, _this, false);
      _this.label = label;
      _this.applyTheme();
      return _this;
    }
    LabelBullet2.prototype.handleMaxSize = function() {
      this.label.maxWidth = this.maxWidth;
      this.label.maxHeight = this.maxHeight;
    };
    LabelBullet2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.label.copyFrom(source.label);
    };
    return LabelBullet2;
  }(Bullet)
);
registry.registeredClasses["LabelBullet"] = LabelBullet;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/SankeyNode.js
var SankeyNode = (
  /** @class */
  function(_super) {
    __extends(SankeyNode2, _super);
    function SankeyNode2() {
      var _this = _super.call(this) || this;
      _this.nextInCoord = 0;
      _this.nextOutCoord = 0;
      _this.className = "SankeyNode";
      _this.width = 10;
      _this.height = 10;
      var nameLabel = _this.createChild(LabelBullet);
      nameLabel.shouldClone = false;
      nameLabel.locationX = 1;
      nameLabel.locationY = 0.5;
      nameLabel.label.text = "{name}";
      nameLabel.width = 150;
      nameLabel.height = 150;
      nameLabel.label.horizontalCenter = "left";
      nameLabel.label.padding(0, 5, 0, 5);
      _this.nameLabel = nameLabel;
      var valueLabel = _this.createChild(LabelBullet);
      valueLabel.shouldClone = false;
      valueLabel.label.hideOversized = false;
      valueLabel.locationX = 0.5;
      valueLabel.locationY = 0.5;
      valueLabel.width = 150;
      valueLabel.height = 150;
      valueLabel.label.horizontalCenter = "middle";
      _this.valueLabel = valueLabel;
      var hiddenState = _this.hiddenState;
      hiddenState.properties.fill = new InterfaceColorSet().getFor("disabledBackground");
      hiddenState.properties.opacity = 0.5;
      hiddenState.properties.visible = true;
      _this.background.hiddenState.copyFrom(hiddenState);
      return _this;
    }
    SankeyNode2.prototype.invalidateLinks = function() {
      var _this = this;
      _super.prototype.invalidateLinks.call(this);
      this.nextInCoord = 0;
      this.nextOutCoord = 0;
      var chart = this.chart;
      if (chart) {
        var orientation_1 = chart.orientation;
        if (this._incomingSorted) {
          each3(this._incomingSorted, function(dataItem) {
            var link = dataItem.link;
            var value = dataItem.getWorkingValue("value");
            if (isNumber(value)) {
              link.parent = _this.chart.linksContainer;
              var x = void 0;
              var y = void 0;
              var angle = void 0;
              if (orientation_1 == "horizontal") {
                x = _this.pixelX + _this.dx;
                y = _this.nextInCoord + _this.pixelY + _this.dy;
                angle = 0;
              } else {
                y = _this.pixelY + _this.dy;
                x = _this.nextInCoord + _this.pixelX + _this.dx;
                angle = 90;
              }
              link.endX = x;
              link.endY = y;
              link.startAngle = angle;
              link.endAngle = angle;
              link.gradient.rotation = angle;
              link.linkWidth = value * chart.valueHeight;
              if (!dataItem.fromNode) {
                if (orientation_1 == "horizontal") {
                  link.maxWidth = 200;
                  link.startX = _this.pixelX + _this.dx - link.maxWidth;
                  link.startY = link.endY;
                } else {
                  link.maxHeight = 200;
                  link.startX = link.endX;
                  link.startY = _this.pixelY + _this.dy - link.maxHeight;
                }
                used(link.gradient);
                link.fill = dataItem.toNode.color;
                var stop_1 = link.gradient.stops.getIndex(0);
                if (stop_1) {
                  if (link.colorMode == "gradient") {
                    stop_1.color = _this.color;
                  }
                  stop_1.opacity = 0;
                  link.fill = link.gradient;
                  link.stroke = link.gradient;
                  link.gradient.validate();
                }
              }
              _this.nextInCoord += link.linkWidth;
            }
          });
        }
        if (this._outgoingSorted) {
          each3(this._outgoingSorted, function(dataItem) {
            var link = dataItem.link;
            link.parent = _this.chart.linksContainer;
            var value = dataItem.getWorkingValue("value");
            if (isNumber(value)) {
              var x = void 0;
              var y = void 0;
              var angle = void 0;
              if (orientation_1 == "horizontal") {
                angle = 0;
                x = _this.pixelX + _this.pixelWidth + _this.dx - 1;
                y = _this.nextOutCoord + _this.pixelY + _this.dy;
              } else {
                angle = 90;
                x = _this.nextOutCoord + _this.pixelX + _this.dx;
                y = _this.pixelY + _this.pixelHeight + _this.dy - 1;
              }
              link.startX = x;
              link.startY = y;
              link.startAngle = angle;
              link.endAngle = angle;
              link.gradient.rotation = angle;
              link.linkWidth = value * _this.chart.valueHeight;
              if (!dataItem.toNode) {
                if (orientation_1 == "horizontal") {
                  link.maxWidth = 200;
                  link.endX = _this.pixelX + link.maxWidth + _this.dx;
                  link.endY = link.startY;
                } else {
                  link.maxHeight = 200;
                  link.endX = link.startX;
                  link.endY = _this.pixelY + link.maxHeight + _this.dy;
                }
                link.opacity = _this.opacity;
                var stop_2 = link.gradient.stops.getIndex(1);
                if (stop_2) {
                  if (link.colorMode == "gradient") {
                    stop_2.color = _this.color;
                  }
                  stop_2.opacity = 0;
                  link.fill = link.gradient;
                  link.stroke = link.gradient;
                  link.gradient.validate();
                }
              }
              _this.nextOutCoord += link.linkWidth;
            }
          });
        }
      }
      this.positionBullet(this.nameLabel);
      this.positionBullet(this.valueLabel);
    };
    SankeyNode2.prototype.positionBullet = function(bullet) {
      if (bullet) {
        bullet.x = this.measuredWidth * bullet.locationX;
        bullet.y = this.measuredHeight * bullet.locationY;
      }
    };
    Object.defineProperty(SankeyNode2.prototype, "level", {
      /**
       * @return Level
       */
      get: function() {
        return this.getPropertyValue("level");
      },
      /**
       * A level node is displayed at. (0 - ...)
       *
       * Levels are measured from left to right.
       *
       * The nodes in the left-most column will have `level = 0`.
       *
       * Nodes in second column - `level = 1`, etc.
       *
       * @param value  Level
       */
      set: function(value) {
        this.setPropertyValue("level", value, true);
      },
      enumerable: true,
      configurable: true
    });
    SankeyNode2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.nameLabel.copyFrom(source.nameLabel);
      this.valueLabel.copyFrom(source.valueLabel);
    };
    return SankeyNode2;
  }(FlowDiagramNode)
);
registry.registeredClasses["SankeyNode"] = SankeyNode;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/SankeyLink.js
var SankeyLink = (
  /** @class */
  function(_super) {
    __extends(SankeyLink2, _super);
    function SankeyLink2() {
      var _this = _super.call(this) || this;
      _this.className = "SankeyLink";
      new InterfaceColorSet();
      _this.tension = 0.8;
      _this.controlPointDistance = 0.2;
      _this.startAngle = 0;
      _this.endAngle = 0;
      _this.linkWidth = 0;
      _this.startX = 0;
      _this.endX = 0;
      _this.startY = 0;
      _this.endY = 0;
      _this.middleLine = _this.createChild(Polyspline);
      _this.middleLine.shouldClone = false;
      _this.middleLine.strokeOpacity = 0;
      _this.applyTheme();
      return _this;
    }
    SankeyLink2.prototype.makeBackwards = function() {
      if (this.states.getKey("backwards") != void 0) {
        this.setState("backwards");
      }
    };
    SankeyLink2.prototype.validate = function() {
      var _a, _b, _c, _d;
      _super.prototype.validate.call(this);
      if (!this.isTemplate) {
        var x0 = this.startX;
        var y0 = this.startY;
        var x1 = this.endX;
        var y1 = this.endY;
        if (this.states.getKey("backwards")) {
          this.setState("default");
        }
        if (this.dataItem) {
          var chart = this.dataItem.component;
          if (chart) {
            if (chart.orientation == "horizontal") {
              if (x1 < x0) {
                _a = __read([x1, x0], 2), x0 = _a[0], x1 = _a[1];
                _b = __read([y1, y0], 2), y0 = _b[0], y1 = _b[1];
                this.makeBackwards();
              }
            } else {
              if (y1 < y0) {
                _c = __read([y1, y0], 2), y0 = _c[0], y1 = _c[1];
                _d = __read([x1, x0], 2), x0 = _d[0], x1 = _d[1];
                this.makeBackwards();
              }
            }
          }
        }
        if (!isNumber(x1)) {
          x1 = x0;
        }
        if (!isNumber(y1)) {
          y1 = y0;
        }
        var startAngle = this.startAngle;
        var endAngle = this.endAngle;
        var w = this.linkWidth;
        var path = "";
        var xt0 = x0;
        var yt0 = y0;
        var xt1 = x1;
        var yt1 = y1;
        var xb0 = x0 + w * sin(startAngle);
        var xb1 = x1 + w * sin(endAngle);
        var yb0 = y0 + w * cos(startAngle);
        var yb1 = y1 + w * cos(endAngle);
        var xm0 = x0 + w / 2 * sin(startAngle);
        var xm1 = x1 + w / 2 * sin(endAngle);
        var ym0 = y0 + w / 2 * cos(startAngle);
        var ym1 = y1 + w / 2 * cos(endAngle);
        this.zIndex = this.zIndex || this.dataItem.index;
        var tensionX = this.tension + (1 - this.tension) * sin(startAngle);
        var tensionY = this.tension + (1 - this.tension) * cos(startAngle);
        this.middleLine.tensionX = tensionX;
        this.middleLine.tensionY = tensionY;
        if (isNumber(w) && (isNumber(x0) && isNumber(x1) && isNumber(y0) && isNumber(y1))) {
          if (round(xt0, 3) == round(xt1, 3)) {
            xt1 += 0.01;
          }
          if (round(yt0, 3) == round(yt1, 3)) {
            yt1 += 0.01;
          }
          if (round(xb0, 3) == round(xb1, 3)) {
            xb1 += 0.01;
          }
          if (round(yb0, 3) == round(yb1, 3)) {
            yb1 += 0.01;
          }
          var minX = Math.min(xb0, xb1, xt0, xt1);
          var minY = Math.min(yb0, yb1, yt0, yt1);
          var maxX = Math.max(xb0, xb1, xt0, xt1);
          var maxY = Math.max(yb0, yb1, yt0, yt1);
          this._bbox = {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
          var cpd = this.controlPointDistance;
          var kxt0 = xt0 + (xt1 - xt0) * cpd * cos(startAngle);
          var kyt0 = yt0 + (yt1 - yt0) * cpd * sin(startAngle);
          var kxt1 = xt1 - (xt1 - xt0) * cpd * cos(endAngle);
          var kyt1 = yt1 - (yt1 - yt0) * cpd * sin(endAngle);
          var kxm0 = xm0 + (xm1 - xm0) * cpd * cos(startAngle);
          var kym0 = ym0 + (ym1 - ym0) * cpd * sin(startAngle);
          var kxm1 = xm1 - (xm1 - xm0) * cpd * cos(endAngle);
          var kym1 = ym1 - (ym1 - ym0) * cpd * sin(endAngle);
          var angle = getAngle({ x: kxt0, y: kyt0 }, { x: kxt1, y: kyt1 });
          var dx = (w / cos(angle) - w) / tan(angle) * cos(startAngle);
          var dy = (w / sin(angle) - w) * tan(angle) * sin(startAngle);
          var kxb0 = -dx / 2 + xb0 + (xb1 - xb0) * cpd * cos(startAngle);
          var kyb0 = -dy / 2 + yb0 + (yb1 - yb0) * cpd * sin(startAngle);
          var kxb1 = -dx / 2 + xb1 - (xb1 - xb0) * cpd * cos(endAngle);
          var kyb1 = -dy / 2 + yb1 - (yb1 - yb0) * cpd * sin(endAngle);
          if (ym1 == ym0) {
            ym1 += 0.01;
          }
          this.middleLine.segments = [[{ x: xm0, y: ym0 }, { x: kxm0, y: kym0 }, { x: kxm1, y: kym1 }, { x: xm1, y: ym1 }]];
          kxt0 += dx / 2;
          kyt0 += dy / 2;
          kxt1 += dx / 2;
          kyt1 += dy / 2;
          path += moveTo({ x: xt0, y: yt0 });
          path += new Tension(tensionX, tensionY).smooth([{ x: xt0, y: yt0 }, { x: kxt0, y: kyt0 }, { x: kxt1, y: kyt1 }, { x: xt1, y: yt1 }]);
          path += lineTo({ x: xb1, y: yb1 });
          path += new Tension(tensionX, tensionY).smooth([{ x: xb1, y: yb1 }, { x: kxb1, y: kyb1 }, { x: kxb0, y: kyb0 }, { x: xb0, y: yb0 }]);
          path += closePath();
        }
        this.link.path = path;
        if (this.maskBullets) {
          this.bulletsMask.path = path;
          this.bulletsContainer.mask = this.bulletsMask;
        }
        this.positionBullets();
      }
    };
    Object.defineProperty(SankeyLink2.prototype, "startX", {
      /**
       * @return Start X
       */
      get: function() {
        return this.getPropertyValue("startX");
      },
      /**
       * [startX description]
       *
       * @todo Description
       * @param value  Start X
       */
      set: function(value) {
        this.setPropertyValue("startX", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(SankeyLink2.prototype, "endX", {
      /**
       * @return End X
       */
      get: function() {
        return this.getPropertyValue("endX");
      },
      /**
       * [endX description]
       *
       * @todo Description
       * @param value  End X
       */
      set: function(value) {
        this.setPropertyValue("endX", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(SankeyLink2.prototype, "startY", {
      /**
       * @return Start Y
       */
      get: function() {
        return this.getPropertyValue("startY");
      },
      /**
       * [startY description]
       *
       * @todo Description
       * @param value  Start Y
       */
      set: function(value) {
        this.setPropertyValue("startY", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(SankeyLink2.prototype, "endY", {
      /**
       * @return End Y
       */
      get: function() {
        return this.getPropertyValue("endY");
      },
      /**
       * [endY description]
       *
       * @todo Description
       * @param value End Y
       */
      set: function(value) {
        this.setPropertyValue("endY", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(SankeyLink2.prototype, "linkWidth", {
      /**
       * @return [description]
       */
      get: function() {
        return this.getPropertyValue("linkWidth");
      },
      /**
       * [linkWidth description]
       *
       * @todo Description
       * @param value [description]
       */
      set: function(value) {
        this.setPropertyValue("linkWidth", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(SankeyLink2.prototype, "controlPointDistance", {
      /**
       * @return relative control point distance
       */
      get: function() {
        return this.getPropertyValue("controlPointDistance");
      },
      /**
       * Distance of control point of a link, defines relative distance from a node at which linke should bend
       * @default 0.2
       * @param value
       */
      set: function(value) {
        this.setPropertyValue("controlPointDistance", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(SankeyLink2.prototype, "tension", {
      /**
       * @return tension value
       */
      get: function() {
        return this.getPropertyValue("tension");
      },
      /**
       * Tension of a spline, 1 would make the link to have sharp edges
       * @default 0.8
       * @param value
       */
      set: function(value) {
        this.setPropertyValue("tension", value, true);
      },
      enumerable: true,
      configurable: true
    });
    return SankeyLink2;
  }(FlowDiagramLink)
);
registry.registeredClasses["SankeyLink"] = SankeyLink;

// node_modules/@amcharts/amcharts4/.internal/charts/types/SankeyDiagram.js
var SankeyDiagramDataItem = (
  /** @class */
  function(_super) {
    __extends(SankeyDiagramDataItem2, _super);
    function SankeyDiagramDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "SankeyDiagramDataItem";
      _this.applyTheme();
      return _this;
    }
    return SankeyDiagramDataItem2;
  }(FlowDiagramDataItem)
);
var SankeyDiagram = (
  /** @class */
  function(_super) {
    __extends(SankeyDiagram2, _super);
    function SankeyDiagram2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "SankeyDiagram";
      _this.orientation = "horizontal";
      _this.nodeAlign = "middle";
      _this.nodesContainer.width = percent(100);
      _this.nodesContainer.height = percent(100);
      _this.linksContainer.width = percent(100);
      _this.linksContainer.height = percent(100);
      _this.applyTheme();
      return _this;
    }
    SankeyDiagram2.prototype.validateData = function() {
      var _this = this;
      this._valueHeight = void 0;
      _super.prototype.validateData.call(this);
      this._levelCount = 0;
      this.nodes.each(function(key, node) {
        node.level = void 0;
      });
      this.nodes.each(function(key, node) {
        node.level = _this.getNodeLevel(node, 0);
        _this._levelCount = max(_this._levelCount, node.level);
      });
    };
    SankeyDiagram2.prototype.getNodeLevel = function(node, level) {
      var _this = this;
      var levels = [level];
      each3(node.incomingDataItems.iterator(), function(link) {
        if (link.fromNode) {
          if (isNumber(link.fromNode.level)) {
            levels.push(link.fromNode.level + 1);
          } else {
            _this._counter = 0;
            _this.checkLoop(link.fromNode);
            if (_this._counter < _this.dataItems.length) {
              levels.push(_this.getNodeLevel(link.fromNode, level + 1));
            }
          }
        }
      });
      return Math.max.apply(Math, __spread(levels));
    };
    SankeyDiagram2.prototype.checkLoop = function(node) {
      var _this = this;
      this._counter++;
      if (this._counter > this.dataItems.length) {
        return;
      }
      each3(node.incomingDataItems.iterator(), function(link) {
        _this.checkLoop(link.fromNode);
      });
    };
    SankeyDiagram2.prototype.calculateValueHeight = function() {
      var _this = this;
      this._levelSum = {};
      this._levelNodesCount = {};
      this.maxSum = 0;
      var total = this.dataItem.values.value.sum;
      each3(this._sorted, function(strNode) {
        var node = strNode[1];
        _this.getNodeValue(node);
      });
      this.nodes.each(function(key, node) {
        var level = node.level;
        var value = Math.max(node.totalIncoming, node.totalOutgoing);
        if (value / total < _this.minNodeSize) {
          value = total * _this.minNodeSize;
        }
        if (isNumber(_this._levelSum[level])) {
          _this._levelSum[level] += value;
        } else {
          _this._levelSum[level] = value;
        }
        if (isNumber(_this._levelNodesCount[level])) {
          _this._levelNodesCount[level]++;
        } else {
          _this._levelNodesCount[level] = 1;
        }
      });
      var availableHeight;
      if (this.orientation == "horizontal") {
        availableHeight = this.chartContainer.maxHeight - 1;
      } else {
        availableHeight = this.chartContainer.maxWidth - 1;
      }
      var maxSumLevel;
      var minHeight;
      each2(this._levelSum, function(key, value) {
        var realValue = value;
        var levelNodeCount = _this._levelNodesCount[key];
        var valueHeight2 = (availableHeight - (levelNodeCount - 1) * _this.nodePadding) / realValue;
        if (valueHeight2 == Infinity) {
          valueHeight2 = 0;
        }
        if (minHeight > valueHeight2 || !isNumber(minHeight)) {
          minHeight = valueHeight2;
          _this.maxSum = realValue;
          maxSumLevel = toNumber(key);
        }
      });
      this._maxSumLevel = maxSumLevel;
      var maxSumLevelNodeCount = this._levelNodesCount[this._maxSumLevel];
      var valueHeight = (availableHeight - (maxSumLevelNodeCount - 1) * this.nodePadding) / this.maxSum;
      if (valueHeight == Infinity) {
        valueHeight = 0;
      }
      if (!isNumber(this.valueHeight)) {
        this.valueHeight = valueHeight;
      } else {
        var finalHeight = void 0;
        try {
          finalHeight = this._heightAnimation.animationOptions[0].to;
        } catch (err) {
        }
        if (finalHeight != valueHeight) {
          var duration = this.interpolationDuration;
          try {
            duration = this.nodes.template.states.getKey("active").transitionDuration;
          } catch (err) {
          }
          this._heightAnimation = new Animation(this, { property: "valueHeight", from: this.valueHeight, to: valueHeight }, duration, this.interpolationEasing).start();
          this._disposers.push(this._heightAnimation);
        }
      }
    };
    SankeyDiagram2.prototype.validate = function() {
      var _this = this;
      _super.prototype.validate.call(this);
      this.calculateValueHeight();
      var container = this.nodesContainer;
      var nextCoordinate = {};
      var maxSumLevelNodeCount = this._levelNodesCount[this._maxSumLevel];
      var total = this.dataItem.values.value.sum;
      var availableHeight;
      if (this.orientation == "horizontal") {
        availableHeight = this.chartContainer.maxHeight - 1;
      } else {
        availableHeight = this.chartContainer.maxWidth - 1;
      }
      each3(this._sorted, function(strNode) {
        var node = strNode[1];
        var level = node.level;
        var levelCoordinate = 0;
        var nodeCount = _this._levelNodesCount[level];
        switch (_this.nodeAlign) {
          case "bottom":
            levelCoordinate = (_this.maxSum - _this._levelSum[level]) * _this.valueHeight - (nodeCount - maxSumLevelNodeCount) * _this.nodePadding;
            break;
          case "middle":
            levelCoordinate = (_this.maxSum - _this._levelSum[level]) * _this.valueHeight / 2 - (nodeCount - maxSumLevelNodeCount) * _this.nodePadding / 2;
            break;
        }
        if (_this.maxSum == 0) {
          switch (_this.nodeAlign) {
            case "bottom":
              levelCoordinate = availableHeight - nodeCount * (_this.minNodeSize * availableHeight + _this.nodePadding);
              break;
            case "middle":
              levelCoordinate = availableHeight / 2 - nodeCount / 2 * (_this.minNodeSize * availableHeight + _this.nodePadding);
              break;
          }
        }
        node.parent = container;
        var delta;
        var x;
        var y;
        var value = Math.max(node.totalIncoming, node.totalOutgoing);
        if (value / total < _this.minNodeSize) {
          value = total * _this.minNodeSize;
        }
        if (_this.orientation == "horizontal") {
          delta = (_this.innerWidth - node.pixelWidth) / _this._levelCount;
          x = delta * node.level;
          y = nextCoordinate[level] || levelCoordinate;
          var h = value * _this.valueHeight;
          if (total == 0 && h == 0) {
            h = _this.minNodeSize * availableHeight;
          }
          node.height = h;
          node.minX = x;
          node.maxX = x;
          nextCoordinate[level] = y + h + _this.nodePadding;
        } else {
          delta = (_this.innerHeight - node.pixelHeight) / _this._levelCount;
          x = nextCoordinate[level] || levelCoordinate;
          y = delta * node.level;
          var w = value * _this.valueHeight;
          if (total == 0 && w == 0) {
            w = _this.minNodeSize * availableHeight;
          }
          node.width = w;
          node.minY = y;
          node.maxY = y;
          nextCoordinate[level] = x + w + _this.nodePadding;
        }
        node.x = x;
        node.y = y;
      });
    };
    SankeyDiagram2.prototype.showReal = function(duration) {
      var _this = this;
      if (this.preventShow) {
        return;
      }
      if (this.interpolationDuration > 0) {
        var container_1 = this.nodesContainer;
        var i_1 = 0;
        each3(this.links.iterator(), function(link) {
          link.hide(0);
        });
        each3(this._sorted, function(strNode) {
          var node = strNode[1];
          var property;
          if (_this.orientation == "horizontal") {
            node.dx = -(container_1.pixelWidth - node.pixelWidth) / Math.max(_this._levelCount, 1);
            property = "dx";
          } else {
            node.dy = -(container_1.pixelHeight - node.pixelHeight) / Math.max(_this._levelCount, 1);
            property = "dy";
          }
          var delay = 0;
          var duration2 = _this.interpolationDuration;
          if (_this.sequencedInterpolation) {
            delay = _this.sequencedInterpolationDelay * i_1 + duration2 * i_1 / length(_this.nodes.iterator());
          }
          node.opacity = 0;
          node.invalidateLinks();
          node.animate([{ property: "opacity", from: 0, to: 1 }, { property, to: 0 }], _this.interpolationDuration, _this.interpolationEasing).delay(delay);
          each3(node.outgoingDataItems.iterator(), function(dataItem) {
            var animation = dataItem.link.show(_this.interpolationDuration);
            if (animation && !animation.isFinished()) {
              animation.delay(delay);
            }
          });
          each3(node.incomingDataItems.iterator(), function(dataItem) {
            if (!dataItem.fromNode) {
              var animation = dataItem.link.show(_this.interpolationDuration);
              if (animation && !animation.isFinished()) {
                animation.delay(delay);
              }
            }
          });
          i_1++;
        });
      }
      return _super.prototype.showReal.call(this);
    };
    SankeyDiagram2.prototype.changeSorting = function() {
      var _this = this;
      this.sortNodes();
      var nextCoordinate = {};
      each3(this._sorted, function(strNode) {
        var node = strNode[1];
        var level = node.level;
        var levelCoordinate = (_this.maxSum - _this._levelSum[level]) * _this.valueHeight / 2;
        var property;
        var nodeHeight;
        if (_this.orientation == "horizontal") {
          property = "y";
          nodeHeight = node.pixelHeight;
        } else {
          property = "x";
          nodeHeight = node.pixelWidth;
        }
        node.animate({ property, to: nextCoordinate[level] || levelCoordinate }, _this.interpolationDuration, _this.interpolationEasing);
        nextCoordinate[level] = (nextCoordinate[level] || levelCoordinate) + nodeHeight + _this.nodePadding;
        node.invalidateLinks();
      });
    };
    SankeyDiagram2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Sankey diagram");
      }
    };
    SankeyDiagram2.prototype.createDataItem = function() {
      return new SankeyDiagramDataItem();
    };
    Object.defineProperty(SankeyDiagram2.prototype, "nodeAlign", {
      /**
       * @returns Returns nodeAlign value
       */
      get: function() {
        return this.getPropertyValue("nodeAlign");
      },
      /**
       * How to align nodes. In case layout is vertical, top means left and bottom means right
       *
       * @param value  Node sorting
       */
      set: function(value) {
        this.setPropertyValue("nodeAlign", value);
        this.changeSorting();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(SankeyDiagram2.prototype, "orientation", {
      /**
       * @return Orientation
       */
      get: function() {
        return this.getPropertyValue("orientation");
      },
      /**
       * Orientation of the chart: "horizontal" or "vertical";
       *
       * @param value Orientation
       */
      set: function(value) {
        this.setPropertyValue("orientation", value, true);
        var nameLabel = this.nodes.template.nameLabel;
        if (value == "vertical") {
          this.nodes.template.width = void 0;
          nameLabel.label.horizontalCenter = "middle";
          nameLabel.locationX = 0.5;
        } else {
          this.nodes.template.height = void 0;
          nameLabel.label.horizontalCenter = "left";
          nameLabel.locationX = 1;
        }
      },
      enumerable: true,
      configurable: true
    });
    SankeyDiagram2.prototype.createNode = function() {
      var node = new SankeyNode();
      this._disposers.push(node);
      return node;
    };
    SankeyDiagram2.prototype.createLink = function() {
      var link = new SankeyLink();
      this._disposers.push(link);
      return link;
    };
    Object.defineProperty(SankeyDiagram2.prototype, "valueHeight", {
      /**
       * @ignore
       */
      get: function() {
        return this._valueHeight;
      },
      /**
       * @ignore
       */
      set: function(value) {
        if (value != this._valueHeight) {
          this._valueHeight = value;
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    SankeyDiagram2.prototype.disposeData = function() {
      _super.prototype.disposeData.call(this);
      this._sorted = this.nodes.iterator();
    };
    return SankeyDiagram2;
  }(FlowDiagram)
);
registry.registeredClasses["SankeyDiagram"] = SankeyDiagram;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/ChordNode.js
var ChordNode = (
  /** @class */
  function(_super) {
    __extends(ChordNode2, _super);
    function ChordNode2() {
      var _this = _super.call(this) || this;
      _this.className = "ChordNode";
      var label = _this.createChild(AxisLabelCircular);
      label.location = 0.5;
      label.radius = 5;
      label.text = "{name}";
      label.zIndex = 1;
      label.shouldClone = false;
      _this.label = label;
      _this.layout = "none";
      _this.events.on("positionchanged", _this.updateRotation, _this, false);
      _this.isMeasured = false;
      _this.slice = _this.createChild(Slice);
      _this.slice.isMeasured = false;
      var hiddenState = _this.hiddenState;
      hiddenState.properties.fill = new InterfaceColorSet().getFor("disabledBackground");
      hiddenState.properties.opacity = 0.5;
      hiddenState.properties.visible = true;
      _this.setStateOnChildren = false;
      _this.slice.hiddenState.properties.visible = true;
      _this.adapter.add("tooltipX", function(tooltipX, target) {
        return target.slice.ix * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);
      });
      _this.adapter.add("tooltipY", function(tooltipY, target) {
        return target.slice.iy * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);
      });
      return _this;
    }
    ChordNode2.prototype.invalidateLinks = function() {
      var _this = this;
      _super.prototype.invalidateLinks.call(this);
      var label = this.label;
      var slice = this.slice;
      var chart = this.chart;
      if (chart && slice) {
        var sum = this.total;
        var arc_1 = slice.arc;
        var sliceStartAngle_1 = slice.startAngle;
        this.children.each(function(child) {
          if (child instanceof Bullet) {
            var locationX = child.locationX;
            if (!isNumber(locationX)) {
              locationX = 0.5;
            }
            var locationY = child.locationY;
            if (!isNumber(locationY)) {
              locationY = 1;
            }
            var childAngle = sliceStartAngle_1 + arc_1 * locationX;
            var childRadius = locationY * slice.radius;
            child.x = childRadius * cos(childAngle);
            child.y = childRadius * sin(childAngle);
          }
        });
        var labelAngle = sliceStartAngle_1 + arc_1 * label.location;
        var startAngle = sliceStartAngle_1 + (1 - sum / this.adjustedTotal) * arc_1 * 0.5;
        if (isNaN(startAngle)) {
          startAngle = sliceStartAngle_1;
        }
        label.fixPosition(labelAngle, slice.radius);
        this.nextAngle = startAngle;
        if (this._outgoingSorted) {
          each3(this._outgoingSorted, function(dataItem) {
            var link = dataItem.link;
            link.parent = _this.chart.linksContainer;
            var value = dataItem.getWorkingValue("value");
            if (isNumber(value)) {
              if (chart.nonRibbon) {
                var percentWidth = link.percentWidth;
                if (!isNumber(percentWidth)) {
                  percentWidth = 5;
                }
                percentWidth = percentWidth / 100;
                link.startAngle = sliceStartAngle_1 + arc_1 / 2 - arc_1 / 2 * percentWidth;
                link.arc = arc_1 * percentWidth;
              } else {
                link.arc = value * chart.valueAngle;
                link.startAngle = _this.nextAngle;
                _this.nextAngle += link.arc;
              }
              if (!dataItem.toNode) {
                link.endAngle = link.startAngle;
              }
              link.radius = slice.pixelInnerRadius;
            }
          });
        }
        if (this._incomingSorted) {
          each3(this._incomingSorted, function(dataItem) {
            var link = dataItem.link;
            link.radius = slice.pixelInnerRadius;
            if (chart.nonRibbon) {
              var percentWidth = link.percentWidth;
              if (!isNumber(percentWidth)) {
                percentWidth = 5;
              }
              percentWidth = percentWidth / 100;
              link.endAngle = sliceStartAngle_1 + arc_1 / 2 - arc_1 / 2 * percentWidth;
              link.arc = arc_1 * percentWidth;
            } else {
              link.endAngle = _this.nextAngle;
              var value = dataItem.getWorkingValue("value");
              if (isNumber(value)) {
                link.arc = value * chart.valueAngle;
                _this.nextAngle += link.arc;
              }
            }
            if (!dataItem.fromNode) {
              link.startAngle = link.endAngle;
            }
          });
        }
      }
    };
    ChordNode2.prototype.updateRotation = function() {
      var slice = this.slice;
      var mAngle = this.trueStartAngle + slice.arc / 2;
      var radius = slice.radius;
      var tx = radius * cos(mAngle);
      var ty = radius * sin(mAngle);
      var angle = getAngle({ x: tx + this.pixelX, y: ty + this.pixelY });
      slice.startAngle = this.trueStartAngle + (angle - mAngle);
      this.dx = -this.pixelX;
      this.dy = -this.pixelY;
    };
    ChordNode2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.label.copyFrom(source.label);
      this.slice.copyFrom(source.slice);
    };
    return ChordNode2;
  }(FlowDiagramNode)
);
registry.registeredClasses["ChordNode"] = ChordNode;

// node_modules/@amcharts/amcharts4/.internal/core/elements/QuadraticCurve.js
var QuadraticCurve = (
  /** @class */
  function(_super) {
    __extends(QuadraticCurve2, _super);
    function QuadraticCurve2() {
      var _this = _super.call(this) || this;
      _this.className = "QuadraticCurve";
      _this.element = _this.paper.add("path");
      _this.pixelPerfect = false;
      _this.fill = color();
      _this.applyTheme();
      return _this;
    }
    QuadraticCurve2.prototype.draw = function() {
      if (isNumber(this.x1 + this.x2 + this.y1 + this.y2 + this.cpx + this.cpy)) {
        var p1 = { x: this.x1, y: this.y1 };
        var p2 = { x: this.x2, y: this.y2 };
        var cp = { x: this.cpx, y: this.cpy };
        var d = moveTo(p1) + quadraticCurveTo(p2, cp);
        this.path = d;
      }
    };
    Object.defineProperty(QuadraticCurve2.prototype, "cpx", {
      /**
       * @return X
       */
      get: function() {
        return this.getPropertyValue("cpx");
      },
      /**
       * X coordinate of control point.
       *
       * @param value X
       */
      set: function(value) {
        this.setPropertyValue("cpx", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QuadraticCurve2.prototype, "cpy", {
      /**
       * @return Y
       */
      get: function() {
        return this.getPropertyValue("cpy");
      },
      /**
       * Y coordinate of control point.
       *
       * @param value Y
       */
      set: function(value) {
        this.setPropertyValue("cpy", value, true);
      },
      enumerable: true,
      configurable: true
    });
    QuadraticCurve2.prototype.positionToPoint = function(position) {
      var p1 = { x: this.x1, y: this.y1 };
      var cp = { x: this.cpx, y: this.cpy };
      var p2 = { x: this.x2, y: this.y2 };
      var point1 = getPointOnQuadraticCurve(p1, p2, cp, position);
      var point2 = getPointOnQuadraticCurve(p1, p2, cp, position + 1e-3);
      return { x: point1.x, y: point1.y, angle: getAngle(point1, point2) };
    };
    return QuadraticCurve2;
  }(Line)
);

// node_modules/@amcharts/amcharts4/.internal/charts/elements/ChordLink.js
var ChordLink = (
  /** @class */
  function(_super) {
    __extends(ChordLink2, _super);
    function ChordLink2() {
      var _this = _super.call(this) || this;
      _this.className = "ChordLink";
      _this.middleLine = _this.createChild(QuadraticCurve);
      _this.middleLine.shouldClone = false;
      _this.middleLine.strokeOpacity = 0;
      _this.applyTheme();
      return _this;
    }
    ChordLink2.prototype.validate = function() {
      _super.prototype.validate.call(this);
      if (!this.isTemplate) {
        var startAngle = this.startAngle;
        var endAngle = this.endAngle;
        var arc2 = this.arc;
        var radius = this.radius;
        var fromNode = this.dataItem.fromNode;
        var toNode = this.dataItem.toNode;
        var fromX = 0;
        var fromY = 0;
        if (fromNode) {
          fromX = fromNode.pixelX + fromNode.dx;
          fromY = fromNode.pixelY + fromNode.dy;
        }
        var toX = 0;
        var toY = 0;
        if (toNode) {
          toX = toNode.pixelX + toNode.dx;
          toY = toNode.pixelY + toNode.dy;
        }
        if (radius > 0) {
          var x1 = radius * cos(startAngle) + fromX;
          var y1 = radius * sin(startAngle) + fromY;
          var x2 = radius * cos(endAngle) + toX;
          var y2 = radius * sin(endAngle) + toY;
          var cp = { x: 0, y: 0 };
          var path = moveTo({ x: x1, y: y1 });
          path += arcTo(startAngle, arc2, radius);
          path += quadraticCurveTo({ x: x2, y: y2 }, cp);
          path += arcTo(endAngle, arc2, radius);
          path += quadraticCurveTo({ x: x1, y: y1 }, cp);
          if (arc2 > 0) {
            this.link.path = path;
          } else {
            this.link.path = "";
          }
          if (this.maskBullets) {
            this.bulletsMask.path = path;
            this.bulletsContainer.mask = this.bulletsMask;
          }
          var mAngle1 = startAngle + arc2 / 2;
          var mAngle2 = endAngle + arc2 / 2;
          var middleLine = this.middleLine;
          middleLine.x1 = radius * cos(mAngle1) + fromX;
          middleLine.y1 = radius * sin(mAngle1) + fromY;
          middleLine.x2 = radius * cos(mAngle2) + toX;
          middleLine.y2 = radius * sin(mAngle2) + toY;
          middleLine.cpx = 0;
          middleLine.cpy = 0;
          middleLine.stroke = this.fill;
          this.positionBullets();
        }
      }
    };
    Object.defineProperty(ChordLink2.prototype, "radius", {
      /**
       * @return End Y
       */
      get: function() {
        return this.getPropertyValue("radius");
      },
      /**
       * [radius description]
       *
       * @todo Description
       * @param value End Y
       */
      set: function(value) {
        this.setPropertyValue("radius", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ChordLink2.prototype, "arc", {
      /**
       * @return [description]
       */
      get: function() {
        return this.getPropertyValue("arc");
      },
      /**
       * [arc description]
       *
       * @todo Description
       * @param value [description]
       */
      set: function(value) {
        this.setPropertyValue("arc", value, true);
      },
      enumerable: true,
      configurable: true
    });
    return ChordLink2;
  }(FlowDiagramLink)
);
registry.registeredClasses["ChordLink"] = ChordLink;

// node_modules/@amcharts/amcharts4/.internal/charts/types/ChordDiagram.js
var ChordDiagramDataItem = (
  /** @class */
  function(_super) {
    __extends(ChordDiagramDataItem2, _super);
    function ChordDiagramDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "ChordDiagramDataItem";
      _this.applyTheme();
      return _this;
    }
    return ChordDiagramDataItem2;
  }(FlowDiagramDataItem)
);
var ChordDiagram = (
  /** @class */
  function(_super) {
    __extends(ChordDiagram2, _super);
    function ChordDiagram2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.valueAngle = 0;
      _this.className = "ChordDiagram";
      _this.startAngle = -90;
      _this.endAngle = 270;
      _this.radius = percent(80);
      _this.innerRadius = -15;
      _this.nodePadding = 5;
      var chordContainer = _this.chartContainer.createChild(Container);
      chordContainer.align = "center";
      chordContainer.valign = "middle";
      chordContainer.shouldClone = false;
      chordContainer.layout = "absolute";
      _this.chordContainer = chordContainer;
      _this.nodesContainer.parent = chordContainer;
      _this.linksContainer.parent = chordContainer;
      _this.chartContainer.events.on("maxsizechanged", _this.invalidate, _this, false);
      _this.applyTheme();
      return _this;
    }
    ChordDiagram2.prototype.validate = function() {
      var _this = this;
      var chartContainer = this.chartContainer;
      var endAngle = this.endAngle;
      var startAngle = this.startAngle + this.nodePadding / 2;
      var rect = getArcRect(this.startAngle, this.endAngle, 1);
      var innerRect = { x: 0, y: 0, width: 0, height: 0 };
      rect = getCommonRectangle([rect, innerRect]);
      var maxRadius = Math.min(chartContainer.innerWidth / rect.width, chartContainer.innerHeight / rect.height);
      if (!isNumber(maxRadius)) {
        maxRadius = 0;
      }
      var radius = relativeRadiusToValue(this.radius, maxRadius);
      var pixelInnerRadius = relativeRadiusToValue(this.innerRadius, radius, true);
      var total = this.dataItem.values.value.sum;
      var count = 0;
      var newTotal = 0;
      each3(this._sorted, function(strNode) {
        var node = strNode[1];
        _this.getNodeValue(node);
        count++;
        var value = node.total;
        if (node.total / total < _this.minNodeSize) {
          value = total * _this.minNodeSize;
        }
        newTotal += value;
      });
      this.valueAngle = (endAngle - this.startAngle - this.nodePadding * count) / newTotal;
      each3(this._sorted, function(strNode) {
        var node = strNode[1];
        var slice = node.slice;
        slice.radius = radius;
        slice.innerRadius = pixelInnerRadius;
        var value = node.total;
        if (node.total / total < _this.minNodeSize) {
          value = total * _this.minNodeSize;
        }
        node.adjustedTotal = value;
        var arc2;
        if (_this.nonRibbon) {
          arc2 = (endAngle - _this.startAngle) / count - _this.nodePadding;
        } else {
          arc2 = _this.valueAngle * value;
        }
        slice.arc = arc2;
        slice.startAngle = startAngle;
        node.trueStartAngle = startAngle;
        node.parent = _this.nodesContainer;
        node.validate();
        startAngle += arc2 + _this.nodePadding;
      });
      this.chordContainer.definedBBox = { x: radius * rect.x, y: radius * rect.y, width: radius * rect.width, height: radius * rect.height };
      this.chordContainer.invalidateLayout();
      _super.prototype.validate.call(this);
    };
    ChordDiagram2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Chord diagram");
      }
    };
    ChordDiagram2.prototype.createDataItem = function() {
      return new ChordDiagramDataItem();
    };
    Object.defineProperty(ChordDiagram2.prototype, "startAngle", {
      /**
       * @return Start angle (degrees)
       */
      get: function() {
        return this.getPropertyValue("startAngle");
      },
      /**
       * Starting angle of the Radar face. (degrees)
       *
       * Normally, a circular radar face begins (the radial axis is drawn) at the
       * top center. (at -90 degrees)
       *
       * You can use `startAngle` to change this setting.
       *
       * E.g. setting this to 0 will make the radial axis start horizontally to
       * the right, as opposed to vertical.
       *
       * For a perfect circle the absolute sum of `startAngle` and `endAngle`
       * needs to be 360.
       *
       * However, it's **not** necessary to do so. You can set those to lesser
       * numbers, to create semi-circles.
       *
       * E.g. `startAngle = -90` with `endAngle = 0` will create a radar face that
       * looks like a quarter of a circle.
       *
       * @default -90
       * @param value  Start angle (degrees)
       */
      set: function(value) {
        this.setPropertyValue("startAngle", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ChordDiagram2.prototype, "endAngle", {
      /**
       * @return End angle (degrees)
       */
      get: function() {
        return this.getPropertyValue("endAngle");
      },
      /**
       * Starting angle of the Radar face. (degrees)
       *
       * Normally, a circular radar face ends (the radial axis is drawn) exactly
       * where it has started, forming a full 360 circle. (at 270 degrees)
       *
       * You can use `endAngle` to end the circle somewhere else.
       *
       * E.g. setting this to 180 will make the radar face end at horizontal line
       * to the left off the center.
       *
       * For a perfect circle the absolute sum of `startAngle` and `endAngle`
       * needs to be 360.
       *
       * However, it's **not** necessary to do so. You can set those to lesser
       * numbers, to create semi-circles.
       *
       * E.g. `startAngle = -90` with `endAngle = 0` will create a radar face that
       * looks like a quarter of a circle.
       *
       * @default -90
       * @param value  End angle (degrees)
       */
      set: function(value) {
        this.setPropertyValue("endAngle", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ChordDiagram2.prototype, "radius", {
      /**
       * @return Outer radius
       */
      get: function() {
        return this.getPropertyValue("radius");
      },
      /**
       * Outer radius of the Radar face.
       *
       * This can either be in absolute pixel value, or relative [[Percent]].
       *
       * @param value  Outer radius
       */
      set: function(value) {
        this.setPercentProperty("radius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ChordDiagram2.prototype, "innerRadius", {
      /**
       * @return Inner radius
       */
      get: function() {
        return this.getPropertyValue("innerRadius");
      },
      /**
       * Inner radius of the Chord nodes.
       *
       * This can either be in absolute pixel value, or relative [[Percent]].
       *
       * @param value  Outer radius
       */
      set: function(value) {
        this.setPercentProperty("innerRadius", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ChordDiagram2.prototype, "nonRibbon", {
      /**
       * @return Non-ribbon
       */
      get: function() {
        return this.getPropertyValue("nonRibbon");
      },
      /**
       *
       * If you set this to true, all the lines will be of the same width. This is done by making middleLine of a ChordLink visible.
       *
       * @param value
       */
      set: function(value) {
        this.setPropertyValue("nonRibbon", value, true);
        this.links.template.middleLine.strokeOpacity = 1;
        this.links.template.link.fillOpacity = 0;
      },
      enumerable: true,
      configurable: true
    });
    ChordDiagram2.prototype.createNode = function() {
      var node = new ChordNode();
      this._disposers.push(node);
      return node;
    };
    ChordDiagram2.prototype.createLink = function() {
      var link = new ChordLink();
      this._disposers.push(link);
      return link;
    };
    return ChordDiagram2;
  }(FlowDiagram)
);
registry.registeredClasses["ChordDiagram"] = ChordDiagram;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/Column.js
var Column = (
  /** @class */
  function(_super) {
    __extends(Column2, _super);
    function Column2() {
      var _this = _super.call(this) || this;
      _this.className = "Column";
      _this.width = percent(80);
      _this.height = percent(80);
      _this.events.disableType("transformed");
      _this.applyOnClones = true;
      _this.strokeOpacity = 1;
      _this.layout = "none";
      _this.createAssets();
      _this.events.on("childadded", _this.handleKidAdded, _this, false);
      return _this;
    }
    Column2.prototype.handleKidAdded = function() {
      if (this.layout == "none") {
        this.layout = "absolute";
      }
    };
    Column2.prototype.createAssets = function() {
      this.column = this.createChild(RoundedRectangle);
      this.column.shouldClone = false;
      this.column.isMeasured = false;
      this.column.cornerRadius(0, 0, 0, 0);
      this._disposers.push(this.column);
    };
    Column2.prototype.validate = function() {
      _super.prototype.validate.call(this);
      var column = this.column;
      if (column) {
        column.width = min(this.pixelWidth, this.maxWidth);
        column.height = min(this.pixelHeight, this.maxHeight);
        if (column.invalid) {
          column.validate();
        }
      }
    };
    Column2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      if (this.column) {
        this.column.copyFrom(source.column);
      }
    };
    Object.defineProperty(Column2.prototype, "bbox", {
      /**
       * Returns bounding box (square) for this element.
       *
       * @ignore Exclude from docs
       */
      get: function() {
        if (this.definedBBox) {
          return this.definedBBox;
        }
        if (this.column) {
          return { x: 0, y: 0, width: this.column.measuredWidth, height: this.column.measuredHeight };
        } else {
          return { x: 0, y: 0, width: min(this.pixelWidth, this.maxWidth), height: min(this.pixelHeight, this.maxHeight) };
        }
      },
      enumerable: true,
      configurable: true
    });
    return Column2;
  }(Container)
);
registry.registeredClasses["Column"] = Column;

// node_modules/@amcharts/amcharts4/.internal/charts/series/ColumnSeries.js
var ColumnSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(ColumnSeriesDataItem2, _super);
    function ColumnSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "ColumnSeriesDataItem";
      _this.locations["dateX"] = 0.5;
      _this.locations["dateY"] = 0.5;
      _this.locations["categoryX"] = 0.5;
      _this.locations["categoryY"] = 0.5;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(ColumnSeriesDataItem2.prototype, "column", {
      /**
       * @return Column
       */
      get: function() {
        return this._column;
      },
      /**
       * A column used to draw a column for this data item.
       *
       * @param column
       */
      set: function(column) {
        this.setColumn(column);
      },
      enumerable: true,
      configurable: true
    });
    ColumnSeriesDataItem2.prototype.setColumn = function(column) {
      var _this = this;
      if (this._column && column != this._column) {
        remove(this.sprites, this._column);
      }
      this._column = column;
      if (column) {
        var prevDataItem = column.dataItem;
        if (prevDataItem && prevDataItem != this) {
          prevDataItem.column = void 0;
        }
        this.addSprite(column);
        this._disposers.push(new Disposer(function() {
          if (_this.component) {
            _this.component.columns.removeValue(column);
          }
        }));
      }
    };
    Object.defineProperty(ColumnSeriesDataItem2.prototype, "width", {
      get: function() {
        var width = this.properties.width;
        if (this._adapterO) {
          width = this._adapterO.apply("width", width);
        }
        return width;
      },
      set: function(value) {
        if (this.properties.width != value) {
          this.properties.width = value;
          if (this.component) {
            this.component.validateDataElement(this);
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ColumnSeriesDataItem2.prototype, "height", {
      get: function() {
        var height = this.properties.height;
        if (this._adapterO) {
          height = this._adapterO.apply("height", height);
        }
        return height;
      },
      set: function(value) {
        if (this.properties.height != value) {
          this.properties.height = value;
          if (this.component) {
            this.component.validateDataElement(this);
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ColumnSeriesDataItem2.prototype, "rangesColumns", {
      /**
       * A dictionary storing axes ranges columns by axis uid
       */
      get: function() {
        if (!this._rangesColumns) {
          this._rangesColumns = new Dictionary();
        }
        return this._rangesColumns;
      },
      enumerable: true,
      configurable: true
    });
    return ColumnSeriesDataItem2;
  }(XYSeriesDataItem)
);
var ColumnSeries = (
  /** @class */
  function(_super) {
    __extends(ColumnSeries2, _super);
    function ColumnSeries2() {
      var _this = _super.call(this) || this;
      _this._startLocation = 0;
      _this._endLocation = 1;
      _this.className = "ColumnSeries";
      _this.width = percent(100);
      _this.height = percent(100);
      _this.strokeOpacity = 0;
      _this.fillOpacity = 1;
      _this.clustered = true;
      var columnsContainer = _this.mainContainer.createChild(Container);
      columnsContainer.shouldClone = false;
      columnsContainer.isMeasured = false;
      columnsContainer.layout = "none";
      _this._columnsContainer = columnsContainer;
      _this.columns.template.pixelPerfect = false;
      _this.tooltipColorSource = _this.columns.template;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(ColumnSeries2.prototype, "columnsContainer", {
      /**
       * A container that columns are created in.
       *
       * @ignore Exclude from docs
       */
      get: function() {
        return this._columnsContainer;
      },
      enumerable: true,
      configurable: true
    });
    ColumnSeries2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Column Series");
      }
    };
    ColumnSeries2.prototype.createDataItem = function() {
      return new ColumnSeriesDataItem();
    };
    ColumnSeries2.prototype.validate = function() {
      var _this = this;
      this.group.node.removeAttribute("fill");
      if (this.chart && this.xAxis && this.yAxis) {
        var baseAxisSeries = this.chart.series;
        var clusterCount_1 = 0;
        var index_1 = 0;
        var sortedByAxis_1 = [];
        each3(baseAxisSeries.iterator(), function(series) {
          if (series instanceof ColumnSeries2) {
            if (_this.baseAxis == series.baseAxis) {
              var index_2;
              if (_this.baseAxis == _this.xAxis) {
                index_2 = _this.chart.yAxes.indexOf(series.yAxis);
              } else {
                index_2 = _this.chart.xAxes.indexOf(series.xAxis);
              }
              sortedByAxis_1.push({ series, axis: index_2 });
            }
          }
        });
        sortedByAxis_1.sort(function(a, b) {
          return a.axis - b.axis;
        });
        var prevAxisIndex_1;
        each(sortedByAxis_1, function(sortedItem) {
          var series = sortedItem.series;
          if (series instanceof ColumnSeries2) {
            if (!series.stacked && series.clustered || prevAxisIndex_1 != sortedItem.axis && series.clustered) {
              clusterCount_1++;
            }
            if (series == _this) {
              index_1 = clusterCount_1 - 1;
            }
          }
          prevAxisIndex_1 = sortedItem.axis;
        });
        if (!this.clustered) {
          index_1 = 0;
          clusterCount_1 = 1;
        }
        var renderer = this.baseAxis.renderer;
        var cellStartLocation = renderer.cellStartLocation;
        var cellEndLocation = renderer.cellEndLocation;
        this._startLocation = cellStartLocation + index_1 / clusterCount_1 * (cellEndLocation - cellStartLocation);
        this._endLocation = cellStartLocation + (index_1 + 1) / clusterCount_1 * (cellEndLocation - cellStartLocation);
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if (xAxis instanceof CategoryAxis && yAxis instanceof ValueAxis) {
          if (xAxis.sortBySeries == this) {
            this.sortCategoryAxis(xAxis, "valueY");
          }
        }
        if (yAxis instanceof CategoryAxis && xAxis instanceof ValueAxis) {
          if (yAxis.sortBySeries == this) {
            this.sortCategoryAxis(yAxis, "valueX");
          }
        }
      }
      _super.prototype.validate.call(this);
      for (var i = 0; i < this.startIndex; i++) {
        var dataItem = this.dataItems.getIndex(i);
        this.disableUnusedColumns(dataItem);
      }
      for (var i = this.dataItems.length - 1; i > this.endIndex; i--) {
        var dataItem = this.dataItems.getIndex(i);
        this.disableUnusedColumns(dataItem);
      }
      this._propertiesChanged = false;
    };
    ColumnSeries2.prototype.sortCategoryAxis = function(axis, key) {
      var _this = this;
      this.dataItems.values.sort(function(x, y) {
        return y.values[key].workingValue - x.values[key].workingValue;
      });
      var i = 0;
      this.dataItems.each(function(dataItem) {
        dataItem._index = i;
        i++;
      });
      axis.dataItems.each(function(dataItem) {
        var axis2 = dataItem.component;
        var currentPosition = axis2.categoryToPosition(dataItem.category) - dataItem.deltaPosition;
        var seriesDataItem = axis2.getSeriesDataItemByCategory(dataItem.category, _this);
        if (seriesDataItem) {
          var index = _this.dataItems.indexOf(seriesDataItem);
          dataItem._index = index;
          var deltaPosition = round((index + 0.5) / _this.dataItems.length - currentPosition, 3);
          if (dataItem.deltaAnimation && !dataItem.deltaAnimation.isDisposed() && dataItem.deltaAnimation.animationOptions[0].to == deltaPosition) {
          } else if (deltaPosition != round(dataItem.deltaPosition, 3)) {
            if (dataItem.deltaAnimation) {
              dataItem.deltaAnimation.stop();
            }
            dataItem.deltaAnimation = dataItem.animate({ property: "deltaPosition", from: -deltaPosition, to: 0 }, axis2.interpolationDuration, axis2.interpolationEasing);
            _this._disposers.push(dataItem.deltaAnimation);
          }
        }
      });
      axis.dataItems.values.sort(function(x, y) {
        return x.index - y.index;
      });
    };
    ColumnSeries2.prototype.validateDataElement = function(dataItem) {
      if (this.chart && this.xAxis && this.yAxis) {
        this.validateDataElementReal(dataItem);
        _super.prototype.validateDataElement.call(this, dataItem);
      }
    };
    ColumnSeries2.prototype.getStartLocation = function(dataItem) {
      var startLocation = this._startLocation;
      if (this.baseAxis == this.xAxis) {
        startLocation += dataItem.locations[this.xOpenField] - 0.5;
      } else {
        startLocation += dataItem.locations[this.yOpenField] - 0.5;
      }
      return startLocation;
    };
    ColumnSeries2.prototype.getEndLocation = function(dataItem) {
      var endLocation = this._endLocation;
      if (this.baseAxis == this.xAxis) {
        endLocation += dataItem.locations[this.xField] - 0.5;
      } else {
        endLocation += dataItem.locations[this.yField] - 0.5;
      }
      return endLocation;
    };
    ColumnSeries2.prototype.validateDataElementReal = function(dataItem) {
      var _this = this;
      var l;
      var r;
      var t;
      var b;
      var startLocation = this.getStartLocation(dataItem);
      var endLocation = this.getEndLocation(dataItem);
      var xField = this.xField;
      var xOpenField = this.xOpenField;
      var yField = this.yField;
      var yOpenField = this.yOpenField;
      var template = this.columns.template;
      var percentWidth = template.percentWidth;
      var percentHeight = template.percentHeight;
      var pixelWidth = template.pixelWidth;
      var pixelHeight = template.pixelHeight;
      var maxWidth = template.maxWidth;
      var maxHeight = template.maxHeight;
      var paddingLeft = template.pixelPaddingLeft;
      var paddingRight = template.pixelPaddingRight;
      var paddingTop = template.pixelPaddingTop;
      var paddingBottom = template.pixelPaddingBottom;
      var outOfBounds = false;
      var diw = dataItem.width;
      if (hasValue(diw)) {
        if (isNumber(diw)) {
          pixelWidth = diw;
        }
        if (diw instanceof Percent) {
          percentWidth = diw.value * 100;
        }
      }
      var dih = dataItem.height;
      if (hasValue(dih)) {
        if (isNumber(dih)) {
          pixelHeight = dih;
        }
        if (dih instanceof Percent) {
          percentHeight = dih.value * 100;
        }
      }
      if (this.xAxis instanceof CategoryAxis && this.yAxis instanceof CategoryAxis) {
        if (!dataItem.hasValue(this._xValueFields) || !dataItem.hasValue(this._yValueFields)) {
          return;
        }
        startLocation = 0;
        endLocation = 1;
        if (!isNaN(percentWidth)) {
          var offset = round((endLocation - startLocation) * (1 - percentWidth / 100) / 2, 5);
          startLocation += offset;
          endLocation -= offset;
        }
        l = this.xAxis.getX(dataItem, xOpenField, startLocation);
        r = this.xAxis.getX(dataItem, xField, endLocation);
        if (isNaN(percentWidth)) {
          var offset = (r - l - pixelWidth) / 2;
          l += offset;
          r -= offset;
        }
        if (!isNaN(maxWidth) && maxWidth < Math.abs(r - l)) {
          var offset = (r - l - maxWidth) / 2;
          l += offset;
          r -= offset;
        }
        startLocation = 0;
        endLocation = 1;
        if (!isNaN(percentHeight)) {
          var offset = round((1 - percentHeight / 100) / 2, 5);
          startLocation += offset;
          endLocation -= offset;
        }
        t = this.yAxis.getY(dataItem, yOpenField, startLocation);
        b = this.yAxis.getY(dataItem, yField, endLocation);
        if (isNaN(percentHeight)) {
          var offset = (b - t - pixelHeight) / 2;
          b += offset;
          t -= offset;
        }
        if (!isNaN(maxHeight) && maxHeight < Math.abs(b - t)) {
          var offset = (b - t - maxHeight) / 2;
          b += offset;
          t -= offset;
        }
        r = this.fixHorizontalCoordinate(r);
        l = this.fixHorizontalCoordinate(l);
        t = this.fixVerticalCoordinate(t);
        b = this.fixVerticalCoordinate(b);
      } else if (this.baseAxis == this.xAxis) {
        if (!dataItem.hasValue(this._yValueFields)) {
          return;
        }
        if (!isNaN(percentWidth)) {
          var offset = round((endLocation - startLocation) * (1 - percentWidth / 100) / 2, 5);
          startLocation += offset;
          endLocation -= offset;
        }
        l = this.xAxis.getX(dataItem, xOpenField, startLocation);
        r = this.xAxis.getX(dataItem, xField, endLocation);
        if (isNaN(percentWidth)) {
          var offset = (r - l - pixelWidth) / 2;
          l += offset;
          r -= offset;
        }
        if (!isNaN(maxWidth) && maxWidth < Math.abs(r - l)) {
          var offset = (r - l - maxWidth) / 2;
          l += offset;
          r -= offset;
        }
        var bottomLocation = dataItem.locations[yOpenField];
        var topLocation = dataItem.locations[yField];
        if (this.yAxis instanceof ValueAxis) {
          if (this.dataFields[this.yField] != this.dataFields[this.yOpenField]) {
            bottomLocation = 0;
            topLocation = 0;
          }
        }
        b = this.yAxis.getY(dataItem, yOpenField, bottomLocation);
        t = this.yAxis.getY(dataItem, yField, topLocation);
        var axisLenght = Math.ceil(this.yAxis.axisLength);
        if (t < 0 && b < 0 || t > axisLenght && b > axisLenght) {
          outOfBounds = true;
        }
        t = this.fixVerticalCoordinate(t);
        b = this.fixVerticalCoordinate(b);
        if (Math.abs(r - l) - paddingLeft - paddingRight == 0) {
          outOfBounds = true;
        }
      } else {
        if (!dataItem.hasValue(this._xValueFields)) {
          return;
        }
        if (!isNaN(percentHeight)) {
          var offset = round((endLocation - startLocation) * (1 - percentHeight / 100) / 2, 5);
          startLocation += offset;
          endLocation -= offset;
        }
        t = this.yAxis.getY(dataItem, yOpenField, startLocation);
        b = this.yAxis.getY(dataItem, yField, endLocation);
        if (isNaN(percentHeight)) {
          var offset = (b - t - pixelHeight) / 2;
          b -= offset;
          t += offset;
        }
        if (!isNaN(maxHeight) && maxHeight < Math.abs(b - t)) {
          var offset = (b - t - maxHeight) / 2;
          b -= offset;
          t += offset;
        }
        var rightLocation = dataItem.locations[xField];
        var leftLocation = dataItem.locations[xOpenField];
        if (this.xAxis instanceof ValueAxis) {
          if (this.dataFields[this.xField] != this.dataFields[this.xOpenField]) {
            rightLocation = 0;
            leftLocation = 0;
          }
        }
        r = this.xAxis.getX(dataItem, xField, rightLocation);
        l = this.xAxis.getX(dataItem, xOpenField, leftLocation);
        var axisLenght = Math.ceil(this.xAxis.axisLength);
        if (r < 0 && l < 0 || r > axisLenght && l > axisLenght) {
          outOfBounds = true;
        }
        r = this.fixHorizontalCoordinate(r);
        l = this.fixHorizontalCoordinate(l);
        if (Math.abs(t - b) - paddingTop - paddingBottom == 0) {
          outOfBounds = true;
        }
      }
      var w = Math.abs(r - l);
      var h = Math.abs(b - t);
      var x = Math.min(l, r);
      var y = Math.min(t, b);
      if (!outOfBounds) {
        var column_1;
        if (!dataItem.column) {
          column_1 = this.columns.create();
          copyProperties(this, column_1, visualProperties);
          copyProperties(this.columns.template, column_1, visualProperties);
          dataItem.addSprite(column_1);
          dataItem.column = column_1;
          column_1.paper = this.paper;
          if (this.itemsFocusable()) {
            if (!hasValue(this.role)) {
              this.role = "menu";
            }
            if (!hasValue(column_1.role)) {
              column_1.role = "menuitem";
            }
            column_1.focusable = true;
          } else {
            if (!hasValue(this.role)) {
              this.role = "list";
            }
            if (!hasValue(column_1.role)) {
              column_1.role = "listitem";
            }
            column_1.focusable = false;
          }
          if (column_1.focusable) {
            column_1.events.on("focus", function(ev) {
              column_1.readerTitle = _this.populateString(_this.itemReaderText, dataItem);
            }, void 0, false);
            column_1.events.on("blur", function(ev) {
              column_1.readerTitle = "";
            }, void 0, false);
          }
          if (column_1.hoverable) {
            column_1.events.on("over", function(ev) {
              column_1.readerTitle = _this.populateString(_this.itemReaderText, dataItem);
            }, void 0, false);
            column_1.events.on("out", function(ev) {
              column_1.readerTitle = "";
            }, void 0, false);
          }
          column_1.parent = this.columnsContainer;
          column_1.virtualParent = this;
        } else {
          column_1 = dataItem.column;
          if (this._propertiesChanged) {
            copyProperties(this, column_1, visualProperties);
            copyProperties(this.columns.template, column_1, visualProperties);
            each(visualProperties, function(property) {
              column_1[property] = column_1[property];
            });
          }
        }
        column_1.width = w;
        column_1.height = h;
        column_1.x = x;
        column_1.y = y;
        column_1.realX = l;
        column_1.realY = t;
        column_1.realWidth = r - l;
        column_1.realHeight = b - t;
        this.setColumnStates(column_1);
        if (column_1.invalid) {
          column_1.validate();
        }
        column_1.__disabled = false;
        each3(this.axisRanges.iterator(), function(axisRange) {
          var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);
          if (!rangeColumn) {
            rangeColumn = _this.columns.create();
            copyProperties(axisRange.contents, rangeColumn, visualProperties);
            dataItem.addSprite(rangeColumn);
            dataItem.rangesColumns.setKey(axisRange.uid, rangeColumn);
            rangeColumn.paper = _this.paper;
          }
          rangeColumn.parent = axisRange.contents;
          rangeColumn.width = w;
          rangeColumn.height = h;
          rangeColumn.x = x;
          rangeColumn.y = y;
          _this.setColumnStates(rangeColumn);
          if (rangeColumn.invalid) {
            rangeColumn.validate();
          }
          rangeColumn.__disabled = false;
        });
      } else {
        this.disableUnusedColumns(dataItem);
      }
      dataItem.itemWidth = w;
      dataItem.itemHeight = h;
    };
    ColumnSeries2.prototype.disableUnusedColumns = function(dataItem) {
      if (dataItem) {
        if (dataItem.column) {
          dataItem.column.width = 0;
          dataItem.column.height = 0;
          dataItem.column.__disabled = true;
        }
        each3(this.axisRanges.iterator(), function(axisRange) {
          var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);
          if (rangeColumn) {
            rangeColumn.width = 0;
            rangeColumn.height = 0;
            rangeColumn.__disabled = true;
          }
        });
      }
    };
    ColumnSeries2.prototype.setColumnStates = function(sprite) {
      if (this._dropFromOpenState || this._dropFromPreviousState || this._riseFromOpenState || this._riseFromPreviousState) {
        var dataItem = sprite.dataItem;
        if (this.xAxis instanceof ValueAxis || this.yAxis instanceof ValueAxis) {
          var open_1;
          var value = void 0;
          var change = void 0;
          if (this.baseAxis == this.yAxis) {
            if (this.xOpenField && this.xField && this.xAxis instanceof ValueAxis) {
              open_1 = dataItem.getValue(this.xOpenField);
              value = dataItem.getValue(this.xField);
            }
            change = dataItem.getValue(this.xAxis.axisFieldName + "X", "previousChange");
          } else {
            if (this.yOpenField && this.yField && this.yAxis instanceof ValueAxis) {
              open_1 = dataItem.getValue(this.yOpenField);
              value = dataItem.getValue(this.yField);
            }
            change = dataItem.getValue(this.yAxis.axisFieldName + "Y", "previousChange");
          }
          if (value < open_1) {
            dataItem.droppedFromOpen = true;
            sprite.defaultState.copyFrom(this._dropFromOpenState);
            sprite.setState(this._dropFromOpenState, 0);
          } else {
            dataItem.droppedFromOpen = false;
            sprite.defaultState.copyFrom(this._riseFromOpenState);
            sprite.setState(this._riseFromOpenState, 0);
          }
          if (change < 0) {
            dataItem.droppedFromPrevious = true;
            sprite.defaultState.copyFrom(this._dropFromPreviousState);
            sprite.setState(this._dropFromPreviousState, 0);
          } else {
            dataItem.droppedFromPrevious = false;
            sprite.defaultState.copyFrom(this._riseFromPreviousState);
            sprite.setState(this._riseFromPreviousState, 0);
          }
        }
      }
    };
    Object.defineProperty(ColumnSeries2.prototype, "columns", {
      /**
       * A list of column elements in the series.
       *
       * @return Columns
       */
      get: function() {
        if (!this._columns) {
          this._columns = new ListTemplate(this.createColumnTemplate());
          this._disposers.push(new ListDisposer(this._columns));
          this._disposers.push(this._columns.template);
        }
        return this._columns;
      },
      enumerable: true,
      configurable: true
    });
    ColumnSeries2.prototype.createColumnTemplate = function() {
      return new Column();
    };
    Object.defineProperty(ColumnSeries2.prototype, "clustered", {
      /**
       * @return Clustered?
       */
      get: function() {
        return this.getPropertyValue("clustered");
      },
      /**
       * Cluster this series columns?
       *
       * Setting to `false` will make columns overlap with other series.
       *
       * @default true
       * @param value  Clustered?
       */
      set: function(value) {
        this.setPropertyValue("clustered", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ColumnSeries2.prototype, "dropFromOpenState", {
      /**
       * @return State
       */
      get: function() {
        if (!this._dropFromOpenState) {
          this._dropFromOpenState = this.states.create("dropFromOpenState");
        }
        return this._dropFromOpenState;
      },
      /**
       * A state to apply to a column when close value is lower than open value.
       *
       * Can be used to differentiate appearance based on value relations.
       *
       * NOTE: this will work only if at least one axis is [[ValueAxis]].
       *
       * @readonly You can modify state object, but can't overwrite it
       * @param  value  State
       */
      set: function(value) {
        this._dropFromOpenState = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ColumnSeries2.prototype, "dropFromPreviousState", {
      /**
       * @return State
       */
      get: function() {
        if (!this._dropFromPreviousState) {
          this._dropFromPreviousState = this.states.create("dropFromPreviousState");
        }
        return this._dropFromPreviousState;
      },
      /**
       * A state to apply to a column when its value is lower value of a previous
       * column.
       *
       * Can be used to differentiate appearance based on value relations.
       *
       * @readonly You can modify state object, but can't overwrite it
       * @param  value  State
       */
      set: function(value) {
        this._dropFromPreviousState = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ColumnSeries2.prototype, "riseFromOpenState", {
      /**
       * @return State
       */
      get: function() {
        if (!this._riseFromOpenState) {
          this._riseFromOpenState = this.states.create("riseFromOpenState");
        }
        return this._riseFromOpenState;
      },
      /**
       * A state to apply to a column when close value is same or higher than open
       * value.
       *
       * Can be used to differentiate appearance based on value relations.
       *
       * NOTE: this will work only if at least one axis is [[ValueAxis]].
       *
       * @readonly You can modify state object, but can't overwrite it
       * @param  value  State
       */
      set: function(value) {
        this._riseFromOpenState = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ColumnSeries2.prototype, "riseFromPreviousState", {
      /**
       * @return State
       */
      get: function() {
        if (!this._riseFromPreviousState) {
          this._riseFromPreviousState = this.states.create("riseFromPreviousState");
        }
        return this._riseFromPreviousState;
      },
      /**
       * A state to apply to a column when its value is same or higher than value
       * of a previous column.
       *
       * Can be used to differentiate appearance based on value relations.
       *
       * @readonly You can modify state object, but can't overwrite it
       * @param  value  State
       */
      set: function(value) {
        this._riseFromPreviousState = value;
      },
      enumerable: true,
      configurable: true
    });
    ColumnSeries2.prototype.updateLegendValue = function(dataItem, notRange) {
      var _this = this;
      _super.prototype.updateLegendValue.call(this, dataItem, notRange);
      if (this.legendDataItem) {
        var marker = this.legendDataItem.marker;
        var fromOpenState_1;
        var fromPreviousState_1;
        if (dataItem) {
          if (dataItem.droppedFromOpen) {
            fromOpenState_1 = this._dropFromOpenState;
          } else {
            fromOpenState_1 = this._riseFromOpenState;
          }
          if (dataItem.droppedFromPrevious) {
            fromPreviousState_1 = this._dropFromPreviousState;
          } else {
            fromPreviousState_1 = this._riseFromPreviousState;
          }
        }
        each3(marker.children.iterator(), function(child) {
          if (dataItem) {
            child.setState(fromPreviousState_1);
            child.setState(fromOpenState_1);
          } else {
            child.setState(_this._riseFromPreviousState);
            child.setState(_this._riseFromOpenState);
          }
        });
      }
    };
    ColumnSeries2.prototype.createLegendMarker = function(marker) {
      var w = marker.pixelWidth;
      var h = marker.pixelHeight;
      marker.removeChildren();
      var column = marker.createChild(RoundedRectangle);
      column.shouldClone = false;
      copyProperties(this, column, visualProperties);
      column.copyFrom(this.columns.template);
      column.padding(0, 0, 0, 0);
      column.width = w;
      column.height = h;
      var legendDataItem = marker.dataItem;
      legendDataItem.color = this.fill;
      legendDataItem.colorOrig = this.fill;
    };
    ColumnSeries2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.columns.template.copyFrom(source.columns.template);
    };
    ColumnSeries2.prototype.getBulletLocationX = function(bullet, field) {
      if (this.baseAxis == this.xAxis) {
        var bulletLocationX = bullet.locationX;
        if (!isNumber(bulletLocationX)) {
          bulletLocationX = 0.5;
        }
        var endLocation = this.getEndLocation(bullet.dataItem);
        var startLocation = this.getStartLocation(bullet.dataItem);
        return endLocation - (endLocation - startLocation) * bulletLocationX;
      } else {
        return _super.prototype.getBulletLocationX.call(this, bullet, field);
      }
    };
    ColumnSeries2.prototype.getBulletLocationY = function(bullet, field) {
      if (this.baseAxis == this.yAxis) {
        var bulletLocationY = bullet.locationY;
        if (!isNumber(bulletLocationY)) {
          bulletLocationY = 0.5;
        }
        var endLocation = this.getEndLocation(bullet.dataItem);
        var startLocation = this.getStartLocation(bullet.dataItem);
        return endLocation - (endLocation - startLocation) * bulletLocationY;
      } else {
        return _super.prototype.getBulletLocationY.call(this, bullet, field);
      }
    };
    ColumnSeries2.prototype.getAdjustedXLocation = function(dataItem, field, bulletLocationX) {
      if (!isNumber(bulletLocationX)) {
        if (dataItem) {
          bulletLocationX = dataItem.locations[field];
        } else {
          bulletLocationX = 0.5;
        }
      }
      return this._endLocation - (this._endLocation - this._startLocation) * (1 - bulletLocationX);
    };
    ColumnSeries2.prototype.getAdjustedYLocation = function(dataItem, field, bulletLocationY) {
      if (!isNumber(bulletLocationY)) {
        if (dataItem) {
          bulletLocationY = dataItem.locations[field];
        } else {
          bulletLocationY = 0.5;
        }
      }
      return this._endLocation - (this._endLocation - this._startLocation) * bulletLocationY;
    };
    ColumnSeries2.prototype.fixVerticalCoordinate = function(coordinate) {
      var paddingBottom = this.columns.template.pixelPaddingBottom;
      var paddingTop = this.columns.template.pixelPaddingTop;
      var minY = -paddingTop;
      var maxY = this.yAxis.axisLength + paddingBottom;
      return fitToRange(coordinate, minY, maxY);
    };
    ColumnSeries2.prototype.fixHorizontalCoordinate = function(coordinate) {
      var paddingLeft = this.columns.template.pixelPaddingLeft;
      var paddingRight = this.columns.template.pixelPaddingRight;
      var minX = -paddingLeft;
      var maxX = this.xAxis.axisLength + paddingRight;
      return fitToRange(coordinate, minX, maxX);
    };
    ColumnSeries2.prototype.disposeData = function() {
      _super.prototype.disposeData.call(this);
      this.columns.clear();
    };
    return ColumnSeries2;
  }(XYSeries)
);
registry.registeredClasses["ColumnSeries"] = ColumnSeries;
registry.registeredClasses["ColumnSeriesDataItem"] = ColumnSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/series/TreeMapSeries.js
var TreeMapSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(TreeMapSeriesDataItem2, _super);
    function TreeMapSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "TreeMapSeriesDataItem";
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(TreeMapSeriesDataItem2.prototype, "parentName", {
      /**
       * Data for the this particular item.
       *
       * @param value  Item's data
       */
      //public set dataContext(value: Object) {
      //	this._dataContext = value;
      //}
      /**
       * @return Item's data
       */
      /*
      public get dataContext(): Object {
          // It's because data of tree series is TreeMapDataItems.
          if (this._dataContext) {
              return (<any>this._dataContext).dataContext;
          }
      }*/
      /**
       * The name of the item's parent item.
       *
       * @return Parent name
       */
      get: function() {
        var treeMapDataItem = this.treeMapDataItem;
        if (treeMapDataItem && treeMapDataItem.parent) {
          return treeMapDataItem.parent.name;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMapSeriesDataItem2.prototype, "value", {
      /**
       * Item's numeric value.
       *
       * @readonly
       * @return Value
       */
      get: function() {
        var treeMapDataItem = this.treeMapDataItem;
        if (treeMapDataItem) {
          return treeMapDataItem.value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMapSeriesDataItem2.prototype, "treeMapDataItem", {
      /**
       * A corresponding data item from the tree map.
       *
       * @readonly
       * @return Data item
       */
      get: function() {
        return this._dataContext;
      },
      enumerable: true,
      configurable: true
    });
    TreeMapSeriesDataItem2.prototype.hide = function(duration, delay, toValue, fields) {
      var treeMapDataItem = this.treeMapDataItem;
      if (treeMapDataItem) {
        treeMapDataItem.hide(duration);
      }
      return _super.prototype.hide.call(this, duration, delay, toValue, fields);
    };
    TreeMapSeriesDataItem2.prototype.show = function(duration, delay, fields) {
      var treeMapDataItem = this.treeMapDataItem;
      if (treeMapDataItem) {
        treeMapDataItem.show(duration, delay, fields);
      }
      return _super.prototype.show.call(this, duration, delay, fields);
    };
    return TreeMapSeriesDataItem2;
  }(ColumnSeriesDataItem)
);
var TreeMapSeries = (
  /** @class */
  function(_super) {
    __extends(TreeMapSeries2, _super);
    function TreeMapSeries2() {
      var _this = _super.call(this) || this;
      _this.className = "TreeMapSeries";
      _this.applyTheme();
      _this.fillOpacity = 1;
      _this.strokeOpacity = 1;
      _this.minBulletDistance = 0;
      _this.columns.template.tooltipText = "{parentName} {name}: {value}";
      _this.columns.template.configField = "config";
      var interfaceColors = new InterfaceColorSet();
      _this.stroke = interfaceColors.getFor("background");
      _this.dataFields.openValueX = "x0";
      _this.dataFields.valueX = "x1";
      _this.dataFields.openValueY = "y0";
      _this.dataFields.valueY = "y1";
      _this.sequencedInterpolation = false;
      _this.showOnInit = false;
      _this.columns.template.pixelPerfect = false;
      return _this;
    }
    TreeMapSeries2.prototype.processDataItem = function(dataItem, dataContext) {
      dataContext.seriesDataItem = dataItem;
      _super.prototype.processDataItem.call(this, dataItem, dataContext);
    };
    TreeMapSeries2.prototype.createDataItem = function() {
      return new TreeMapSeriesDataItem();
    };
    TreeMapSeries2.prototype.show = function(duration) {
      if (this.preventShow) {
        return;
      }
      var interpolationDuration = this.defaultState.transitionDuration;
      if (isNumber(duration)) {
        interpolationDuration = duration;
      }
      this.dataItems.each(function(dataItem) {
        dataItem.show(duration);
      });
      return _super.prototype.showReal.call(this, interpolationDuration);
    };
    TreeMapSeries2.prototype.hide = function(duration) {
      var interpolationDuration = this.defaultState.transitionDuration;
      if (isNumber(duration)) {
        interpolationDuration = duration;
      }
      var animation = _super.prototype.hideReal.call(this, interpolationDuration);
      this.dataItems.each(function(dataItem) {
        dataItem.hide(duration);
      });
      return animation;
    };
    TreeMapSeries2.prototype.processValues = function() {
    };
    TreeMapSeries2.prototype.getStartLocation = function(dataItem) {
      return 0;
    };
    TreeMapSeries2.prototype.getEndLocation = function(dataItem) {
      return 1;
    };
    TreeMapSeries2.prototype.dataChangeUpdate = function() {
    };
    TreeMapSeries2.prototype.processConfig = function(config) {
      if (config) {
        if (!hasValue(config.dataFields) || !isObject(config.dataFields)) {
          config.dataFields = {};
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    TreeMapSeries2.prototype.createLegendMarker = function(marker) {
      var w = marker.pixelWidth;
      var h = marker.pixelHeight;
      marker.removeChildren();
      var column = marker.createChild(RoundedRectangle);
      column.shouldClone = false;
      copyProperties(this, column, visualProperties);
      column.padding(0, 0, 0, 0);
      column.width = w;
      column.height = h;
      var legendDataItem = marker.dataItem;
      legendDataItem.color = column.fill;
      legendDataItem.colorOrig = column.fill;
    };
    TreeMapSeries2.prototype.disableUnusedColumns = function(dataItem) {
      _super.prototype.disableUnusedColumns.call(this, dataItem);
      if (dataItem.column) {
        dataItem.column.__disabled = false;
      }
    };
    return TreeMapSeries2;
  }(ColumnSeries)
);
registry.registeredClasses["TreeMapSeries"] = TreeMapSeries;
registry.registeredClasses["TreeMapSeriesDataItem"] = TreeMapSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/types/TreeMap.js
var TreeMapDataItem = (
  /** @class */
  function(_super) {
    __extends(TreeMapDataItem2, _super);
    function TreeMapDataItem2() {
      var _this = _super.call(this) || this;
      _this.rows = [];
      _this.className = "TreeMapDataItem";
      _this.values.value = { workingValue: 0 };
      _this.values.x0 = {};
      _this.values.y0 = {};
      _this.values.x1 = {};
      _this.values.y1 = {};
      _this.hasChildren.children = true;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(TreeMapDataItem2.prototype, "legendDataItem", {
      /**
       * @return Legend data item
       */
      get: function() {
        return this._legendDataItem;
      },
      /**
       * A legend's data item, that corresponds to this data item.
       *
       * @param value  Legend data item
       */
      set: function(value) {
        this._legendDataItem = value;
        if (value.label) {
          value.label.dataItem = this;
        }
        if (value.valueLabel) {
          value.valueLabel.dataItem = this;
        }
      },
      enumerable: true,
      configurable: true
    });
    TreeMapDataItem2.prototype.getDuration = function() {
      return 0;
    };
    Object.defineProperty(TreeMapDataItem2.prototype, "value", {
      /**
       * @return Value
       */
      get: function() {
        var value = 0;
        if (!this.children || this.children.length == 0) {
          value = this.values["value"].workingValue;
        } else {
          each3(this.children.iterator(), function(child) {
            var childValue = child.value;
            if (isNumber(childValue)) {
              value += childValue;
            }
          });
        }
        return value;
      },
      /**
       * Numeric value of the item.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("value", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMapDataItem2.prototype, "percent", {
      /**
       * Percent value of a node
       */
      get: function() {
        if (this.parent) {
          return this.value / this.parent.value * 100;
        }
        return 100;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMapDataItem2.prototype, "x0", {
      /**
       * @return X
       */
      get: function() {
        return this.values.x0.value;
      },
      /**
       * Item's X position.
       *
       * @ignore Exclude from docs
       * @todo Description (review)
       * @param value  X
       */
      set: function(value) {
        this.setValue("x0", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMapDataItem2.prototype, "x1", {
      /**
       * @return X
       */
      get: function() {
        return this.values.x1.value;
      },
      /**
       * Item's X position.
       *
       * @ignore Exclude from docs
       * @todo Description (review)
       * @param value  X
       */
      set: function(value) {
        this.setValue("x1", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMapDataItem2.prototype, "y0", {
      /**
       * @return Y
       */
      get: function() {
        return this.values.y0.value;
      },
      /**
       * Item's Y position.
       *
       * @ignore Exclude from docs
       * @todo Description (review)
       * @param value  Y
       */
      set: function(value) {
        this.setValue("y0", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMapDataItem2.prototype, "y1", {
      /**
       * @return Y
       */
      get: function() {
        return this.values.y1.value;
      },
      /**
       * Item's Y position.
       *
       * @ignore Exclude from docs
       * @todo Description (review)
       * @param value  Y
       */
      set: function(value) {
        this.setValue("y1", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMapDataItem2.prototype, "name", {
      /**
       * @return Name
       */
      get: function() {
        return this.properties.name;
      },
      /**
       * Item's name.
       *
       * @param name  Name
       */
      set: function(name) {
        this.setProperty("name", name);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMapDataItem2.prototype, "children", {
      /**
       * @return Item's children
       */
      get: function() {
        return this.properties.children;
      },
      /**
       * A list of item's sub-children.
       *
       * Having children means that the TreeMap chat will automatically be
       * "drillable". Clicking on an item with children will zoom to the item, then
       * display its children.
       *
       * Treemap can have any level of nesting.
       *
       * @param children  Item's children
       */
      set: function(children) {
        this.setProperty("children", children);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMapDataItem2.prototype, "level", {
      /**
       * Depth level in the treemap hierarchy.
       *
       * The top-level item will have level set at 0. Its children will have
       * level 1, and so on.
       *
       * @readonly
       * @return Level
       */
      get: function() {
        if (!this.parent) {
          return 0;
        } else {
          return this.parent.level + 1;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMapDataItem2.prototype, "color", {
      /**
       * @return Color
       */
      get: function() {
        var color2 = this.properties.color;
        if (color2 == void 0) {
          if (this.parent) {
            color2 = this.parent.color;
          }
        }
        if (color2 == void 0) {
          if (this.component) {
            color2 = this.component.colors.getIndex(this.component.colors.step * this.index);
          }
        }
        return color2;
      },
      /**
       * Item's color.
       *
       * If not set, will use parent's color, or, if that is not set either,
       * automatically assigned color from chart's color set. (`chart.colors`)
       *
       * @param value  Color
       */
      set: function(value) {
        this.setProperty("color", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMapDataItem2.prototype, "fill", {
      /**
       * @ignore
       * For the legend to work properly
       */
      get: function() {
        return this.color;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMapDataItem2.prototype, "series", {
      get: function() {
        return this._series;
      },
      /**
       * Series of children data items
       * @todo: proper descrition
       */
      set: function(series) {
        if (series != this._series) {
          if (this._series) {
            this.component.series.removeValue(this._series);
            this._series.dispose();
          }
          this._series = series;
          this._disposers.push(series);
        }
      },
      enumerable: true,
      configurable: true
    });
    TreeMapDataItem2.prototype.hide = function(duration, delay, toValue, fields) {
      this.setWorkingValue("value", 0);
      if (this.children) {
        this.children.each(function(child) {
          child.hide(duration, delay, toValue, fields);
        });
      }
      var seriesDataItem = this.seriesDataItem;
      if (seriesDataItem) {
        seriesDataItem.bullets.each(function(key, value) {
          value.hide();
          value.preventShow = true;
        });
      }
      return _super.prototype.hide.call(this, duration, delay, toValue, fields);
    };
    TreeMapDataItem2.prototype.show = function(duration, delay, fields) {
      this.setWorkingValue("value", this.values.value.value);
      if (this.children) {
        this.children.each(function(child) {
          child.show(duration, delay, fields);
        });
      }
      var seriesDataItem = this.seriesDataItem;
      if (seriesDataItem) {
        seriesDataItem.bullets.each(function(key, value) {
          value.preventShow = false;
        });
      }
      return _super.prototype.show.call(this, duration, delay, fields);
    };
    return TreeMapDataItem2;
  }(XYChartDataItem)
);
var TreeMap = (
  /** @class */
  function(_super) {
    __extends(TreeMap2, _super);
    function TreeMap2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.layoutAlgorithm = _this.squarify;
      _this.zoomable = true;
      _this.className = "TreeMap";
      _this._usesData = true;
      _this.maxLevels = 2;
      _this.currentLevel = 0;
      _this.hideParentColumns = false;
      _this.colors = new ColorSet();
      _this.sorting = "descending";
      var xAxis = _this.xAxes.push(new ValueAxis());
      xAxis.title.disabled = true;
      xAxis.strictMinMax = true;
      var xRenderer = xAxis.renderer;
      xRenderer.inside = true;
      xRenderer.labels.template.disabled = true;
      xRenderer.ticks.template.disabled = true;
      xRenderer.grid.template.disabled = true;
      xRenderer.axisFills.template.disabled = true;
      xRenderer.minGridDistance = 100;
      xRenderer.line.disabled = true;
      xRenderer.baseGrid.disabled = true;
      var yAxis = _this.yAxes.push(new ValueAxis());
      yAxis.title.disabled = true;
      yAxis.strictMinMax = true;
      var yRenderer = yAxis.renderer;
      yRenderer.inside = true;
      yRenderer.labels.template.disabled = true;
      yRenderer.ticks.template.disabled = true;
      yRenderer.grid.template.disabled = true;
      yRenderer.axisFills.template.disabled = true;
      yRenderer.minGridDistance = 100;
      yRenderer.line.disabled = true;
      yRenderer.baseGrid.disabled = true;
      yRenderer.inversed = true;
      _this.xAxis = xAxis;
      _this.yAxis = yAxis;
      var template = new TreeMapSeries();
      _this.seriesTemplates = new DictionaryTemplate(template);
      template.virtualParent = _this;
      _this._disposers.push(new DictionaryDisposer(_this.seriesTemplates));
      _this._disposers.push(template);
      _this.zoomOutButton.events.on("hit", function() {
        _this.zoomToChartDataItem(_this._homeDataItem);
      }, void 0, false);
      _this.seriesTemplates.events.on("insertKey", function(event) {
        event.newValue.isTemplate = true;
      }, void 0, false);
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(TreeMap2.prototype, "navigationBar", {
      /**
       * Returns navigationBar if it is added to a chart
       */
      get: function() {
        return this._navigationBar;
      },
      /**
       * A navigation bar used to show "breadcrumb" control, indicating current
       * drill-down path.
       */
      set: function(navigationBar) {
        var _this = this;
        if (this._navigationBar != navigationBar) {
          this._navigationBar = navigationBar;
          navigationBar.parent = this;
          navigationBar.toBack();
          navigationBar.links.template.events.on("hit", function(event) {
            var dataItem = event.target.dataItem.dataContext;
            if (!dataItem.isDisposed()) {
              _this.zoomToChartDataItem(dataItem);
              _this.createTreeSeries(dataItem);
            }
          }, void 0, true);
          this._disposers.push(navigationBar);
        }
      },
      enumerable: true,
      configurable: true
    });
    TreeMap2.prototype.validateData = function() {
      this.series.clear();
      this._tempSeries = [];
      _super.prototype.validateData.call(this);
      if (this._homeDataItem) {
        this._homeDataItem.dispose();
      }
      var homeDataItem = this.dataItems.template.clone();
      this._homeDataItem = homeDataItem;
      each3(this.dataItems.iterator(), function(dataItem) {
        dataItem.parent = homeDataItem;
      });
      homeDataItem.children = this.dataItems;
      homeDataItem.x0 = 0;
      homeDataItem.y0 = 0;
      homeDataItem.name = this._homeText;
      var maxX = 1e3;
      var maxY = Math.round(maxX * this.pixelHeight / this.pixelWidth / 10) * 10 || 1e3;
      homeDataItem.x1 = maxX;
      homeDataItem.y1 = maxY;
      this.xAxis.min = 0;
      this.xAxis.max = maxX;
      this.xAxis.getMinMax();
      this.yAxis.min = 0;
      this.yAxis.max = maxY;
      this.yAxis.getMinMax();
      this.layoutItems(homeDataItem);
      this.createTreeSeries(homeDataItem);
      this.feedLegend();
    };
    TreeMap2.prototype.layoutItems = function(parent, sorting) {
      if (parent) {
        var children = parent.children;
        if (!sorting) {
          sorting = this.sorting;
        }
        if (sorting == "ascending") {
          children.values.sort(function(a, b) {
            return a.value - b.value;
          });
        }
        if (sorting == "descending") {
          children.values.sort(function(a, b) {
            return b.value - a.value;
          });
        }
        this._updateDataItemIndexes(0);
        this.layoutAlgorithm(parent);
        for (var i = 0, len = children.length; i < len; i++) {
          var node = children.getIndex(i);
          if (node.children) {
            this.layoutItems(node);
          }
        }
      }
    };
    TreeMap2.prototype.createTreeSeries = function(dataItem) {
      var _this = this;
      this._tempSeries = [];
      var navigationData = [dataItem];
      var parentDataItem = dataItem.parent;
      while (parentDataItem != void 0) {
        this.initSeries(parentDataItem);
        navigationData.push(parentDataItem);
        parentDataItem = parentDataItem.parent;
      }
      navigationData.reverse();
      if (this.navigationBar) {
        this.navigationBar.data = navigationData;
      }
      this.createTreeSeriesReal(dataItem);
      each(this._tempSeries, function(series) {
        if (_this.series.indexOf(series) == -1) {
          _this.series.push(series);
        }
        series.zIndex = series.level;
      });
    };
    TreeMap2.prototype.createTreeSeriesReal = function(dataItem) {
      if (dataItem.children) {
        var level = dataItem.level;
        if (level < this.currentLevel + this.maxLevels) {
          this.initSeries(dataItem);
          for (var i = 0; i < dataItem.children.length; i++) {
            var child = dataItem.children.getIndex(i);
            if (child.children) {
              this.createTreeSeriesReal(child);
            }
          }
        }
      }
    };
    TreeMap2.prototype.setData = function(value) {
      this.currentLevel = 0;
      this.currentlyZoomed = void 0;
      this.xAxis.start = 0;
      this.xAxis.end = 1;
      this.yAxis.start = 0;
      this.yAxis.end = 1;
      _super.prototype.setData.call(this, value);
    };
    TreeMap2.prototype.seriesAppeared = function() {
      return true;
    };
    TreeMap2.prototype.initSeries = function(dataItem) {
      var _this = this;
      if (!dataItem.series) {
        var series = void 0;
        var template = this.seriesTemplates.getKey(dataItem.level.toString());
        if (template) {
          series = template.clone();
        } else {
          series = this.series.create();
        }
        series.dataItem.dataContext = dataItem;
        series.name = dataItem.name;
        series.parentDataItem = dataItem;
        dataItem.series = series;
        var level = dataItem.level;
        series.level = level;
        var dataContext = dataItem.dataContext;
        if (dataContext) {
          series.config = dataContext.config;
        }
        this.dataUsers.removeValue(series);
        series.data = dataItem.children.values;
        series.fill = dataItem.color;
        series.columnsContainer.hide(0);
        series.bulletsContainer.hide(0);
        series.columns.template.adapter.add("fill", function(fill, target) {
          var dataItem2 = target.dataItem;
          if (dataItem2) {
            var treeMapDataItem = dataItem2.treeMapDataItem;
            if (treeMapDataItem) {
              target.fill = treeMapDataItem.color;
              target.adapter.remove("fill");
              return treeMapDataItem.color;
            }
          }
        });
        if (this.zoomable && (dataItem.level > this.currentLevel || dataItem.children && dataItem.children.length > 0)) {
          series.columns.template.cursorOverStyle = MouseCursorStyle.pointer;
          if (this.zoomable) {
            series.columns.template.events.on("hit", function(event) {
              var seriesDataItem = event.target.dataItem;
              if (dataItem.level > _this.currentLevel) {
                _this.zoomToChartDataItem(seriesDataItem.treeMapDataItem.parent);
              } else {
                _this.zoomToSeriesDataItem(seriesDataItem);
              }
            }, this, void 0);
          }
        }
      }
      this._tempSeries.push(dataItem.series);
    };
    TreeMap2.prototype.toggleBullets = function(duration) {
      var _this = this;
      each3(this.series.iterator(), function(series) {
        if (_this._tempSeries.indexOf(series) == -1) {
          series.columnsContainer.hide();
          series.bulletsContainer.hide(duration);
        } else {
          series.columnsContainer.show();
          series.bulletsContainer.show(duration);
          series.dataItems.each(function(dataItem) {
            dataItem.bullets.each(function(key, bullet) {
              bullet.show();
            });
          });
          if (series.level < _this.currentLevel) {
            if (_this.hideParentColumns) {
              series.columnsContainer.hide();
            }
            series.bulletsContainer.hide(duration);
          } else if (series.level == _this.currentLevel) {
            if (_this.maxLevels > 1) {
              series.dataItems.each(function(dataItem) {
                if (dataItem.treeMapDataItem.children) {
                  dataItem.bullets.each(function(key, bullet) {
                    bullet.hide();
                  });
                }
              });
            }
          }
        }
      });
    };
    TreeMap2.prototype.zoomToSeriesDataItem = function(dataItem) {
      this.zoomToChartDataItem(dataItem.treeMapDataItem);
    };
    TreeMap2.prototype.zoomToChartDataItem = function(dataItem) {
      var _this = this;
      if (!dataItem) {
        dataItem = this._homeDataItem;
      }
      var zoomOutButton = this.zoomOutButton;
      if (zoomOutButton) {
        if (dataItem != this._homeDataItem) {
          zoomOutButton.show();
        } else {
          zoomOutButton.hide();
        }
      }
      if (dataItem && dataItem.children) {
        this.xAxis.zoomToValues(dataItem.x0, dataItem.x1);
        this.yAxis.zoomToValues(dataItem.y0, dataItem.y1);
        this.currentLevel = dataItem.level;
        this.currentlyZoomed = dataItem;
        this.createTreeSeries(dataItem);
        var rangeChangeAnimation = this.xAxis.rangeChangeAnimation || this.yAxis.rangeChangeAnimation;
        if (rangeChangeAnimation && !rangeChangeAnimation.isDisposed() && !rangeChangeAnimation.isFinished()) {
          this._dataDisposers.push(rangeChangeAnimation);
          rangeChangeAnimation.events.once("animationended", function() {
            _this.toggleBullets();
          });
        } else {
          this.toggleBullets();
        }
      }
    };
    TreeMap2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("TreeMap chart");
      }
    };
    TreeMap2.prototype.createDataItem = function() {
      return new TreeMapDataItem();
    };
    Object.defineProperty(TreeMap2.prototype, "maxLevels", {
      /**
       * @return Maximum drill-down level
       */
      get: function() {
        return this.getPropertyValue("maxLevels");
      },
      /**
       * Maximum number of levels the chart will display initially.
       *
       * @default 2
       * @param value  Maximum drill-down level
       */
      set: function(value) {
        this.setPropertyValue("maxLevels", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMap2.prototype, "currentLevel", {
      /**
       * @return Current level
       */
      get: function() {
        return this.getPropertyValue("currentLevel");
      },
      /**
       * Current drill-down level the chart is at.
       *
       * @param value  Current level
       */
      set: function(value) {
        this.setPropertyValue("currentLevel", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMap2.prototype, "hideParentColumns", {
      /**
       * @return Hide?
       */
      get: function() {
        return this.getPropertyValue("hideParentColumns");
      },
      /**
       * If set to `true`, columns of parent nodes will be hidden when user
       * drills-down into deeper levels.
       *
       * @sice 4.7.4
       * @default false
       * @param  value  Hide?
       */
      set: function(value) {
        this.setPropertyValue("hideParentColumns", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TreeMap2.prototype, "sorting", {
      get: function() {
        return this.getPropertyValue("sorting");
      },
      /**
       * Sorting direction of treemap items.
       *
       * Available options: "none", "ascending", and "descending" (default).
       *
       * @default "descending"
       * @param value [description]
       */
      set: function(value) {
        this.setPropertyValue("sorting", value, true);
      },
      enumerable: true,
      configurable: true
    });
    TreeMap2.prototype.createSeries = function() {
      return new TreeMapSeries();
    };
    Object.defineProperty(TreeMap2.prototype, "homeText", {
      /**
       * @return Home text
       */
      get: function() {
        return this._homeText;
      },
      /**
       * A text displayed on the "home" button which is used to go back to level 0
       * after drill into sub-items.
       *
       * @param value  Home text
       */
      set: function(value) {
        this._homeText = value;
        if (this._homeDataItem) {
          this._homeDataItem.name = this._homeText;
        }
      },
      enumerable: true,
      configurable: true
    });
    TreeMap2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config["layoutAlgorithm"]) && isString(config["layoutAlgorithm"])) {
          switch (config["layoutAlgorithm"]) {
            case "squarify":
              config["layoutAlgorithm"] = this.squarify;
              break;
            case "binaryTree":
              config["layoutAlgorithm"] = this.binaryTree;
              break;
            case "slice":
              config["layoutAlgorithm"] = this.slice;
              break;
            case "dice":
              config["layoutAlgorithm"] = this.dice;
              break;
            case "sliceDice":
              config["layoutAlgorithm"] = this.sliceDice;
              break;
            default:
              delete config["layoutAlgorithm"];
              break;
          }
        }
        if (hasValue(config.navigationBar) && !hasValue(config.navigationBar.type)) {
          config.navigationBar.type = "NavigationBar";
        }
        _super.prototype.processConfig.call(this, config);
      }
    };
    TreeMap2.prototype.validateLayout = function() {
      _super.prototype.validateLayout.call(this);
      this.layoutItems(this.currentlyZoomed);
    };
    TreeMap2.prototype.validateDataItems = function() {
      _super.prototype.validateDataItems.call(this);
      this.layoutItems(this._homeDataItem);
      each3(this.series.iterator(), function(series) {
        series.validateRawData();
      });
      this.zoomToChartDataItem(this._homeDataItem);
    };
    TreeMap2.prototype.binaryTree = function(parent) {
      var nodes = parent.children, i, n = nodes.length, sum, sums = new Array(n + 1);
      for (sums[0] = sum = i = 0; i < n; ++i) {
        sums[i + 1] = sum += nodes.getIndex(i).value;
      }
      if (n > 0) {
        partition(0, n, parent.value, parent.x0, parent.y0, parent.x1, parent.y1);
      }
      function partition(i2, j, value, x0, y0, x1, y1) {
        if (i2 >= j - 1) {
          var node = nodes.getIndex(i2);
          node.x0 = x0;
          node.y0 = y0;
          node.x1 = x1;
          node.y1 = y1;
          return;
        }
        var valueOffset = sums[i2], valueTarget = value / 2 + valueOffset, k = i2 + 1, hi = j - 1;
        while (k < hi) {
          var mid = k + hi >>> 1;
          if (sums[mid] < valueTarget) {
            k = mid + 1;
          } else {
            hi = mid;
          }
        }
        if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i2 + 1 < k) {
          --k;
        }
        var valueLeft = sums[k] - valueOffset, valueRight = value - valueLeft;
        if (value == 0) {
          var node = nodes.getIndex(i2);
          node.x0 = x0;
          node.y0 = y0;
          node.x1 = x1;
          node.y1 = y1;
          return;
        }
        if (x1 - x0 > y1 - y0) {
          var xk = (x0 * valueRight + x1 * valueLeft) / value;
          partition(i2, k, valueLeft, x0, y0, xk, y1);
          partition(k, j, valueRight, xk, y0, x1, y1);
        } else {
          var yk = (y0 * valueRight + y1 * valueLeft) / value;
          partition(i2, k, valueLeft, x0, y0, x1, yk);
          partition(k, j, valueRight, x0, yk, x1, y1);
        }
      }
    };
    TreeMap2.prototype.slice = function(parent) {
      var x0 = parent.x0;
      var x1 = parent.x1;
      var y0 = parent.y0;
      var y1 = parent.y1;
      var nodes = parent.children;
      var node;
      var i = -1;
      var n = nodes.length;
      var k = parent.value && (y1 - y0) / parent.value;
      while (++i < n) {
        node = nodes.getIndex(i);
        node.x0 = x0;
        node.x1 = x1;
        node.y0 = y0;
        y0 += node.value * k;
        node.y1 = y0;
      }
    };
    TreeMap2.prototype.dice = function(parent) {
      var x0 = parent.x0;
      var x1 = parent.x1;
      var y0 = parent.y0;
      var y1 = parent.y1;
      var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
      while (++i < n) {
        node = nodes.getIndex(i);
        node.y0 = y0;
        node.y1 = y1;
        node.x0 = x0;
        x0 += node.value * k;
        node.x1 = x0;
      }
    };
    TreeMap2.prototype.sliceDice = function(parent) {
      if (parent.level & 1) {
        this.slice(parent);
      } else {
        this.dice(parent);
      }
    };
    TreeMap2.prototype.squarify = function(parent) {
      var ratio = (1 + Math.sqrt(5)) / 2;
      var x0 = parent.x0;
      var x1 = parent.x1;
      var y0 = parent.y0;
      var y1 = parent.y1;
      var nodes = parent.children;
      var nodeValue;
      var i0 = 0;
      var i1 = 0;
      var n = nodes.length;
      var dx;
      var dy;
      var value = parent.value;
      var sumValue;
      var minValue;
      var maxValue;
      var newRatio;
      var minRatio;
      var alpha;
      var beta;
      while (i0 < n) {
        dx = x1 - x0;
        dy = y1 - y0;
        do {
          sumValue = nodes.getIndex(i1++).value;
        } while (!sumValue && i1 < n);
        minValue = maxValue = sumValue;
        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
        beta = sumValue * sumValue * alpha;
        minRatio = Math.max(maxValue / beta, beta / minValue);
        for (; i1 < n; ++i1) {
          sumValue += nodeValue = nodes.getIndex(i1).value;
          if (nodeValue < minValue) {
            minValue = nodeValue;
          }
          if (nodeValue > maxValue) {
            maxValue = nodeValue;
          }
          beta = sumValue * sumValue * alpha;
          newRatio = Math.max(maxValue / beta, beta / minValue);
          if (newRatio > minRatio) {
            sumValue -= nodeValue;
            break;
          }
          minRatio = newRatio;
        }
        var row = this.dataItems.template.clone();
        row.value = sumValue;
        row.dice = dx < dy;
        row.children = nodes.slice(i0, i1);
        row.x0 = x0;
        row.y0 = y0;
        row.x1 = x1;
        row.y1 = y1;
        if (row.dice) {
          row.y1 = value ? y0 += dy * sumValue / value : y1;
          this.dice(row);
        } else {
          row.x1 = value ? x0 += dx * sumValue / value : x1;
          this.slice(row);
        }
        value -= sumValue;
        i0 = i1;
      }
    };
    TreeMap2.prototype.handleSeriesAdded2 = function() {
    };
    TreeMap2.prototype.handleDataItemValueChange = function(dataItem, name) {
      if (name == "value") {
        this.invalidateDataItems();
      }
    };
    TreeMap2.prototype.handleDataItemWorkingValueChange = function(dataItem, name) {
      if (name == "value") {
        this.invalidateDataItems();
      }
    };
    TreeMap2.prototype.getLegendLevel = function(dataItem) {
      if (!dataItem) {
        return;
      }
      if (!dataItem.children) {
        return;
      }
      if (dataItem.children.length > 1) {
        return dataItem;
      } else if (dataItem.children.length == 1) {
        var child = dataItem.children.getIndex(0);
        if (child.children) {
          return this.getLegendLevel(child);
        } else {
          return dataItem;
        }
      } else {
        return dataItem;
      }
    };
    TreeMap2.prototype.handleLegendSeriesAdded = function(series) {
    };
    Object.defineProperty(TreeMap2.prototype, "homeDataItem", {
      /**
       * A data item associated with top node.
       *
       * @since 4.8.2
       */
      get: function() {
        return this._homeDataItem;
      },
      enumerable: true,
      configurable: true
    });
    TreeMap2.prototype.feedLegend = function() {
      var legend = this.legend;
      if (legend) {
        legend.dataFields.name = "name";
        var legendParent = this.getLegendLevel(this._homeDataItem);
        if (legendParent) {
          var legendData_1 = [];
          legendParent.children.each(function(dataItem) {
            legendData_1.push(dataItem);
          });
          legend.data = legendData_1;
        }
      }
    };
    TreeMap2.prototype.disposeData = function() {
      _super.prototype.disposeData.call(this);
      this._homeDataItem = void 0;
      this.series.clear();
      if (this.navigationBar) {
        this.navigationBar.disposeData();
      }
      this.xAxis.disposeData();
      this.yAxis.disposeData();
    };
    TreeMap2.prototype.getExporting = function() {
      var _this = this;
      var exporting = _super.prototype.getExporting.call(this);
      exporting.adapter.add("formatDataFields", function(info) {
        if (info.format == "csv" || info.format == "xlsx") {
          if (hasValue(_this.dataFields.children)) {
            delete info.dataFields[_this.dataFields.children];
          }
        }
        return info;
      });
      return exporting;
    };
    return TreeMap2;
  }(XYChart)
);
registry.registeredClasses["TreeMap"] = TreeMap;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererX3D.js
var AxisRendererX3D = (
  /** @class */
  function(_super) {
    __extends(AxisRendererX3D2, _super);
    function AxisRendererX3D2() {
      var _this = _super.call(this) || this;
      _this._chart = new MutableValueDisposer();
      _this.className = "AxisRendererX3D";
      _this._disposers.push(_this._chart);
      _this.applyTheme();
      return _this;
    }
    AxisRendererX3D2.prototype.updateGridElement = function(grid, position, endPosition) {
      position = position + (endPosition - position) * grid.location;
      var point = this.positionToPoint(position);
      if (grid.element) {
        var dx = this.chart.dx3D || 0;
        var dy = this.chart.dy3D || 0;
        var h = this.getHeight();
        grid.path = moveTo({ x: dx, y: dy }) + lineTo({ x: dx, y: h + dy }) + lineTo({ x: 0, y: h });
      }
      this.positionItem(grid, point);
      this.toggleVisibility(grid, position, 0, 1);
    };
    AxisRendererX3D2.prototype.updateBaseGridElement = function() {
      _super.prototype.updateBaseGridElement.call(this);
      var h = this.getHeight();
      var dx = this.chart.dx3D || 0;
      var dy = this.chart.dy3D || 0;
      this.baseGrid.path = moveTo({ x: dx, y: dy }) + lineTo({ x: 0, y: 0 }) + lineTo({ x: 0, y: h });
    };
    Object.defineProperty(AxisRendererX3D2.prototype, "chart", {
      /**
       * @ignore Exclude from docs
       * @return Chart
       */
      get: function() {
        return this._chart.get();
      },
      /**
       * Chart, associated with the Axis.
       *
       * @ignore Exclude from docs
       * @param value Chart
       */
      set: function(chart) {
        if (chart) {
          this._chart.set(chart, chart.events.on("propertychanged", this.handle3DChanged, this, false));
        }
      },
      enumerable: true,
      configurable: true
    });
    AxisRendererX3D2.prototype.handle3DChanged = function(event) {
      if (event.property == "depth" || event.property == "angle") {
        this.invalidate();
      }
    };
    return AxisRendererX3D2;
  }(AxisRendererX)
);
registry.registeredClasses["AxisRendererX3D"] = AxisRendererX3D;

// node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererY3D.js
var AxisRendererY3D = (
  /** @class */
  function(_super) {
    __extends(AxisRendererY3D2, _super);
    function AxisRendererY3D2() {
      var _this = _super.call(this) || this;
      _this._chart = new MutableValueDisposer();
      _this.className = "AxisRendererY3D";
      _this._disposers.push(_this._chart);
      _this.applyTheme();
      return _this;
    }
    AxisRendererY3D2.prototype.updateGridElement = function(grid, position, endPosition) {
      position = position + (endPosition - position) * grid.location;
      var point = this.positionToPoint(position);
      if (grid.element) {
        var dx = this.chart.dx3D || 0;
        var dy = this.chart.dy3D || 0;
        var w = this.getWidth();
        grid.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: dx, y: dy }) + lineTo({ x: w + dx, y: dy });
      }
      this.positionItem(grid, point);
      this.toggleVisibility(grid, position, 0, 1);
    };
    AxisRendererY3D2.prototype.updateBaseGridElement = function() {
      _super.prototype.updateBaseGridElement.call(this);
      var dx = this.chart.dx3D || 0;
      var dy = this.chart.dy3D || 0;
      var w = this.getWidth();
      this.baseGrid.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: w, y: 0 }) + lineTo({ x: w + dx, y: dy });
    };
    Object.defineProperty(AxisRendererY3D2.prototype, "chart", {
      /**
       * @ignore Exclude from docs
       * @return Chart
       */
      get: function() {
        return this._chart.get();
      },
      /**
       * Chart, associated with the Axis.
       *
       * @ignore Exclude from docs
       * @param value  Chart
       */
      set: function(chart) {
        if (chart) {
          this._chart.set(chart, chart.events.on("propertychanged", this.handle3DChanged, this, false));
        }
      },
      enumerable: true,
      configurable: true
    });
    AxisRendererY3D2.prototype.handle3DChanged = function(event) {
      if (event.property == "depth" || event.property == "angle") {
        this.invalidate();
      }
    };
    return AxisRendererY3D2;
  }(AxisRendererY)
);

// node_modules/@amcharts/amcharts4/.internal/charts/elements/Column3D.js
var Column3D = (
  /** @class */
  function(_super) {
    __extends(Column3D2, _super);
    function Column3D2() {
      var _this = _super.call(this) || this;
      _this.className = "Column3D";
      return _this;
    }
    Column3D2.prototype.createAssets = function() {
      this.column3D = this.createChild(Rectangle3D);
      this.column3D.shouldClone = false;
      this.column3D.strokeOpacity = 0;
      this.column = this.column3D;
    };
    Column3D2.prototype.validate = function() {
      _super.prototype.validate.call(this);
      if (this.column3D) {
        this.column3D.width = this.pixelWidth;
        this.column3D.height = this.pixelHeight;
        if (this.column3D.invalid) {
          this.column3D.validate();
        }
      }
    };
    Column3D2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      if (this.column3D) {
        this.column3D.copyFrom(source.column3D);
      }
    };
    Column3D2.prototype.setFill = function(value) {
      _super.prototype.setFill.call(this, value);
      this.column.fill = value;
    };
    return Column3D2;
  }(Column)
);
registry.registeredClasses["Column3D"] = Column3D;

// node_modules/@amcharts/amcharts4/.internal/charts/series/ColumnSeries3D.js
var ColumnSeries3DDataItem = (
  /** @class */
  function(_super) {
    __extends(ColumnSeries3DDataItem2, _super);
    function ColumnSeries3DDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "ColumnSeries3DDataItem";
      _this.applyTheme();
      return _this;
    }
    return ColumnSeries3DDataItem2;
  }(ColumnSeriesDataItem)
);
var ColumnSeries3D = (
  /** @class */
  function(_super) {
    __extends(ColumnSeries3D2, _super);
    function ColumnSeries3D2() {
      var _this = _super.call(this) || this;
      _this.className = "ColumnSeries3D";
      _this.columns.template.column3D.applyOnClones = true;
      _this.columns.template.hiddenState.properties.visible = true;
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(ColumnSeries3D2.prototype, "columnsContainer", {
      /**
       * @ignore
       */
      get: function() {
        var chart = this.chart;
        if (chart && chart.columnsContainer && chart.leftAxesContainer.layout != "vertical" && chart.rightAxesContainer.layout != "vertical" && chart.bottomAxesContainer.layout != "horizontal" && chart.topAxesContainer.layout != "horizontal") {
          return chart.columnsContainer;
        } else {
          return this._columnsContainer;
        }
      },
      enumerable: true,
      configurable: true
    });
    ColumnSeries3D2.prototype.validateDataElementReal = function(dataItem) {
      _super.prototype.validateDataElementReal.call(this, dataItem);
      if (dataItem.column) {
        dataItem.column.dx = this.dx;
        dataItem.column.dy = this.dy;
        dataItem.column.visible = this.visible;
      }
    };
    ColumnSeries3D2.prototype.validateDataElements = function() {
      _super.prototype.validateDataElements.call(this);
      if (this.chart) {
        this.chart.invalidateLayout();
      }
    };
    ColumnSeries3D2.prototype.createColumnTemplate = function() {
      return new Column3D();
    };
    Object.defineProperty(ColumnSeries3D2.prototype, "depth", {
      /**
       * @ignore Exclude from docs
       * @return Depth (px)
       */
      get: function() {
        return this.getPropertyValue("depth");
      },
      /**
       * Depth (height) of the slices in the series in pixels.
       *
       * @ignore Exclude from docs
       * @param value  Depth (px)
       */
      set: function(value) {
        this.setPropertyValue("depth", value, true);
        var template = this.columns.template;
        template.column3D.depth = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ColumnSeries3D2.prototype, "angle", {
      /**
       * @ignore Exclude from docs
       * @return Angle (0-360)
       */
      get: function() {
        return this.getPropertyValue("angle");
      },
      /**
       * Angle of view for the slices in series. (0-360)
       *
       * @ignore Exclude from docs
       * @param value  Angle (0-360)
       */
      set: function(value) {
        this.setPropertyValue("angle", value);
        var template = this.columns.template;
        template.column3D.angle = value;
      },
      enumerable: true,
      configurable: true
    });
    return ColumnSeries3D2;
  }(ColumnSeries)
);
registry.registeredClasses["ColumnSeries3D"] = ColumnSeries3D;
registry.registeredClasses["ColumnSeries3DDataItem"] = ColumnSeries3DDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/types/XYChart3D.js
var XYChart3DDataItem = (
  /** @class */
  function(_super) {
    __extends(XYChart3DDataItem2, _super);
    function XYChart3DDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "XYChart3DDataItem";
      _this.applyTheme();
      return _this;
    }
    return XYChart3DDataItem2;
  }(XYChartDataItem)
);
var XYChart3D = (
  /** @class */
  function(_super) {
    __extends(XYChart3D2, _super);
    function XYChart3D2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._axisRendererX = AxisRendererX3D;
      _this._axisRendererY = AxisRendererY3D;
      _this.className = "XYChart3D";
      _this.depth = 30;
      _this.angle = 30;
      var columnsContainer = _this.seriesContainer.createChild(Container);
      columnsContainer.shouldClone = false;
      columnsContainer.isMeasured = false;
      columnsContainer.layout = "none";
      _this.columnsContainer = columnsContainer;
      _this.columnsContainer.mask = _this.createChild(Sprite);
      _this.applyTheme();
      return _this;
    }
    XYChart3D2.prototype.updateSeriesMasks = function() {
      _super.prototype.updateSeriesMasks.call(this);
      if (isIE()) {
        var columnsContainer = this.columnsContainer;
        var mask = columnsContainer.mask;
        columnsContainer.mask = void 0;
        columnsContainer.mask = mask;
      }
    };
    Object.defineProperty(XYChart3D2.prototype, "depth", {
      /**
       * @return Depth (px)
       */
      get: function() {
        return this.getPropertyValue("depth");
      },
      /**
       * Depth of the 3D chart / columns in pixels.
       *
       * @param value  Depth (px)
       */
      set: function(value) {
        this.setPropertyValue("depth", value);
        this.fixLayout();
        this.invalidateDataUsers();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYChart3D2.prototype, "angle", {
      /**
       * @return Angle
       */
      get: function() {
        return this.getPropertyValue("angle");
      },
      /**
       * Angle the chart is viewed at.
       *
       * @todo Description (review)
       * @param value  Angle
       */
      set: function(value) {
        this.setPropertyValue("angle", value);
        this.fixLayout();
        this.invalidateDataUsers();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYChart3D2.prototype, "dx3D", {
      /**
       * A calculated horizontal 3D offset (px).
       *
       * @readonly
       * @return Offset (px)
       */
      get: function() {
        return cos(this.angle) * this.depth;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYChart3D2.prototype, "dy3D", {
      /**
       * A calculated vertical 3D offset (px).
       *
       * @readonly
       * @return Offset (px)
       */
      get: function() {
        return -sin(this.angle) * this.depth;
      },
      enumerable: true,
      configurable: true
    });
    XYChart3D2.prototype.validateLayout = function() {
      _super.prototype.validateLayout.call(this);
      this.fixColumns();
    };
    XYChart3D2.prototype.fixLayout = function() {
      this.chartContainer.paddingTop = -this.dy3D;
      this.chartContainer.paddingRight = this.dx3D;
      if (this.scrollbarX) {
        this.scrollbarX.dy = this.dy3D;
        this.scrollbarX.dx = this.dx3D;
      }
      if (this.scrollbarY) {
        this.scrollbarY.dy = this.dy3D;
        this.scrollbarY.dx = this.dx3D;
      }
      this.fixColumns();
      _super.prototype.fixLayout.call(this);
    };
    XYChart3D2.prototype.fixColumns = function() {
      var _this = this;
      var count = 1;
      var i = 0;
      each3(this.series.iterator(), function(series) {
        if (series instanceof ColumnSeries3D) {
          if (!series.clustered && i > 0) {
            count++;
          }
          series.depthIndex = count - 1;
          i++;
        }
      });
      var s = 0;
      each3(this.series.iterator(), function(series) {
        if (series instanceof ColumnSeries3D) {
          series.depth = _this.depth / count;
          series.angle = _this.angle;
          if (series.columnsContainer == _this.columnsContainer) {
            series.dx = _this.depth / count * cos(_this.angle) * series.depthIndex;
            series.dy = -_this.depth / count * sin(_this.angle) * series.depthIndex;
          }
          var inversed_1 = false;
          if (series.baseAxis == series.xAxis && series.xAxis.renderer.inversed || series.baseAxis == series.yAxis && series.yAxis.renderer.inversed) {
            inversed_1 = true;
          }
          var i_1 = 1;
          series.dataItems.each(function(dataItem) {
            var column = dataItem.column;
            if (column) {
              if (inversed_1) {
                column.zIndex = 1e3 * (1e3 - i_1) + s - series.depthIndex * 100;
              } else {
                column.zIndex = 1e3 * i_1 + s - series.depthIndex * 100;
              }
            }
            i_1++;
          });
          if (inversed_1) {
            s--;
          } else {
            s++;
          }
        }
      });
      this.maskColumns();
    };
    XYChart3D2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config.series) && isArray(config.series)) {
          for (var i = 0, len = config.series.length; i < len; i++) {
            config.series[i].type = config.series[i].type || "ColumnSeries3D";
          }
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    XYChart3D2.prototype.maskColumns = function() {
      var w = this.plotContainer.pixelWidth;
      var h = this.plotContainer.pixelHeight;
      var dx = this.dx3D;
      var dy = this.dy3D;
      var path = moveTo({ x: 0, y: 0 }) + lineTo({ x: dx, y: dy }) + lineTo({ x: w + dx, y: dy }) + lineTo({ x: w + dx, y: h + dy }) + lineTo({ x: w, y: h }) + lineTo({ x: w, y: h }) + lineTo({ x: 0, y: h }) + closePath();
      var columnsContainer = this.columnsContainer;
      if (columnsContainer && columnsContainer.mask) {
        columnsContainer.mask.path = path;
      }
    };
    return XYChart3D2;
  }(XYChart)
);
registry.registeredClasses["XYChart3D"] = XYChart3D;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/HeatLegend.js
var HeatLegend = (
  /** @class */
  function(_super) {
    __extends(HeatLegend2, _super);
    function HeatLegend2() {
      var _this = _super.call(this) || this;
      _this.className = "HeatLegend";
      _this.markerContainer = _this.createChild(Container);
      _this.markerContainer.shouldClone = false;
      _this.markerCount = 1;
      var marker = new RoundedRectangle();
      marker.minHeight = 20;
      marker.minWidth = 20;
      marker.interactionsEnabled = false;
      marker.fillOpacity = 1;
      marker.cornerRadius(0, 0, 0, 0);
      _this.markerContainer.minHeight = 20;
      _this.markerContainer.minWidth = 20;
      _this.orientation = "horizontal";
      _this.markers = new ListTemplate(marker);
      _this._disposers.push(new ListDisposer(_this.markers));
      _this._disposers.push(_this.markers.template);
      _this.applyTheme();
      return _this;
    }
    HeatLegend2.prototype.getMinFromRules = function(property) {
      var series = this.series;
      if (series) {
        var minValue_1;
        eachContinue2(series.heatRules.iterator(), function(heatRule) {
          if (heatRule.property == property) {
            minValue_1 = heatRule.min;
            return false;
          }
          return true;
        });
        return minValue_1;
      }
    };
    HeatLegend2.prototype.getMaxFromRules = function(property) {
      var series = this.series;
      if (series) {
        var maxValue_1;
        each3(series.heatRules.iterator(), function(heatRule) {
          if (heatRule.property == property) {
            maxValue_1 = heatRule.max;
            return false;
          }
          return true;
        });
        return maxValue_1;
      }
    };
    HeatLegend2.prototype.validate = function() {
      _super.prototype.validate.call(this);
      this.valueAxis.renderer.inversed = this.reverseOrder;
      var series = this.series;
      var minColor = this.minColor;
      var maxColor = this.maxColor;
      if (!hasValue(minColor)) {
        minColor = toColor(this.getMinFromRules("fill"));
      }
      if (!hasValue(maxColor)) {
        maxColor = toColor(this.getMaxFromRules("fill"));
      }
      if (series) {
        var seriesFill = series.fill;
        if (!hasValue(minColor) && seriesFill instanceof Color) {
          minColor = seriesFill;
        }
        if (!hasValue(maxColor) && seriesFill instanceof Color) {
          maxColor = seriesFill;
        }
      }
      if (!hasValue(maxColor)) {
        maxColor = toColor(this.getMaxFromRules("fill"));
      }
      var minOpacity = toNumber(this.getMinFromRules("fillOpacity"));
      if (!isNumber(minOpacity)) {
        minOpacity = 1;
      }
      var maxOpacity = toNumber(this.getMaxFromRules("fillOpacity"));
      if (!isNumber(maxOpacity)) {
        maxOpacity = 1;
      }
      var minStrokeOpacity = toNumber(this.getMinFromRules("strokeOpacity"));
      if (!isNumber(minStrokeOpacity)) {
        minStrokeOpacity = 1;
      }
      var maxStrokeOpacity = toNumber(this.getMaxFromRules("strokeOpacity"));
      if (!isNumber(maxStrokeOpacity)) {
        maxStrokeOpacity = 1;
      }
      var minStroke = toColor(this.getMinFromRules("stroke"));
      var maxStroke = toColor(this.getMaxFromRules("stroke"));
      for (var i = 0; i < this.markerCount; i++) {
        var marker = this.markers.getIndex(i);
        if (!marker) {
          marker = this.markers.create();
          marker.parent = this.markerContainer;
          marker.height = percent(100);
          marker.width = percent(100);
        }
        if (this.markerCount == 1) {
          var gradient = new LinearGradient();
          if (this.reverseOrder) {
            gradient.addColor(maxColor, maxOpacity);
            gradient.addColor(minColor, minOpacity);
          } else {
            gradient.addColor(minColor, minOpacity);
            gradient.addColor(maxColor, maxOpacity);
          }
          if (this.orientation == "vertical") {
            gradient.rotation = -90;
          }
          marker.fill = gradient;
          if (hasValue(minStroke) && hasValue(maxStroke)) {
            var strokeGradient = new LinearGradient();
            if (this.reverseOrder) {
              strokeGradient.addColor(maxStroke, maxStrokeOpacity);
              strokeGradient.addColor(minStroke, minStrokeOpacity);
            } else {
              strokeGradient.addColor(minStroke, minStrokeOpacity);
              strokeGradient.addColor(maxStroke, maxStrokeOpacity);
            }
            if (this.orientation == "vertical") {
              strokeGradient.rotation = -90;
            }
            marker.stroke = strokeGradient;
          }
        } else {
          var c = i;
          if (this.reverseOrder) {
            c = this.markerCount - i - 1;
          }
          var color2 = new Color(interpolate(minColor.rgb, maxColor.rgb, c / this.markerCount));
          marker.fill = color2;
          var opacity = minOpacity + (maxOpacity - minOpacity) * c / this.markerCount;
          marker.fillOpacity = opacity;
          if (hasValue(minStroke) && hasValue(maxStroke)) {
            var color_1 = new Color(interpolate(minStroke.rgb, maxStroke.rgb, c / this.markerCount));
            marker.stroke = color_1;
            var opacity_1 = minStrokeOpacity + (maxStrokeOpacity - minStrokeOpacity) * c / this.markerCount;
            marker.strokeOpacity = opacity_1;
          }
        }
      }
      var renderer = this.valueAxis.renderer;
      if (this.markerCount > 1) {
        if (this.orientation == "horizontal") {
          renderer.minGridDistance = this.measuredWidth / this.markerCount;
        } else {
          renderer.minGridDistance = this.measuredHeight / this.markerCount;
        }
      }
      this.valueAxis.invalidate();
      for (var i = this.markerCount, len = this.markers.length; i < len; i++) {
        this.markers.getIndex(i).parent = void 0;
      }
    };
    Object.defineProperty(HeatLegend2.prototype, "minColor", {
      /**
       * Returns minColor value
       * @return {Color}
       */
      get: function() {
        return this.getPropertyValue("minColor");
      },
      /**
       * Min color of a heat legend. If a series is set for the legend, minColor is taken from series.
       *
       * @param {Color}
       */
      set: function(value) {
        if (!(value instanceof Color)) {
          value = toColor(value);
        }
        this.setColorProperty("minColor", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(HeatLegend2.prototype, "maxColor", {
      /**
       * Returns maxColor value
       * @return {Color}
       */
      get: function() {
        return this.getPropertyValue("maxColor");
      },
      /**
       * Max color of a heat legend. If a series is set for the legend, maxColor is taken from series.
       *
       * @param {Color}
       */
      set: function(value) {
        if (!(value instanceof Color)) {
          value = toColor(value);
        }
        this.setColorProperty("maxColor", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(HeatLegend2.prototype, "markerCount", {
      /**
       * Returns number of color squares (markers).
       * @return {number}
       */
      get: function() {
        return this.getPropertyValue("markerCount");
      },
      /**
       * Number of color squares (markers) in the heat legend. If only 1 marker is used, it will be filled with gradient.
       *
       * @param {number}
       */
      set: function(value) {
        this.setPropertyValue("markerCount", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(HeatLegend2.prototype, "minValue", {
      /**
       * Returns minimum value of heat legend.
       * @return {number}
       */
      get: function() {
        return this.getPropertyValue("minValue");
      },
      /**
       * Minimum value of heat legend's value axis. If a series is set for the legend, min is taken from series.
       *
       * @param {number}
       */
      set: function(value) {
        this.setPropertyValue("minValue", value);
        this.valueAxis.min = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(HeatLegend2.prototype, "maxValue", {
      /**
       * Returns maximum value of heat legend.
       * @return {number}
       */
      get: function() {
        return this.getPropertyValue("maxValue");
      },
      /**
       * Maximum value of heat legend's value axis. If a series is set for the legend, max is taken from series.
       *
       * @param {number}
       */
      set: function(value) {
        this.setPropertyValue("maxValue", value);
        this.valueAxis.max = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(HeatLegend2.prototype, "orientation", {
      /**
       * Returns orientation value.
       *
       * @return {"horizontal" | "vertical"}
       */
      get: function() {
        return this.getPropertyValue("orientation");
      },
      /**
      * Heat legend orientation. Note, if you change orientation of a heat legend, you must set value axis renderer properties after that, as with orientation renderer changes.
      *
      * @param {"horizontal" | "vertical"}
      */
      set: function(value) {
        this.setPropertyValue("orientation", value, true);
        var markerContainer = this.markerContainer;
        var valueAxis = this.valueAxis;
        if (value == "horizontal") {
          if (!hasValue(this.width)) {
            this.width = 200;
          }
          this.height = void 0;
          valueAxis.width = percent(100);
          valueAxis.height = void 0;
          valueAxis.tooltip.pointerOrientation = "vertical";
          this.layout = "vertical";
          markerContainer.width = percent(100);
          markerContainer.height = void 0;
          if (!(valueAxis.renderer instanceof AxisRendererX)) {
            valueAxis.renderer = new AxisRendererX();
          }
        } else {
          if (!hasValue(this.height)) {
            this.height = 200;
          }
          this.width = void 0;
          this.layout = "horizontal";
          markerContainer.width = void 0;
          markerContainer.height = percent(100);
          valueAxis.height = percent(100);
          valueAxis.width = void 0;
          valueAxis.tooltip.pointerOrientation = "horizontal";
          if (!(valueAxis.renderer instanceof AxisRendererY)) {
            valueAxis.renderer = new AxisRendererY();
          }
          valueAxis.renderer.inside = true;
          valueAxis.renderer.labels.template.inside = true;
          this.markerContainer.reverseOrder = true;
        }
        var renderer = valueAxis.renderer;
        renderer.grid.template.disabled = true;
        renderer.axisFills.template.disabled = true;
        renderer.baseGrid.disabled = true;
        renderer.labels.template.padding(2, 3, 2, 3);
        renderer.minHeight = void 0;
        renderer.minWidth = void 0;
        this.markerContainer.layout = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(HeatLegend2.prototype, "valueAxis", {
      /**
       * Returns valueAxis value.
       * @return {ValueAxis}
       */
      get: function() {
        if (!this._valueAxis) {
          this.valueAxis = this.createChild(ValueAxis);
          this.valueAxis.shouldClone = false;
        }
        return this._valueAxis;
      },
      /**
       * Sets a value axis of heat legend. Value axis for heat legend is created automatically.
       * @param {ValueAxis}
       */
      set: function(valueAxis) {
        this._valueAxis = valueAxis;
        valueAxis.parent = this;
        valueAxis.strictMinMax = true;
        this.orientation = this.orientation;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(HeatLegend2.prototype, "series", {
      /**
       * Returns series value.
       * @return {Series}
       */
      get: function() {
        return this._series;
      },
      /**
       * You can set series for heat legend. It will take min, max, minColor and maxColor values from this series.
       * @param series
       */
      set: function(series) {
        var _this = this;
        this._series = series;
        var dataField = "value";
        try {
          var dataFieldDefined = series.heatRules.getIndex(0).dataField;
          if (dataFieldDefined) {
            dataField = dataFieldDefined;
          }
        } catch (err) {
        }
        this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);
        series.dataItem.events.on("calculatedvaluechanged", function(event) {
          _this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);
        }, void 0, false);
        series.heatRules.events.on("inserted", this.invalidate, this, false);
        series.heatRules.events.on("removed", this.invalidate, this, false);
      },
      enumerable: true,
      configurable: true
    });
    HeatLegend2.prototype.updateMinMax = function(min2, max2) {
      var valueAxis = this.valueAxis;
      if (!isNumber(this.minValue)) {
        valueAxis.min = min2;
        valueAxis.invalidate();
      }
      if (!isNumber(this.maxValue)) {
        valueAxis.max = max2;
        valueAxis.invalidate();
      }
    };
    HeatLegend2.prototype.processConfig = function(config) {
      if (config) {
        if (hasValue(config.series) && isString(config.series)) {
          if (isString(config.series)) {
            if (this.map.hasKey(config.series)) {
              config.series = this.map.getKey(config.series);
            } else {
              var seriesId_1 = config.series;
              var disposer_1 = this.map.events.on("insertKey", function(ev) {
                if (ev.key == seriesId_1) {
                  this.series = ev.newValue;
                  disposer_1.dispose();
                }
              }, this);
              this._disposers.push(disposer_1);
              delete config.series;
            }
          }
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    return HeatLegend2;
  }(Container)
);
registry.registeredClasses["HeatLegend"] = HeatLegend;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/Candlestick.js
var Candlestick = (
  /** @class */
  function(_super) {
    __extends(Candlestick2, _super);
    function Candlestick2() {
      var _this = _super.call(this) || this;
      _this.className = "Candlestick";
      _this.layout = "none";
      return _this;
    }
    Candlestick2.prototype.createAssets = function() {
      _super.prototype.createAssets.call(this);
      this.lowLine = this.createChild(Line);
      this.lowLine.shouldClone = false;
      this.highLine = this.createChild(Line);
      this.highLine.shouldClone = false;
    };
    Candlestick2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      if (this.lowLine) {
        this.lowLine.copyFrom(source.lowLine);
      }
      if (this.highLine) {
        this.highLine.copyFrom(source.highLine);
      }
    };
    return Candlestick2;
  }(Column)
);
registry.registeredClasses["Candlestick"] = Candlestick;

// node_modules/@amcharts/amcharts4/.internal/charts/series/CandlestickSeries.js
var CandlestickSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(CandlestickSeriesDataItem2, _super);
    function CandlestickSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.values.lowValueX = {};
      _this.values.lowValueY = {};
      _this.values.highValueX = {};
      _this.values.highValueY = {};
      _this.className = "CandlestickSeriesDataItem";
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(CandlestickSeriesDataItem2.prototype, "lowValueX", {
      /**
       * @return Value
       */
      get: function() {
        return this.values.lowValueX.value;
      },
      /**
       * Low value for horizontal axis.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("lowValueX", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CandlestickSeriesDataItem2.prototype, "lowValueY", {
      /**
       * @return Value
       */
      get: function() {
        return this.values.lowValueY.value;
      },
      /**
       * Low value for vertical axis.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("lowValueY", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CandlestickSeriesDataItem2.prototype, "highValueX", {
      /**
       * @return Value
       */
      get: function() {
        return this.values.highValueX.value;
      },
      /**
       * High value for horizontal axis.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("highValueX", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CandlestickSeriesDataItem2.prototype, "highValueY", {
      /**
       * @return Value
       */
      get: function() {
        return this.values.highValueY.value;
      },
      /**
       * High value for vertical axis.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("highValueY", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CandlestickSeriesDataItem2.prototype, "closeValueX", {
      /**
       * @return Value
       */
      get: function() {
        return this.values.valueX.value;
      },
      /**
       * Close value for horizontal axis.
       *
       * This is an alias for `valueX` added for convenience only.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("valueX", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CandlestickSeriesDataItem2.prototype, "closeValueY", {
      /**
       * @return Value
       */
      get: function() {
        return this.values.valueY.value;
      },
      /**
       * Close value for vertical axis.
       *
       * This is an alias for `valueX` added for convenience only.
       *
       * @param value  Value
       */
      set: function(value) {
        this.setValue("valueY", value);
      },
      enumerable: true,
      configurable: true
    });
    return CandlestickSeriesDataItem2;
  }(ColumnSeriesDataItem)
);
var CandlestickSeries = (
  /** @class */
  function(_super) {
    __extends(CandlestickSeries2, _super);
    function CandlestickSeries2() {
      var _this = _super.call(this) || this;
      _this.className = "CandlestickSeries";
      _this.groupFields.lowValueX = "low";
      _this.groupFields.lowValueY = "low";
      _this.groupFields.highValueX = "high";
      _this.groupFields.highValueY = "high";
      _this.strokeOpacity = 1;
      var interfaceColors = new InterfaceColorSet();
      var positiveColor = interfaceColors.getFor("positive");
      var negativeColor = interfaceColors.getFor("negative");
      _this.dropFromOpenState.properties.fill = negativeColor;
      _this.dropFromOpenState.properties.stroke = negativeColor;
      _this.riseFromOpenState.properties.fill = positiveColor;
      _this.riseFromOpenState.properties.stroke = positiveColor;
      _this.applyTheme();
      return _this;
    }
    CandlestickSeries2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Candlestick Series");
      }
    };
    CandlestickSeries2.prototype.createDataItem = function() {
      return new CandlestickSeriesDataItem();
    };
    CandlestickSeries2.prototype.validateDataElementReal = function(dataItem) {
      _super.prototype.validateDataElementReal.call(this, dataItem);
      this.validateCandlestick(dataItem);
    };
    CandlestickSeries2.prototype.validateCandlestick = function(dataItem) {
      var column = dataItem.column;
      if (column) {
        var lowLine_1 = column.lowLine;
        var highLine_1 = column.highLine;
        if (this.baseAxis == this.xAxis) {
          var x = column.pixelWidth / 2;
          lowLine_1.x = x;
          highLine_1.x = x;
          var open_1 = dataItem.getWorkingValue(this.yOpenField);
          var close_1 = dataItem.getWorkingValue(this.yField);
          var yOpen = this.yAxis.getY(dataItem, this.yOpenField);
          var yClose = this.yAxis.getY(dataItem, this.yField);
          var yLow = this.yAxis.getY(dataItem, this.yLowField);
          var yHigh = this.yAxis.getY(dataItem, this.yHighField);
          var pixelY = column.pixelY;
          lowLine_1.y1 = yLow - pixelY;
          highLine_1.y1 = yHigh - pixelY;
          if (open_1 < close_1) {
            lowLine_1.y2 = yOpen - pixelY;
            highLine_1.y2 = yClose - pixelY;
          } else {
            lowLine_1.y2 = yClose - pixelY;
            highLine_1.y2 = yOpen - pixelY;
          }
        }
        if (this.baseAxis == this.yAxis) {
          var y = column.pixelHeight / 2;
          lowLine_1.y = y;
          highLine_1.y = y;
          var open_2 = dataItem.getWorkingValue(this.xOpenField);
          var close_2 = dataItem.getWorkingValue(this.xField);
          var xOpen = this.xAxis.getX(dataItem, this.xOpenField);
          var xClose = this.xAxis.getX(dataItem, this.xField);
          var xLow = this.xAxis.getX(dataItem, this.xLowField);
          var xHigh = this.xAxis.getX(dataItem, this.xHighField);
          var pixelX = column.pixelX;
          lowLine_1.x1 = xLow - pixelX;
          highLine_1.x1 = xHigh - pixelX;
          if (open_2 < close_2) {
            lowLine_1.x2 = xOpen - pixelX;
            highLine_1.x2 = xClose - pixelX;
          } else {
            lowLine_1.x2 = xClose - pixelX;
            highLine_1.x2 = xOpen - pixelX;
          }
        }
        each3(this.axisRanges.iterator(), function(axisRange) {
          var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);
          if (rangeColumn) {
            var rangeLowLine = rangeColumn.lowLine;
            rangeLowLine.x = lowLine_1.x;
            rangeLowLine.y = lowLine_1.y;
            rangeLowLine.x1 = lowLine_1.x1;
            rangeLowLine.x2 = lowLine_1.x2;
            rangeLowLine.y1 = lowLine_1.y1;
            rangeLowLine.y2 = lowLine_1.y2;
            var rangehighLine = rangeColumn.highLine;
            rangehighLine.x = highLine_1.x;
            rangehighLine.y = highLine_1.y;
            rangehighLine.x1 = highLine_1.x1;
            rangehighLine.x2 = highLine_1.x2;
            rangehighLine.y1 = highLine_1.y1;
            rangehighLine.y2 = highLine_1.y2;
          }
        });
      }
    };
    Object.defineProperty(CandlestickSeries2.prototype, "xLowField", {
      /**
       * A data field to look for "low" value for horizontal axis.
       *
       * @ignore Exclude from docs
       * @return Field name
       */
      get: function() {
        return this._xLowField;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CandlestickSeries2.prototype, "yLowField", {
      /**
       * A data field to look for "low" value for vertical axis.
       *
       * @ignore Exclude from docs
       * @return Field name
       */
      get: function() {
        return this._yLowField;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CandlestickSeries2.prototype, "xHighField", {
      /**
       * A data field to look for "high" value for horizontal axis.
       *
       * @ignore Exclude from docs
       * @return Field name
       */
      get: function() {
        return this._xHighField;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CandlestickSeries2.prototype, "yHighField", {
      /**
       * A data field to look for "high" value for vertical axis.
       *
       * @ignore Exclude from docs
       * @return Field name
       */
      get: function() {
        return this._yHighField;
      },
      enumerable: true,
      configurable: true
    });
    CandlestickSeries2.prototype.defineFields = function() {
      _super.prototype.defineFields.call(this);
      var xAxis = this.xAxis;
      var yAxis = this.yAxis;
      if (xAxis && yAxis) {
        if (this.baseAxis == xAxis) {
          var yAxisFieldName = capitalize(yAxis.axisFieldName);
          this._yLowField = "low" + yAxisFieldName + "Y";
          this._yHighField = "high" + yAxisFieldName + "Y";
        }
        if (this.baseAxis == yAxis) {
          var xAxisFieldName = capitalize(xAxis.axisFieldName);
          this._xLowField = "low" + xAxisFieldName + "X";
          this._xHighField = "high" + xAxisFieldName + "X";
        }
        this.addValueField(xAxis, this._xValueFields, this._xLowField);
        this.addValueField(xAxis, this._xValueFields, this._xHighField);
        this.addValueField(yAxis, this._yValueFields, this._yLowField);
        this.addValueField(yAxis, this._yValueFields, this._yHighField);
      }
    };
    CandlestickSeries2.prototype.createLegendMarker = function(marker) {
      var w = marker.pixelWidth;
      var h = marker.pixelHeight;
      marker.removeChildren();
      var column = marker.createChild(Candlestick);
      column.shouldClone = false;
      column.copyFrom(this.columns.template);
      var cw;
      var ch;
      var highLine = column.lowLine;
      var lowLine = column.highLine;
      if (this.baseAxis == this.yAxis) {
        cw = w / 3;
        ch = h;
        highLine.y = h / 2;
        lowLine.y = h / 2;
        highLine.x2 = w / 3;
        lowLine.x2 = w / 3;
        lowLine.x = w / 3 * 2;
        column.column.x = w / 3;
      } else {
        cw = w;
        ch = h / 3;
        highLine.x = w / 2;
        lowLine.x = w / 2;
        highLine.y2 = h / 3;
        lowLine.y2 = h / 3;
        lowLine.y = h / 3 * 2;
        column.column.y = h / 3;
      }
      column.width = cw;
      column.height = ch;
      copyProperties(this, marker, visualProperties);
      copyProperties(this.columns.template, column, visualProperties);
      column.stroke = this.riseFromOpenState.properties.stroke;
      column.fill = column.stroke;
      var legendDataItem = marker.dataItem;
      legendDataItem.color = column.fill;
      legendDataItem.colorOrig = column.fill;
    };
    CandlestickSeries2.prototype.createColumnTemplate = function() {
      return new Candlestick();
    };
    return CandlestickSeries2;
  }(ColumnSeries)
);
registry.registeredClasses["CandlestickSeries"] = CandlestickSeries;
registry.registeredClasses["CandlestickSeriesDataItem"] = CandlestickSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/OHLC.js
var OHLC = (
  /** @class */
  function(_super) {
    __extends(OHLC2, _super);
    function OHLC2() {
      var _this = _super.call(this) || this;
      _this.className = "OHLC";
      _this.layout = "none";
      return _this;
    }
    OHLC2.prototype.createAssets = function() {
      this.openLine = this.createChild(Line);
      this.openLine.shouldClone = false;
      this.highLowLine = this.createChild(Line);
      this.highLowLine.shouldClone = false;
      this.closeLine = this.createChild(Line);
      this.closeLine.shouldClone = false;
    };
    OHLC2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      if (this.openLine) {
        this.openLine.copyFrom(source.openLine);
      }
      if (this.highLowLine) {
        this.highLowLine.copyFrom(source.highLowLine);
      }
      if (this.closeLine) {
        this.closeLine.copyFrom(source.closeLine);
      }
    };
    return OHLC2;
  }(Candlestick)
);
registry.registeredClasses["OHLC"] = OHLC;

// node_modules/@amcharts/amcharts4/.internal/charts/series/OHLCSeries.js
var OHLCSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(OHLCSeriesDataItem2, _super);
    function OHLCSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "OHLCSeriesDataItem";
      _this.applyTheme();
      return _this;
    }
    return OHLCSeriesDataItem2;
  }(CandlestickSeriesDataItem)
);
var OHLCSeries = (
  /** @class */
  function(_super) {
    __extends(OHLCSeries2, _super);
    function OHLCSeries2() {
      var _this = _super.call(this) || this;
      _this.className = "OHLCSeries";
      _this.applyTheme();
      return _this;
    }
    OHLCSeries2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("OHLC Series");
      }
    };
    OHLCSeries2.prototype.createDataItem = function() {
      return new OHLCSeriesDataItem();
    };
    OHLCSeries2.prototype.validateCandlestick = function(dataItem) {
      var column = dataItem.column;
      if (column) {
        var openLine_1 = column.openLine;
        var highLowLine_1 = column.highLowLine;
        var closeLine_1 = column.closeLine;
        if (this.baseAxis == this.xAxis) {
          var x = column.pixelWidth / 2;
          highLowLine_1.x = x;
          dataItem.getWorkingValue(this.yOpenField);
          dataItem.getWorkingValue(this.yField);
          var yOpen = this.yAxis.getY(dataItem, this.yOpenField);
          var yClose = this.yAxis.getY(dataItem, this.yField);
          var yLow = this.yAxis.getY(dataItem, this.yLowField);
          var yHigh = this.yAxis.getY(dataItem, this.yHighField);
          var pixelY = column.pixelY;
          openLine_1.y1 = yOpen - pixelY;
          openLine_1.y2 = yOpen - pixelY;
          openLine_1.x1 = 0;
          openLine_1.x2 = x;
          closeLine_1.y1 = yClose - pixelY;
          closeLine_1.y2 = yClose - pixelY;
          closeLine_1.x1 = x;
          closeLine_1.x2 = 2 * x;
          highLowLine_1.y1 = yHigh - pixelY;
          highLowLine_1.y2 = yLow - pixelY;
        }
        if (this.baseAxis == this.yAxis) {
          var y = column.pixelHeight / 2;
          highLowLine_1.y = y;
          dataItem.getWorkingValue(this.xOpenField);
          dataItem.getWorkingValue(this.xField);
          var xOpen = this.xAxis.getX(dataItem, this.xOpenField);
          var xClose = this.xAxis.getX(dataItem, this.xField);
          var xLow = this.xAxis.getX(dataItem, this.xLowField);
          var xHigh = this.xAxis.getX(dataItem, this.xHighField);
          var pixelX = column.pixelX;
          openLine_1.x1 = xOpen - pixelX;
          openLine_1.x2 = xOpen - pixelX;
          openLine_1.y1 = y;
          openLine_1.y2 = 2 * y;
          closeLine_1.x1 = xClose - pixelX;
          closeLine_1.x2 = xClose - pixelX;
          closeLine_1.y1 = 0;
          closeLine_1.y2 = y;
          highLowLine_1.x1 = xHigh - pixelX;
          highLowLine_1.x2 = xLow - pixelX;
        }
        each3(this.axisRanges.iterator(), function(axisRange) {
          var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);
          if (rangeColumn) {
            var rangeOpenLine = rangeColumn.openLine;
            rangeOpenLine.x = openLine_1.x;
            rangeOpenLine.y = openLine_1.y;
            rangeOpenLine.x1 = openLine_1.x1;
            rangeOpenLine.x2 = openLine_1.x2;
            rangeOpenLine.y1 = openLine_1.y1;
            rangeOpenLine.y2 = openLine_1.y2;
            var rangeCloseLine = rangeColumn.closeLine;
            rangeCloseLine.x = closeLine_1.x;
            rangeCloseLine.y = closeLine_1.y;
            rangeCloseLine.x1 = closeLine_1.x1;
            rangeCloseLine.x2 = closeLine_1.x2;
            rangeCloseLine.y1 = closeLine_1.y1;
            rangeCloseLine.y2 = closeLine_1.y2;
            var rangeHighLowLine = rangeColumn.highLowLine;
            rangeHighLowLine.x = highLowLine_1.x;
            rangeHighLowLine.y = highLowLine_1.y;
            rangeHighLowLine.x1 = highLowLine_1.x1;
            rangeHighLowLine.x2 = highLowLine_1.x2;
            rangeHighLowLine.y1 = highLowLine_1.y1;
            rangeHighLowLine.y2 = highLowLine_1.y2;
          }
        });
      }
    };
    OHLCSeries2.prototype.createLegendMarker = function(marker) {
      var w = marker.pixelWidth;
      var h = marker.pixelHeight;
      marker.removeChildren();
      var column = marker.createChild(OHLC);
      column.shouldClone = false;
      column.copyFrom(this.columns.template);
      var cw;
      var ch;
      var openLine = column.openLine;
      var closeLine = column.closeLine;
      var highLowLine = column.highLowLine;
      if (this.baseAxis == this.yAxis) {
        cw = w / 3;
        ch = h;
        highLowLine.y = h / 2;
        highLowLine.x2 = w;
        openLine.x = w / 3 * 2;
        openLine.y2 = h / 2;
        closeLine.x = w / 3;
        closeLine.y2 = h;
        closeLine.y1 = h / 2;
      } else {
        cw = w;
        ch = h / 3;
        highLowLine.x = w / 2;
        highLowLine.y2 = h;
        openLine.y = h / 3 * 2;
        openLine.x2 = w / 2;
        closeLine.y = h / 3;
        closeLine.x2 = w;
        closeLine.x1 = w / 2;
      }
      column.width = cw;
      column.height = ch;
      copyProperties(this, marker, visualProperties);
      copyProperties(this.columns.template, column, visualProperties);
      column.stroke = this.riseFromOpenState.properties.stroke;
      var legendDataItem = marker.dataItem;
      legendDataItem.color = column.stroke;
      legendDataItem.colorOrig = column.stroke;
    };
    OHLCSeries2.prototype.createColumnTemplate = function() {
      return new OHLC();
    };
    return OHLCSeries2;
  }(CandlestickSeries)
);
registry.registeredClasses["OHLCSeries"] = OHLCSeries;
registry.registeredClasses["OHLCSeriesDataItem"] = OHLCSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/series/StepLineSeriesSegment.js
var StepLineSeriesSegment = (
  /** @class */
  function(_super) {
    __extends(StepLineSeriesSegment2, _super);
    function StepLineSeriesSegment2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "StepLineSeriesSegment";
      return _this;
    }
    StepLineSeriesSegment2.prototype.drawSegment = function(points, closePoints, smoothnessX, smoothnessY, noRisers, vertical) {
      if (points.length > 0 && closePoints.length > 0) {
        if (noRisers) {
          var path = moveTo(points[0]);
          if (points.length > 0) {
            for (var i = 1; i < points.length; i++) {
              var point = points[i];
              if (i / 2 == Math.round(i / 2)) {
                path += moveTo(point);
              } else {
                path += lineTo(point);
              }
            }
          }
          this.strokeSprite.path = path;
          if (this.fillOpacity > 0 || this.fillSprite.fillOpacity > 0) {
            path = moveTo(points[0]) + polyline(points);
            path += lineTo(closePoints[0]) + polyline(closePoints);
            path += lineTo(points[0]);
            path += closePath();
            this.fillSprite.path = path;
          } else {
          }
        } else {
          var path = moveTo(points[0]) + polyline(points);
          this.strokeSprite.path = path;
          if (this.fillOpacity > 0 || this.fillSprite.fillOpacity > 0) {
            path += lineTo(closePoints[0]) + polyline(closePoints);
            path += lineTo(points[0]);
            path += closePath();
            this.fillSprite.path = path;
          }
        }
      } else {
        this.strokeSprite.path = "";
        this.fillSprite.path = "";
      }
    };
    return StepLineSeriesSegment2;
  }(LineSeriesSegment)
);
registry.registeredClasses["StepLineSeriesSegment"] = StepLineSeriesSegment;

// node_modules/@amcharts/amcharts4/.internal/charts/series/StepLineSeries.js
var StepLineSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(StepLineSeriesDataItem2, _super);
    function StepLineSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "StepLineSeriesDataItem";
      _this.applyTheme();
      return _this;
    }
    return StepLineSeriesDataItem2;
  }(LineSeriesDataItem)
);
var StepLineSeries = (
  /** @class */
  function(_super) {
    __extends(StepLineSeries2, _super);
    function StepLineSeries2() {
      var _this = _super.call(this) || this;
      _this.className = "StepLineSeries";
      _this.applyTheme();
      _this.startLocation = 0;
      _this.endLocation = 1;
      return _this;
    }
    StepLineSeries2.prototype.createDataItem = function() {
      return new StepLineSeriesDataItem();
    };
    StepLineSeries2.prototype.addPoints = function(points, dataItem, xField, yField, backwards) {
      var startLocationX;
      var endLocationX;
      var startLocationY;
      var endLocationY;
      if (this.baseAxis == this.xAxis) {
        startLocationX = this.startLocation;
        endLocationX = this.endLocation;
        startLocationY = this.getAdjustedXLocation(dataItem, this.yOpenField);
        endLocationY = this.getAdjustedXLocation(dataItem, this.yField);
      }
      if (this.baseAxis == this.yAxis) {
        startLocationY = this.startLocation;
        endLocationY = this.endLocation;
        startLocationX = this.getAdjustedXLocation(dataItem, this.xOpenField);
        endLocationX = this.getAdjustedXLocation(dataItem, this.xField);
      }
      var x0 = this.xAxis.getX(dataItem, xField, startLocationX);
      var y0 = this.yAxis.getY(dataItem, yField, startLocationY);
      var x1 = this.xAxis.getX(dataItem, xField, endLocationX);
      var y1 = this.yAxis.getY(dataItem, yField, endLocationY);
      x0 = fitToRange(x0, -1e5, 1e5);
      y0 = fitToRange(y0, -1e5, 1e5);
      x1 = fitToRange(x1, -1e5, 1e5);
      y1 = fitToRange(y1, -1e5, 1e5);
      if (!this.noRisers) {
        if (points.length > 1) {
          var prevPoint = points[points.length - 1];
          if (this.baseAxis == this.xAxis) {
            if (backwards) {
              points.push({ x: prevPoint.x, y: y1 });
            } else {
              points.push({ x: x0, y: prevPoint.y });
            }
          }
          if (this.baseAxis == this.yAxis) {
            if (backwards) {
              points.push({ x: x1, y: prevPoint.y });
            } else {
              points.push({ x: prevPoint.x, y: y0 });
            }
          }
        }
      }
      var point0 = { x: x0, y: y0 };
      var point1 = { x: x1, y: y1 };
      if (backwards) {
        points.push(point1, point0);
      } else {
        points.push(point0, point1);
      }
    };
    StepLineSeries2.prototype.drawSegment = function(segment, points, closePoints) {
      var vertical = false;
      if (this.yAxis == this.baseAxis) {
        vertical = true;
      }
      segment.drawSegment(points, closePoints, this.tensionX, this.tensionY, this.noRisers, vertical);
    };
    StepLineSeries2.prototype.createSegment = function() {
      return new StepLineSeriesSegment();
    };
    Object.defineProperty(StepLineSeries2.prototype, "noRisers", {
      /**
       * @return No risers
       */
      get: function() {
        return this.getPropertyValue("noRisers");
      },
      /**
       * Specifies if step line series should draw only horizontal (or only
       * vertical, depending on base axis) lines, instead of connecting them with
       * vertical (or horizontal) lines.
       *
       * @default false
       * @param value  No risers
       */
      set: function(value) {
        this.setPropertyValue("noRisers", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(StepLineSeries2.prototype, "startLocation", {
      /**
       * @return Location (0-1)
       */
      get: function() {
        return this.getPropertyValue("startLocation");
      },
      /**
       * start location of the step
       *
       * @param value Location (0-1)
       * @default 0
       */
      set: function(value) {
        this.setPropertyValue("startLocation", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(StepLineSeries2.prototype, "endLocation", {
      /**
       * @return Location (0-1)
       */
      get: function() {
        return this.getPropertyValue("endLocation");
      },
      /**
       * Step end location.
       *
       * @param value Location (0-1)
       * #default 1
       */
      set: function(value) {
        this.setPropertyValue("endLocation", value, true);
      },
      enumerable: true,
      configurable: true
    });
    return StepLineSeries2;
  }(LineSeries)
);
registry.registeredClasses["StepLineSeries"] = StepLineSeries;
registry.registeredClasses["StepLineSeriesDataItem"] = StepLineSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/RadarColumn.js
var RadarColumn = (
  /** @class */
  function(_super) {
    __extends(RadarColumn2, _super);
    function RadarColumn2() {
      var _this = _super.call(this) || this;
      _this.className = "RadarColumn";
      return _this;
    }
    RadarColumn2.prototype.createAssets = function() {
      this.radarColumn = this.createChild(Slice);
      this.radarColumn.shouldClone = false;
      this.radarColumn.strokeOpacity = void 0;
      this.column = this.radarColumn;
    };
    RadarColumn2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      if (this.radarColumn) {
        this.radarColumn.copyFrom(source.radarColumn);
      }
    };
    RadarColumn2.prototype.getTooltipX = function() {
      var value = this.getPropertyValue("tooltipX");
      if (!isNumber(value)) {
        return this.radarColumn.getTooltipX();
      }
      return value;
    };
    RadarColumn2.prototype.getTooltipY = function() {
      var value = this.getPropertyValue("tooltipX");
      if (!isNumber(value)) {
        return this.radarColumn.getTooltipY();
      }
      return value;
    };
    return RadarColumn2;
  }(Column)
);
registry.registeredClasses["RadarColumn"] = RadarColumn;

// node_modules/@amcharts/amcharts4/.internal/charts/series/RadarColumnSeries.js
var RadarColumnSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(RadarColumnSeriesDataItem2, _super);
    function RadarColumnSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "ColumnSeriesDataItem";
      _this.applyTheme();
      return _this;
    }
    return RadarColumnSeriesDataItem2;
  }(ColumnSeriesDataItem)
);
var RadarColumnSeries = (
  /** @class */
  function(_super) {
    __extends(RadarColumnSeries2, _super);
    function RadarColumnSeries2() {
      var _this = _super.call(this) || this;
      _this.className = "RadarColumnSeries";
      _this.applyTheme();
      return _this;
    }
    RadarColumnSeries2.prototype.createColumnTemplate = function() {
      return new RadarColumn();
    };
    RadarColumnSeries2.prototype.validate = function() {
      if (this.chart.invalid) {
        this.chart.validate();
      }
      _super.prototype.validate.call(this);
    };
    RadarColumnSeries2.prototype.disableUnusedColumns = function(dataItem) {
      if (dataItem) {
        if (dataItem.column) {
          dataItem.column.__disabled = true;
        }
        each3(this.axisRanges.iterator(), function(axisRange) {
          var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);
          if (rangeColumn) {
            rangeColumn.__disabled = true;
          }
        });
      }
    };
    RadarColumnSeries2.prototype.validateDataElementReal = function(dataItem) {
      var _this = this;
      var startAngle = this.chart.startAngle;
      var endAngle = this.chart.endAngle;
      var yField = this.yField;
      var yOpenField = this.yOpenField;
      var xField = this.xField;
      var xOpenField = this.xOpenField;
      var lAngle;
      var rAngle;
      var tRadius;
      var bRadius;
      var startLocation = this.getStartLocation(dataItem);
      var endLocation = this.getEndLocation(dataItem);
      var cellAngle = (endAngle - startAngle) / (this.dataItems.length * (this.end - this.start));
      var radarColumn = dataItem.column;
      if (!radarColumn) {
        radarColumn = this.columns.create();
        dataItem.column = radarColumn;
        copyProperties(this, radarColumn, visualProperties);
        copyProperties(this.columns.template, radarColumn, visualProperties);
        dataItem.addSprite(radarColumn);
        radarColumn.paper = this.paper;
        this.setColumnStates(radarColumn);
      }
      var width = radarColumn.width;
      var percentWidth = 100;
      if (width instanceof Percent) {
        percentWidth = width.percent;
      }
      var offset = round((endLocation - startLocation) * (1 - percentWidth / 100) / 2, 5);
      startLocation += offset;
      endLocation -= offset;
      if (this.xAxis instanceof CategoryAxis && this.yAxis instanceof CategoryAxis) {
        tRadius = getDistance({ x: this.yAxis.getX(dataItem, yField, 0, "valueY"), y: this.yAxis.getY(dataItem, yField, 0, "valueY") });
        bRadius = getDistance({ x: this.yAxis.getX(dataItem, yOpenField, 1, "valueY"), y: this.yAxis.getY(dataItem, yOpenField, 1, "valueY") });
        lAngle = this.xAxis.getAngle(dataItem, xOpenField, 0, "valueX");
        rAngle = this.xAxis.getAngle(dataItem, xField, 1, "valueX");
        startAngle = startAngle + startLocation * cellAngle;
        endAngle = endAngle - (1 - endLocation) * cellAngle;
      } else if (this.baseAxis == this.xAxis) {
        tRadius = getDistance({ x: this.yAxis.getX(dataItem, yField, dataItem.locations[yField], "valueY"), y: this.yAxis.getY(dataItem, yField, dataItem.locations[yField], "valueY") });
        bRadius = getDistance({ x: this.yAxis.getX(dataItem, yOpenField, dataItem.locations[yOpenField], "valueY"), y: this.yAxis.getY(dataItem, yOpenField, dataItem.locations[yOpenField], "valueY") });
        lAngle = this.xAxis.getAngle(dataItem, xOpenField, startLocation, "valueX");
        rAngle = this.xAxis.getAngle(dataItem, xField, endLocation, "valueX");
        startAngle = startAngle + startLocation * cellAngle;
        endAngle = endAngle - (1 - endLocation) * cellAngle;
      } else {
        tRadius = getDistance({ x: this.yAxis.getX(dataItem, yField, startLocation, "valueY"), y: this.yAxis.getY(dataItem, yField, startLocation, "valueY") });
        bRadius = getDistance({ x: this.yAxis.getX(dataItem, yOpenField, endLocation, "valueY"), y: this.yAxis.getY(dataItem, yOpenField, endLocation, "valueY") });
        if (isNumber(width)) {
          var abs = Math.abs(tRadius - bRadius);
          if (abs > width) {
            var d = (abs - width) / 2;
            tRadius += d;
            bRadius -= d;
          }
        }
        lAngle = this.xAxis.getAngle(dataItem, xField, dataItem.locations[xField], "valueX");
        rAngle = this.xAxis.getAngle(dataItem, xOpenField, dataItem.locations[xOpenField], "valueX");
      }
      if (rAngle < lAngle) {
        var temp = rAngle;
        rAngle = lAngle;
        lAngle = temp;
      }
      lAngle = fitToRange(lAngle, startAngle, endAngle);
      rAngle = fitToRange(rAngle, startAngle, endAngle);
      var slice = radarColumn.radarColumn;
      slice.startAngle = lAngle;
      var arc2 = rAngle - lAngle;
      if (arc2 > 0) {
        slice.arc = arc2;
        slice.radius = tRadius;
        slice.innerRadius = bRadius;
        radarColumn.__disabled = false;
        radarColumn.parent = this.columnsContainer;
        each3(this.axisRanges.iterator(), function(axisRange) {
          var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);
          if (!rangeColumn) {
            rangeColumn = _this.columns.create();
            forceCopyProperties(_this.columns.template, rangeColumn, visualProperties);
            copyProperties(axisRange.contents, rangeColumn, visualProperties);
            if (rangeColumn.dataItem) {
              remove(rangeColumn.dataItem.sprites, rangeColumn);
            }
            dataItem.addSprite(rangeColumn);
            rangeColumn.paper = _this.paper;
            _this.setColumnStates(rangeColumn);
            dataItem.rangesColumns.setKey(axisRange.uid, rangeColumn);
          }
          var slice2 = rangeColumn.radarColumn;
          slice2.startAngle = lAngle;
          slice2.arc = arc2;
          slice2.radius = tRadius;
          slice2.innerRadius = bRadius;
          if (slice2.invalid) {
            slice2.paper = _this.paper;
            slice2.validate();
          }
          rangeColumn.__disabled = false;
          rangeColumn.parent = axisRange.contents;
        });
      } else {
        this.disableUnusedColumns(dataItem);
      }
    };
    RadarColumnSeries2.prototype.getPoint = function(dataItem, xKey, yKey, locationX, locationY, stackKeyX, stackKeyY) {
      if (!stackKeyX) {
        stackKeyX = "valueX";
      }
      if (!stackKeyY) {
        stackKeyY = "valueY";
      }
      var x = this.yAxis.getX(dataItem, yKey, locationY, stackKeyY);
      var y = this.yAxis.getY(dataItem, yKey, locationY, stackKeyY);
      var radius = getDistance({ x, y });
      if (radius == 0) {
        radius = 1e-5;
      }
      var angle = this.xAxis.getAngle(dataItem, xKey, locationX, stackKeyX);
      return { x: radius * cos(angle), y: radius * sin(angle) };
    };
    RadarColumnSeries2.prototype.getMaskPath = function() {
      var renderer = this.yAxis.renderer;
      return arc(renderer.startAngle, renderer.endAngle - renderer.startAngle, renderer.pixelRadius, renderer.pixelInnerRadius);
    };
    RadarColumnSeries2.prototype.positionBulletReal = function(bullet, positionX, positionY) {
      var xAxis = this.xAxis;
      var yAxis = this.yAxis;
      if (positionX < xAxis.start || positionX > xAxis.end || positionY < yAxis.start || positionY > yAxis.end) {
        bullet.visible = false;
      }
      bullet.moveTo(this.xAxis.renderer.positionToPoint(positionX, positionY));
    };
    RadarColumnSeries2.prototype.setXAxis = function(axis) {
      _super.prototype.setXAxis.call(this, axis);
      this.updateRendererRefs();
    };
    RadarColumnSeries2.prototype.setYAxis = function(axis) {
      _super.prototype.setYAxis.call(this, axis);
      this.updateRendererRefs();
    };
    RadarColumnSeries2.prototype.updateRendererRefs = function() {
      var rendererX = this.xAxis.renderer;
      var rendererY = this.yAxis.renderer;
      rendererX.axisRendererY = rendererY;
    };
    return RadarColumnSeries2;
  }(ColumnSeries)
);
registry.registeredClasses["RadarColumnSeries"] = RadarColumnSeries;
registry.registeredClasses["RadarColumnSeriesDataItem"] = RadarColumnSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/FunnelSlice.js
var FunnelSlice = (
  /** @class */
  function(_super) {
    __extends(FunnelSlice2, _super);
    function FunnelSlice2() {
      var _this = _super.call(this) || this;
      _this.slice = _this.createChild(Sprite);
      _this.slice.shouldClone = false;
      _this.slice.setElement(_this.paper.add("path"));
      _this.slice.isMeasured = false;
      _this.orientation = "vertical";
      _this.bottomWidth = percent(100);
      _this.topWidth = percent(100);
      _this.isMeasured = false;
      _this.width = 10;
      _this.height = 10;
      _this.expandDistance = 0;
      _this.className = "FunnelSlice";
      _this.applyTheme();
      return _this;
    }
    FunnelSlice2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      var pt = this.pixelPaddingTop;
      var pb = this.pixelPaddingBottom;
      var pr = this.pixelPaddingRight;
      var pl = this.pixelPaddingLeft;
      var w = this.pixelWidth - pr - pl;
      var h = this.pixelHeight - pt - pb;
      var ed = this.expandDistance;
      var path = "";
      if (this.orientation == "vertical") {
        var tw = relativeToValue(this.topWidth, w);
        var bw = relativeToValue(this.bottomWidth, w);
        var tl = { x: (w - tw) / 2 + pl, y: pt };
        var tr = { x: (w + tw) / 2 + pl, y: pt };
        var br = { x: (w + bw) / 2 + pl, y: pt + h };
        var bl = { x: (w - bw) / 2 + pl, y: pt + h };
        var cpr = { x: tr.x + (br.x - tr.x) / 2 + ed * h, y: tr.y + 0.5 * h };
        var cpl = { x: tl.x + (bl.x - tl.x) / 2 - ed * h, y: tl.y + 0.5 * h };
        var qp1 = lineTo(br);
        var qp2 = lineTo(tl);
        if (ed != 0) {
          qp1 = quadraticCurveTo(br, cpr);
          qp2 = quadraticCurveTo(tl, cpl);
        }
        path = moveTo(tl) + lineTo(tr) + qp1 + lineTo(bl) + qp2;
        this.tickPoint = { x: tr.x + (br.x - tr.x) / 2, y: tr.y + (br.y - tr.y) / 2 };
      } else {
        var tw = relativeToValue(this.topWidth, h);
        var bw = relativeToValue(this.bottomWidth, h);
        var tt = { x: pl, y: (h - tw) / 2 + pt };
        var tb = { x: pl, y: (h + tw) / 2 + pt };
        var bt = { x: pl + w, y: (h - bw) / 2 + pt };
        var bb = { x: pl + w, y: (h + bw) / 2 + pt };
        var cpr = { y: tt.y + (bt.y - tt.y) / 2 - ed * w, x: tt.x + 0.5 * w };
        var cpl = { y: tb.y + (bb.y - tb.y) / 2 + ed * w, x: tb.x + 0.5 * w };
        var qp1 = lineTo(bt);
        var qp2 = lineTo(tb);
        if (ed != 0) {
          qp1 = quadraticCurveTo(bt, cpr);
          qp2 = quadraticCurveTo(tb, cpl);
        }
        path = moveTo(tb) + lineTo(tt) + qp1 + lineTo(bb) + qp2;
        this.tickPoint = { y: tb.y + (bb.y - tb.y) / 2, x: tb.x + (bb.x - tb.x) / 2 };
      }
      this.slice.path = path;
      this.invalidateLayout();
    };
    FunnelSlice2.prototype.getPoint = function(locationX, locationY) {
      var pt = this.pixelPaddingTop;
      var pb = this.pixelPaddingBottom;
      var pr = this.pixelPaddingRight;
      var pl = this.pixelPaddingLeft;
      var w = this.pixelWidth - pr - pl;
      var h = this.pixelHeight - pt - pb;
      if (this.orientation == "vertical") {
        var tw = relativeToValue(this.topWidth, w);
        var bw = relativeToValue(this.bottomWidth, w);
        var tl = { x: (w - tw) / 2 + pl, y: pt };
        var tr = { x: (w + tw) / 2 + pl, y: pt };
        var br = { x: (w + bw) / 2 + pl, y: pt + h };
        var bl = { x: (w - bw) / 2 + pl, y: pt + h };
        var mlx = tl.x + (bl.x - tl.x) * locationY;
        var mrx = tr.x + (br.x - tr.x) * locationY;
        return { x: mlx + (mrx - mlx) * locationX, y: tr.y + (br.y - tr.y) * locationY };
      } else {
        var tw = relativeToValue(this.topWidth, h);
        var bw = relativeToValue(this.bottomWidth, h);
        var tt = { x: pl, y: (h - tw) / 2 + pt };
        var tb = { x: pl, y: (h + tw) / 2 + pt };
        var bt = { x: pl + w, y: (h - bw) / 2 + pt };
        var bb = { x: pl + w, y: (h + bw) / 2 + pt };
        var mty = tt.y + (bt.y - tt.y) * locationX;
        var mby = tb.y + (bb.y - tb.y) * locationX;
        return { y: mty + (mby - mty) * locationY, x: tt.x + (bt.x - tt.x) * locationX };
      }
    };
    Object.defineProperty(FunnelSlice2.prototype, "bottomWidth", {
      /**
       * @return bottom width
       */
      get: function() {
        return this.getPropertyValue("bottomWidth");
      },
      /**
       * Bottom width in pixels or percent.
       *
       * IMPORTANT: this setting might be used to set dimensions if you use slice
       * as a standalone element. If it's a part of [[FunnelSeries]] this setting
       * becomes read-only as it will be automatically reset by series.
       *
       * @param value  Bottom width
       */
      set: function(value) {
        this.setPercentProperty("bottomWidth", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FunnelSlice2.prototype, "topWidth", {
      /**
       * @return Top width
       */
      get: function() {
        return this.getPropertyValue("topWidth");
      },
      /**
       * Top width in pixels or percent.
       *
       * IMPORTANT: this setting might be used to set dimensions if you use slice
       * as a standalone element. If it's a part of [[FunnelSeries]] this setting
       * becomes read-only as it will be automatically reset by series.
       *
       * @param value  Top width
       */
      set: function(value) {
        this.setPercentProperty("topWidth", value, true, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FunnelSlice2.prototype, "orientation", {
      /**
       * @return Orientation
       */
      get: function() {
        return this.getPropertyValue("orientation");
      },
      /**
       * Orientation of the funnel slice: "horizontal" or "vertical".
       *
       * IMPORTANT: this setting might be used to set orintation if you use slice
       * as a standalone element. If it's a part of [[FunnelSeries]] this setting
       * becomes read-only as it will be automatically reset by series.
       *
       * @param value  Orientation
       */
      set: function(value) {
        this.setPropertyValue("orientation", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FunnelSlice2.prototype, "expandDistance", {
      /**
       * @return expandDistance
       */
      get: function() {
        return this.getPropertyValue("expandDistance");
      },
      /**
       * A relative distance slice's sides should be bent to. It's relative to the
       * height of the slice.
       *
       * Zero (default) will mean the sides will be perfectly straight.
       *
       * Positive value will make them bend outwards, resulting in "puffed" slices.
       *
       * Negative values will make them bend inwards.
       *
       * @default 0
       * @param {number}
       */
      set: function(value) {
        this.setPropertyValue("expandDistance", value, true);
      },
      enumerable: true,
      configurable: true
    });
    FunnelSlice2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      if (this.slice) {
        this.slice.copyFrom(source.slice);
      }
    };
    return FunnelSlice2;
  }(Container)
);
registry.registeredClasses["FunnelSlice"] = FunnelSlice;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/FunnelTick.js
var FunnelTick = (
  /** @class */
  function(_super) {
    __extends(FunnelTick2, _super);
    function FunnelTick2() {
      var _this = _super.call(this) || this;
      _this._label = new MutableValueDisposer();
      _this._slice = new MutableValueDisposer();
      _this.className = "FunnelTick";
      _this.element = _this.paper.add("path");
      _this._disposers.push(_this._label);
      _this._disposers.push(_this._slice);
      _this.setPropertyValue("locationX", 0);
      _this.setPropertyValue("locationY", 0);
      _this.applyTheme();
      return _this;
    }
    FunnelTick2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      var slice = this.slice;
      var point = slice.getPoint(this.locationX, this.locationY);
      if (point) {
        var label = this.label;
        var series = slice.dataItem.component;
        var p0 = void 0;
        var p1 = void 0;
        var p2 = void 0;
        if (series.orientation == "vertical") {
          var x1 = label.pixelX;
          var y1 = label.pixelY;
          if (!series.labelsOpposite) {
            x1 += label.maxRight;
          }
          p0 = spritePointToSprite(point, slice, this.parent);
          p2 = spritePointToSprite({ x: x1, y: y1 }, label.parent, this.parent);
          p1 = { x: label.parent.pixelX - this.length, y: p2.y };
          if (!series.labelsOpposite) {
            p1.x = label.parent.measuredWidth + this.length;
          }
        } else {
          var x1 = label.pixelX;
          var y1 = label.pixelY;
          if (!series.labelsOpposite) {
            y1 += label.maxBottom;
          }
          p0 = spritePointToSprite(point, slice, this.parent);
          p2 = spritePointToSprite({ x: x1, y: y1 }, label.parent, this.parent);
          p1 = { x: p2.x, y: label.parent.pixelY - this.length };
          if (!series.labelsOpposite) {
            p1.y = label.parent.measuredHeight + this.length;
          }
        }
        this.path = moveTo(p0) + lineTo(p1) + lineTo(p2);
      }
    };
    Object.defineProperty(FunnelTick2.prototype, "slice", {
      /**
       * @return FunnelSlice
       */
      get: function() {
        return this._slice.get();
      },
      /**
       * [[FunnelSlice]] element tick is attached to.
       *
       * @param slice  Slice
       */
      set: function(slice) {
        this._slice.set(slice, new MultiDisposer([
          slice.events.on("transformed", this.invalidate, this, false),
          slice.events.on("validated", this.invalidate, this, false)
        ]));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FunnelTick2.prototype, "label", {
      /**
       * @return Label
       */
      get: function() {
        return this._label.get();
      },
      /**
       * [[Label]] element tick is attached to.
       *
       * @param label  Label
       */
      set: function(label) {
        this._label.set(label, label.events.on("transformed", this.invalidate, this, false));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FunnelTick2.prototype, "locationX", {
      /**
       * @return Location (0-1)
       */
      get: function() {
        return this.getPropertyValue("locationX");
      },
      /**
       * A relative horizontal position within target element a tick is pointing
       * to.
       *
       * A scale is from 0 to 1, where 0 means left edge, and 1 right edge.
       *
       * You can also set any value in-between (e.g. 0.5 will point to the middle
       * of the slice), or outside 0-1 range, which will put tick anchor position
       * outside target element.
       *
       * @param value  Location (0-1)
       */
      set: function(value) {
        this.setPropertyValue("locationX", value, false, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FunnelTick2.prototype, "locationY", {
      /**
       * @return Location (0-1)
       */
      get: function() {
        return this.getPropertyValue("locationY");
      },
      /**
       * A relative vertical position within target element a tick is pointing
       * to.
       *
       * A scale is from 0 to 1, where 0 means top edge, and 1 bottom edge.
       *
       * You can also set any value in-between (e.g. 0.5 will point to the middle
       * of the slice), or outside 0-1 range, which will put tick anchor position
       * outside target element.
       *
       * @param value  Location (0-1)
       */
      set: function(value) {
        this.setPropertyValue("locationY", value, false, true);
      },
      enumerable: true,
      configurable: true
    });
    return FunnelTick2;
  }(Tick)
);
registry.registeredClasses["FunnelTick"] = FunnelTick;

// node_modules/@amcharts/amcharts4/.internal/charts/series/FunnelSeries.js
var FunnelSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(FunnelSeriesDataItem2, _super);
    function FunnelSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "FunnelSeriesDataItem";
      _this.events.on("visibilitychanged", function() {
        if (_this.component) {
          _this.component.invalidateDataItems();
        }
      }, _this, false);
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(FunnelSeriesDataItem2.prototype, "sliceLink", {
      /**
       * A [[FunnelSlice]] element, related to this data item ([[FunnelSlice]]).
       *
       * @readonly
       * @return Slice element
       */
      get: function() {
        var _this = this;
        if (!this._sliceLink) {
          var sliceLink_1 = this.component.sliceLinks.create();
          this._sliceLink = sliceLink_1;
          this._disposers.push(sliceLink_1);
          sliceLink_1.parent = this.component.slicesContainer;
          this._disposers.push(new Disposer(function() {
            if (_this.component) {
              _this.component.sliceLinks.removeValue(sliceLink_1);
            }
          }));
          this.addSprite(sliceLink_1);
          sliceLink_1.visible = this.visible;
        }
        return this._sliceLink;
      },
      enumerable: true,
      configurable: true
    });
    return FunnelSeriesDataItem2;
  }(PercentSeriesDataItem)
);
var FunnelSeries = (
  /** @class */
  function(_super) {
    __extends(FunnelSeries2, _super);
    function FunnelSeries2() {
      var _this = _super.call(this) || this;
      _this._nextY = 0;
      _this.className = "FunnelSeries";
      _this.orientation = "vertical";
      _this.width = percent(100);
      _this.height = percent(100);
      _this.slicesContainer.width = percent(100);
      _this.slicesContainer.height = percent(100);
      _this._disposers.push(_this.slicesContainer.events.on("maxsizechanged", _this.invalidateDataItems, _this, false));
      _this.labelsOpposite = true;
      _this.labelsContainer.layout = "absolute";
      _this.bottomRatio = 0;
      _this.applyTheme();
      return _this;
    }
    FunnelSeries2.prototype.createSlice = function() {
      return new FunnelSlice();
    };
    FunnelSeries2.prototype.createTick = function() {
      return new FunnelTick();
    };
    FunnelSeries2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Funnel Series");
      }
    };
    FunnelSeries2.prototype.createDataItem = function() {
      return new FunnelSeriesDataItem();
    };
    FunnelSeries2.prototype.initSlice = function(slice) {
      slice.isMeasured = false;
      slice.defaultState.properties.scale = 1;
      slice.observe("scale", this.handleSliceScale, this);
      slice.observe(["dx", "dy", "x", "y"], this.handleSliceMove, this);
      slice.tooltipText = "{category}: {value.percent.formatNumber('#.#p')} ({value.value})";
      var hoverState = slice.states.create("hover");
      hoverState.properties.expandDistance = 0.2;
    };
    FunnelSeries2.prototype.initLabel = function(label) {
      _super.prototype.initLabel.call(this, label);
      label.verticalCenter = "middle";
      label.horizontalCenter = "middle";
      label.isMeasured = true;
      label.padding(5, 5, 5, 5);
    };
    FunnelSeries2.prototype.validate = function() {
      _super.prototype.validate.call(this);
      this._nextY = 0;
    };
    FunnelSeries2.prototype.validateDataElements = function() {
      var _this = this;
      var slicesContainer = this.slicesContainer;
      var labelsContainer = this.labelsContainer;
      var labelTemplate = this.labels.template;
      if (this.alignLabels) {
        labelTemplate.interactionsEnabled = true;
        slicesContainer.isMeasured = true;
        labelsContainer.isMeasured = true;
      } else {
        labelTemplate.interactionsEnabled = false;
        slicesContainer.isMeasured = false;
        labelsContainer.isMeasured = false;
      }
      var total = 0;
      var count = 0;
      this.dataItems.each(function(dItem) {
        if (hasValue(dItem.value)) {
          count++;
          if (dItem.value > 0) {
            total += Math.abs(dItem.getWorkingValue("value") / dItem.value);
          } else {
            if (_this.ignoreZeroValues) {
              count--;
            } else {
              if (!dItem.visible || dItem.__disabled || dItem.isHiding) {
                count--;
              } else {
                total += 1;
              }
            }
          }
        }
      });
      this._total = 1 / count * total;
      this._count = count;
      _super.prototype.validateDataElements.call(this);
      this.arrangeLabels();
    };
    FunnelSeries2.prototype.getNextValue = function(dataItem) {
      var index = dataItem.index;
      var nextValue = dataItem.getWorkingValue("value");
      if (index < this.dataItems.length - 1) {
        var nextItem = this.dataItems.getIndex(index + 1);
        nextValue = nextItem.getWorkingValue("value");
        if (!nextItem.visible || nextItem.isHiding || nextItem.__disabled || nextItem.value == 0 && this.ignoreZeroValues) {
          return this.getNextValue(nextItem);
        }
      }
      return nextValue;
    };
    FunnelSeries2.prototype.formDataElement = function() {
    };
    FunnelSeries2.prototype.validateDataElement = function(dataItem) {
      var _this = this;
      var slice = dataItem.slice;
      slice.orientation = this.orientation;
      var sliceLink = dataItem.sliceLink;
      sliceLink.orientation = this.orientation;
      var tick = dataItem.tick;
      var label = dataItem.label;
      tick.slice = slice;
      tick.label = label;
      if (hasValue(dataItem.value)) {
        this.decorateSlice(dataItem);
        each(dataItem.sprites, function(sprite) {
          if (dataItem.value == 0 && _this.ignoreZeroValues) {
            sprite.__disabled = true;
          } else {
            sprite.__disabled = false;
          }
        });
      } else {
        each(dataItem.sprites, function(sprite) {
          sprite.__disabled = true;
        });
      }
      if (dataItem.index == this.dataItems.length - 1) {
        sliceLink.disabled = true;
      }
      _super.prototype.validateDataElement.call(this, dataItem);
      sliceLink.fill = slice.fill;
    };
    FunnelSeries2.prototype.decorateSlice = function(dataItem) {
      var slice = dataItem.slice;
      var sliceLink = dataItem.sliceLink;
      var label = dataItem.label;
      var tick = dataItem.tick;
      var maxWidth = this.slicesContainer.innerWidth;
      var maxHeight = this.slicesContainer.innerHeight;
      var nextValue = this.getNextValue(dataItem);
      var workingValue = Math.abs(dataItem.getWorkingValue("value"));
      var bottomRatio = this.bottomRatio;
      var d = 1;
      if (dataItem.value != 0) {
        d = workingValue / Math.abs(dataItem.value);
      } else {
        if (dataItem.__disabled || dataItem.isHiding || !dataItem.visible) {
          d = 1e-6;
        }
      }
      if (this.ignoreZeroValues && dataItem.value == 0) {
        dataItem.__disabled = true;
        return;
      } else {
        dataItem.__disabled = false;
      }
      if (this._nextY == Infinity) {
        this._nextY = 0;
      }
      if (this.orientation == "vertical") {
        var linkHeight = sliceLink.pixelHeight * d;
        maxHeight = maxHeight + linkHeight;
        slice.topWidth = workingValue / this.dataItem.values.value.high * maxWidth;
        slice.bottomWidth = (workingValue - (workingValue - nextValue) * bottomRatio) / this.dataItem.values.value.high * maxWidth;
        sliceLink.topWidth = slice.bottomWidth;
        sliceLink.bottomWidth = (workingValue - (workingValue - nextValue)) / this.dataItem.values.value.high * maxWidth;
        slice.y = this._nextY;
        slice.height = Math.min(1e5, max(0, maxHeight / this._count * d / this._total - linkHeight));
        slice.x = maxWidth / 2;
        if (!this.alignLabels) {
          label.x = slice.x;
        } else {
          label.x = void 0;
        }
        label.y = slice.pixelY + slice.pixelHeight * tick.locationY;
        this._nextY += slice.pixelHeight + linkHeight;
        sliceLink.y = this._nextY - linkHeight;
        sliceLink.x = slice.x;
      } else {
        var linkWidth = sliceLink.pixelWidth * d;
        maxWidth = maxWidth + linkWidth;
        slice.topWidth = workingValue / this.dataItem.values.value.high * maxHeight;
        slice.bottomWidth = (workingValue - (workingValue - nextValue) * bottomRatio) / this.dataItem.values.value.high * maxHeight;
        sliceLink.topWidth = slice.bottomWidth;
        sliceLink.bottomWidth = (workingValue - (workingValue - nextValue)) / this.dataItem.values.value.high * maxHeight;
        slice.x = this._nextY;
        slice.width = Math.min(1e5, maxWidth / this._count * d * 1 / this._total - linkWidth);
        slice.y = maxHeight / 2;
        if (!this.alignLabels) {
          label.y = slice.y;
        } else {
          label.y = this.labelsContainer.measuredHeight;
        }
        label.x = slice.pixelX + slice.pixelWidth * tick.locationX;
        this._nextY += slice.pixelWidth + linkWidth;
        sliceLink.x = this._nextY - linkWidth;
        sliceLink.y = slice.y;
      }
    };
    FunnelSeries2.prototype.getLastLabel = function(index) {
      if (index > 0) {
        var lastLabel = this.labels.getIndex(index);
        if (lastLabel.__disabled || !lastLabel.visible) {
          return this.getLastLabel(index - 1);
        } else {
          return lastLabel;
        }
      }
    };
    FunnelSeries2.prototype.arrangeLabels = function() {
      if (this.alignLabels) {
        var count = this.labels.length;
        if (count > 1) {
          var lastLabel = this.getLastLabel(count - 1);
          if (lastLabel) {
            var lastY = lastLabel.pixelY;
            var lastX = lastLabel.pixelX;
            if (count > 1) {
              for (var i = count - 2; i >= 0; i--) {
                var label = this.labels.getIndex(i);
                if (label.visible && !label.__disabled) {
                  if (label.invalid) {
                    label.validate();
                  }
                  if (this.orientation == "vertical") {
                    if (label.pixelY + label.measuredHeight > lastY) {
                      label.y = Math.min(1e6, lastY - label.measuredHeight);
                    }
                  } else {
                    if (label.pixelX + label.measuredWidth > lastX) {
                      label.x = Math.min(1e6, lastX - label.measuredWidth);
                    }
                  }
                  lastY = label.pixelY;
                  lastX = label.pixelX;
                }
              }
              lastY = 0;
              lastX = 0;
              for (var i = 0; i < count; i++) {
                var label = this.labels.getIndex(i);
                if (label.visible && !label.__disabled) {
                  if (label.invalid) {
                    label.validate();
                  }
                  if (this.orientation == "vertical") {
                    if (label.pixelY < lastY) {
                      label.y = Math.min(1e6, lastY);
                    }
                  } else {
                    if (label.pixelX < lastX) {
                      label.x = Math.min(1e6, lastX);
                    }
                  }
                  lastY += label.measuredHeight;
                  lastX += label.measuredWidth;
                }
              }
            }
          }
        }
      }
    };
    FunnelSeries2.prototype.positionBullet = function(bullet) {
      _super.prototype.positionBullet.call(this, bullet);
      var dataItem = bullet.dataItem;
      var slice = dataItem.slice;
      var locationX = bullet.locationX;
      if (!isNumber(locationX)) {
        locationX = 0.5;
      }
      var locationY = bullet.locationY;
      if (!isNumber(locationY)) {
        locationY = 1;
      }
      bullet.x = slice.pixelX + slice.measuredWidth * locationX;
      bullet.y = slice.pixelY + slice.measuredHeight * locationY;
    };
    Object.defineProperty(FunnelSeries2.prototype, "orientation", {
      /**
       * @return Orientation
       */
      get: function() {
        return this.getPropertyValue("orientation");
      },
      /**
       * Orientation of the funnel slices: "horizontal" or "vertical" (default).
       *
       * @default "vertical"
       * @param value Orientation
       */
      set: function(value) {
        if (this.setPropertyValue("orientation", value)) {
          this.labelsOpposite = this.labelsOpposite;
          this.invalidate();
          if (value == "vertical") {
            this.ticks.template.locationX = 1;
            this.ticks.template.locationY = 0.5;
            this.labels.template.rotation = 0;
            this.layout = "horizontal";
          } else {
            this.ticks.template.locationX = 0.5;
            this.ticks.template.locationY = 1;
            this.labels.template.rotation = -90;
            this.layout = "vertical";
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FunnelSeries2.prototype, "bottomRatio", {
      /**
       * @return {number}
       */
      get: function() {
        return this.getPropertyValue("bottomRatio");
      },
      /**
       * Indicates how slice's bottom will change in relation to slices top AND
       * next slices top.
       *
       * Basically it's a relative value (0-1) that indicates bottom width
       * position between current slice's top width and the top withd of the next
       * one.
       *
       * The scale goes from 0 (closer to current slice width) to 1 (closer to next
       * slice with).
       *
       * `0` (default) will mean that bottom will be the same as top, resulting in
       * a prefectly square slice.
       *
       * From the data-viz standpoint `0` is a correct setting, since area of the
       * slices will depict their value correctly.
       *
       * `1` will mean that slice will become trapezoid with its bottom matching
       * width of the next slice.
       *
       * `0.5` will make bottom width be in the middle of width of current slice
       * and the next slice.
       *
       * @default 0
       * @param {number}
       */
      set: function(value) {
        if (this.setPropertyValue("bottomRatio", value)) {
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FunnelSeries2.prototype, "sliceLinks", {
      /**
       * A list of elements linking each actual slice.
       *
       * Please note that links are [[FunnelSlice]] objects, just like real links,
       * so they have all the same configuration options.
       *
       * You can use `template` of this link, to specify how links will look.
       *
       * ```TypeScript
       * series.sliceLinks.template.fillOpacity = 0.5;
       * ```
       * ```JavaScript
       * series.sliceLinks.template.fillOpacity = 0.5;
       * ```
       * ```JSON
       * {
       *   // ...
       *   "series": [{
       *     "type": "FunnelSeries",
       *      // ...
       *      "sliceLinks": {
       *        "fillOpacity": 0.5
       *      }
       *   }]
       * }
       * ```
       *
       * @return Funnel links
       */
      get: function() {
        if (!this._sliceLinks) {
          var sliceLink = new FunnelSlice();
          sliceLink.applyOnClones = true;
          sliceLink.fillOpacity = 0.5;
          sliceLink.expandDistance = -0.3;
          sliceLink.hiddenState.properties.opacity = 0;
          this._disposers.push(sliceLink);
          this._sliceLinks = new ListTemplate(sliceLink);
          this._disposers.push(new ListDisposer(this._sliceLinks));
        }
        return this._sliceLinks;
      },
      enumerable: true,
      configurable: true
    });
    FunnelSeries2.prototype.show = function(duration) {
      var _this = this;
      var startIndex = this.startIndex;
      var endIndex = this.endIndex;
      var interpolationDuration = this.defaultState.transitionDuration;
      if (isNumber(duration)) {
        interpolationDuration = duration;
      }
      if (!options.animationsEnabled) {
        interpolationDuration = 0;
      }
      var delay = 0;
      each3(indexed(this.dataItems.iterator()), function(a) {
        var i = a[0];
        var dataItem = a[1];
        if (_this.sequencedInterpolation) {
          delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);
        }
        dataItem.show(interpolationDuration, delay, ["value"]);
      });
      var animation = _super.prototype.show.call(this, duration);
      return animation;
    };
    FunnelSeries2.prototype.hide = function(duration) {
      var _this = this;
      var fields = ["value"];
      var value = 0;
      var startIndex = this.startIndex;
      var endIndex = this.endIndex;
      var delay = 0;
      var interpolationDuration = this.hiddenState.transitionDuration;
      if (isNumber(duration)) {
        interpolationDuration = duration;
      }
      if (!options.animationsEnabled) {
        interpolationDuration = 0;
      }
      each3(indexed(this.dataItems.iterator()), function(a) {
        var i = a[0];
        var dataItem = a[1];
        if (_this.sequencedInterpolation) {
          delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);
        }
        dataItem.hide(interpolationDuration, delay, value, fields);
      });
      var animation = _super.prototype.hide.call(this, duration);
      if (animation && !animation.isFinished()) {
        animation.delay(delay);
      }
      return animation;
    };
    FunnelSeries2.prototype.setAlignLabels = function(value) {
      _super.prototype.setAlignLabels.call(this, value);
      this.ticks.template.disabled = !value;
      var labelsContainer = this.labelsContainer;
      if (labelsContainer) {
        if (!value) {
          labelsContainer.width = percent(100);
          labelsContainer.height = percent(100);
        } else {
          labelsContainer.height = void 0;
          labelsContainer.width = void 0;
          labelsContainer.margin(10, 10, 10, 10);
        }
      }
      this.labelsOpposite = this.labelsOpposite;
    };
    Object.defineProperty(FunnelSeries2.prototype, "labelsOpposite", {
      /**
       * @return Labels on opposite side?
       */
      get: function() {
        return this.getPropertyValue("labelsOpposite");
      },
      /**
       * Put labels on the oppsite side of the series?
       *
       * This setting is only used if `alignLabels = true`.
       *
       * If set to `true` (default) labels will be drawn to the right (on vertical
       * series), or to the bottom (on horizontal series).
       *
       * If set to `false`, labels will be positioned to the left or top
       * respectively.
       *
       * @default true
       * @since 4.1.13
       * @param  value  Labels on opposite side?
       */
      set: function(value) {
        this.setPropertyValue("labelsOpposite", value);
        var labelTemplate = this.labels.template;
        var labelAlign = "none";
        var labelValign = "none";
        if (!this.alignLabels) {
          if (this.orientation == "vertical") {
            labelAlign = "center";
          } else {
            labelValign = "middle";
          }
        } else {
          if (value) {
            this.labelsContainer.toFront();
            if (this.orientation == "vertical") {
              this.ticks.template.locationX = 1;
              labelTemplate.horizontalCenter = "left";
              labelAlign = "right";
            } else {
              this.ticks.template.locationY = 1;
              labelTemplate.horizontalCenter = "right";
              labelValign = "bottom";
            }
          } else {
            this.labelsContainer.toBack();
            if (this.orientation == "vertical") {
              this.ticks.template.locationX = 0;
              labelAlign = "left";
            } else {
              labelValign = "top";
              this.ticks.template.locationY = 0;
            }
          }
        }
        labelTemplate.align = labelAlign;
        labelTemplate.valign = labelValign;
        this.validateLayout();
        this.ticks.each(function(tick) {
          tick.invalidate();
        });
        this.invalidateDataItems();
      },
      enumerable: true,
      configurable: true
    });
    return FunnelSeries2;
  }(PercentSeries)
);
registry.registeredClasses["FunnelSeries"] = FunnelSeries;
registry.registeredClasses["FunnelSeriesDataItem"] = FunnelSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/series/PyramidSeries.js
var PyramidSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(PyramidSeriesDataItem2, _super);
    function PyramidSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "PyramidSeriesDataItem";
      _this.applyTheme();
      return _this;
    }
    return PyramidSeriesDataItem2;
  }(FunnelSeriesDataItem)
);
var PyramidSeries = (
  /** @class */
  function(_super) {
    __extends(PyramidSeries2, _super);
    function PyramidSeries2() {
      var _this = _super.call(this) || this;
      _this.className = "PyramidSeries";
      _this.topWidth = percent(0);
      _this.bottomWidth = percent(100);
      _this.pyramidHeight = percent(100);
      _this.valueIs = "area";
      _this.sliceLinks.template.width = 0;
      _this.sliceLinks.template.height = 0;
      _this.applyTheme();
      return _this;
    }
    PyramidSeries2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Pyramid Series");
      }
    };
    PyramidSeries2.prototype.createDataItem = function() {
      return new PyramidSeriesDataItem();
    };
    PyramidSeries2.prototype.validate = function() {
      _super.prototype.validate.call(this);
      this._nextWidth = void 0;
    };
    PyramidSeries2.prototype.getNextValue = function(dataItem) {
      var index = dataItem.index;
      var nextValue = dataItem.getWorkingValue("value");
      if (index < this.dataItems.length - 1) {
        var nextItem = this.dataItems.getIndex(index + 1);
        nextValue = nextItem.getWorkingValue("value");
      }
      if (nextValue == 0) {
        nextValue = 1e-6;
      }
      return nextValue;
    };
    PyramidSeries2.prototype.validateDataElements = function() {
      var _this = this;
      var maxWidth = this.slicesContainer.innerWidth;
      var maxHeight = this.slicesContainer.innerHeight;
      this.dataItems.each(function(dataItem) {
        if (dataItem.value > 0) {
          var relValue = dataItem.getWorkingValue("value") / dataItem.value;
          var sliceLink = dataItem.sliceLink;
          if (_this.orientation == "vertical") {
            maxHeight -= sliceLink.pixelHeight * relValue;
          } else {
            maxWidth -= sliceLink.pixelWidth * relValue;
          }
        }
      });
      this._pyramidHeight = relativeToValue(this.pyramidHeight, maxHeight);
      this._pyramidWidth = relativeToValue(this.pyramidHeight, maxWidth);
      if (this.orientation == "vertical") {
        var y = (maxHeight - this._pyramidHeight) / 2;
        this.slicesContainer.y = y;
        this.labelsContainer.y = y;
        this.ticksContainer.y = y;
      } else {
        var x = (maxWidth - this._pyramidWidth) / 2;
        this.slicesContainer.x = x;
        this.labelsContainer.x = x;
        this.ticksContainer.x = x;
      }
      _super.prototype.validateDataElements.call(this);
    };
    PyramidSeries2.prototype.decorateSlice = function(dataItem) {
      var sum = this.dataItem.values.value.absoluteSum;
      if (sum == 0) {
        return;
      }
      var slice = dataItem.slice;
      var sliceLink = dataItem.sliceLink;
      var label = dataItem.label;
      var tick = dataItem.tick;
      this.getNextValue(dataItem);
      var workingValue = Math.abs(dataItem.getWorkingValue("value"));
      var pyramidWidth = this._pyramidWidth;
      var pyramidHeight = this._pyramidHeight;
      var maxWidth = this.slicesContainer.innerWidth;
      var maxHeight = this.slicesContainer.innerHeight;
      var linkWidth = sliceLink.pixelWidth;
      var linkHeight = sliceLink.pixelHeight;
      if ((dataItem.value == 0 || dataItem.value == null) && this.ignoreZeroValues) {
        dataItem.__disabled = true;
      } else {
        dataItem.__disabled = false;
      }
      if (this.orientation == "vertical") {
        var topWidth = relativeToValue(this.topWidth, maxWidth);
        if (!isNumber(this._nextWidth)) {
          this._nextWidth = topWidth;
        }
        var bottomWidth = relativeToValue(this.bottomWidth, maxWidth);
        var sliceTopWidth = this._nextWidth;
        var angle = Math.atan2(pyramidHeight, topWidth - bottomWidth);
        var c = Math.tan(Math.PI / 2 - angle);
        if (c == 0) {
          c = 1e-8;
        }
        var sliceHeight = void 0;
        var sliceBottomWidth = void 0;
        if (this.valueIs == "area") {
          var totalSquare = (topWidth + bottomWidth) / 2 * pyramidHeight;
          var square = totalSquare * workingValue / sum;
          var s = Math.abs(sliceTopWidth * sliceTopWidth - 2 * square * c);
          sliceHeight = (sliceTopWidth - Math.sqrt(s)) / c;
          if (sliceHeight > 0) {
            sliceBottomWidth = (2 * square - sliceHeight * sliceTopWidth) / sliceHeight;
          } else {
            sliceBottomWidth = sliceTopWidth;
          }
        } else {
          sliceHeight = pyramidHeight * workingValue / sum;
          sliceBottomWidth = sliceTopWidth - sliceHeight * c;
        }
        slice.height = sliceHeight;
        slice.width = maxWidth;
        slice.bottomWidth = sliceBottomWidth;
        slice.topWidth = sliceTopWidth;
        sliceLink.topWidth = slice.bottomWidth;
        sliceLink.bottomWidth = slice.bottomWidth;
        slice.y = this._nextY;
        if (!this.alignLabels) {
          label.x = maxWidth / 2;
        } else {
          label.x = 0;
        }
        label.y = slice.pixelY + slice.pixelHeight * tick.locationY + slice.dy;
        this._nextY += slice.pixelHeight + linkHeight * workingValue / Math.max(Math.abs(dataItem.value), 1e-8);
        sliceLink.y = this._nextY - linkHeight;
        sliceLink.x = maxWidth / 2;
      } else {
        var topWidth = relativeToValue(this.topWidth, maxHeight);
        if (!isNumber(this._nextWidth)) {
          this._nextWidth = topWidth;
        }
        var bottomWidth = relativeToValue(this.bottomWidth, maxHeight);
        var sliceTopWidth = this._nextWidth;
        var angle = Math.atan2(pyramidWidth, topWidth - bottomWidth);
        var c = Math.tan(Math.PI / 2 - angle);
        if (c == 0) {
          c = 1e-8;
        }
        var sliceWidth = void 0;
        var sliceBottomWidth = void 0;
        if (this.valueIs == "area") {
          var totalSquare = (topWidth + bottomWidth) / 2 * pyramidWidth;
          var square = totalSquare * workingValue / sum;
          sliceWidth = (sliceTopWidth - Math.sqrt(sliceTopWidth * sliceTopWidth - 2 * square * c)) / c;
          sliceBottomWidth = (2 * square - sliceWidth * sliceTopWidth) / sliceWidth;
        } else {
          sliceWidth = pyramidWidth * workingValue / sum;
          sliceBottomWidth = sliceTopWidth - sliceWidth * c;
        }
        slice.width = sliceWidth;
        slice.height = maxHeight;
        slice.bottomWidth = sliceBottomWidth;
        slice.topWidth = sliceTopWidth;
        sliceLink.topWidth = slice.bottomWidth;
        sliceLink.bottomWidth = slice.bottomWidth;
        slice.x = this._nextY;
        if (!this.alignLabels) {
          label.y = maxHeight / 2;
        } else {
          label.y = this.labelsContainer.measuredHeight;
        }
        label.x = slice.pixelX + slice.pixelWidth * tick.locationX + slice.dx;
        this._nextY += slice.pixelWidth + linkWidth * workingValue / Math.max(Math.abs(dataItem.value), 1e-8);
        sliceLink.x = this._nextY - linkWidth;
        sliceLink.y = maxHeight / 2;
      }
      this._nextWidth = slice.bottomWidth;
    };
    Object.defineProperty(PyramidSeries2.prototype, "topWidth", {
      /**
       * @return {number | Percent}
       */
      get: function() {
        return this.getPropertyValue("topWidth");
      },
      /**
       * Width of the pyramid's tip in pixels or relative (`Percent`).
       *
       * `0%` (default) means the pyramid will be perfectly pointy.
       * `50%` will have a cut off / blunt top that is half the width of the chart.
       * `100%` will take the whole width of the chart.
       *
       * If you need the downward-pointing pyramid, you might want to `topWidth` to
       * `100%` and `bottomWidth` to `0%`.
       *
       * @default 0%
       * @param {number | Percent}
       */
      set: function(value) {
        if (this.setPercentProperty("topWidth", value, false, false, 10, false)) {
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PyramidSeries2.prototype, "pyramidHeight", {
      /**
       * @return {number | Percent}
       */
      get: function() {
        return this.getPropertyValue("pyramidHeight");
      },
      /**
       * Height of pyramid
       *
       *
       * @default 100%
       * @param {number | Percent}
       */
      set: function(value) {
        if (this.setPercentProperty("pyramidHeight", value, false, false, 10, false)) {
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PyramidSeries2.prototype, "bottomWidth", {
      /**
       * @return {number | Percent}
       */
      get: function() {
        return this.getPropertyValue("bottomWidth");
      },
      /**
       * Width of the pyramid's bottom (bsae) in pixels or relative (`Percent`).
       *
       * `0%` means the pyramid's botto will be pointy.
       * `50%` will have a cut off / blunt bottom that is half the width of the chart.
       * `100%` (default) will take the whole width of the chart.
       *
       * If you need the downward-pointing pyramid, you might want to `topWidth` to
       * `100%` and `bottomWidth` to `0%`.
       *
       * @param {number | Percent}
       */
      set: function(value) {
        if (this.setPercentProperty("bottomWidth", value, false, false, 10, false)) {
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PyramidSeries2.prototype, "valueIs", {
      /**
       * @return {"area" | "height"}
       */
      get: function() {
        return this.getPropertyValue("valueIs");
      },
      /**
       * Indicates how slice's value will influence its size.
       *
       * `"area"` (default) means that the whole area of the pyramid (counting in
       * modifications by `topWidth` and `bottomWidth`) will be divvied up between
       * slices based on their value.
       *
       * With this setting at `"area"` the area of the trapezoids of each slice
       * will represent their value relatively to values of the other slices.
       *
       * This is a correct way to depict "weight" of each slice based on their
       * values.
       *
       * `"height"` means whole height (as opposed to area) of the pyramid will be
       * divvied up between slices. Actual slice width or area is not counted in.
       *
       * From the data-viz standpoint this does not make a lot of sense, since
       * slices with lesser values might appear more prominent if they are placed
       * towards thick end of the pyramid since their areas will be bigger.
       *
       * @default "area"
       * @param {"area" | "height"}
       */
      set: function(value) {
        if (this.setPropertyValue("valueIs", value)) {
          this.invalidate();
        }
      },
      enumerable: true,
      configurable: true
    });
    return PyramidSeries2;
  }(FunnelSeries)
);
registry.registeredClasses["PyramidSeries"] = PyramidSeries;
registry.registeredClasses["PyramidSeriesDataItem"] = PyramidSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/series/PictorialStackedSeries.js
var PictorialStackedSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(PictorialStackedSeriesDataItem2, _super);
    function PictorialStackedSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "PictorialStackedSeriesDataItem";
      _this.applyTheme();
      return _this;
    }
    return PictorialStackedSeriesDataItem2;
  }(PyramidSeriesDataItem)
);
var PictorialStackedSeries = (
  /** @class */
  function(_super) {
    __extends(PictorialStackedSeries2, _super);
    function PictorialStackedSeries2() {
      var _this = _super.call(this) || this;
      _this.className = "PictorialStackedSeries";
      _this.topWidth = percent(100);
      _this.bottomWidth = percent(100);
      _this.valueIs = "height";
      _this.applyTheme();
      _this.startLocation = 0;
      _this.endLocation = 1;
      _this.align = "center";
      _this.valign = "middle";
      _this._maskSprite = _this.slicesContainer.createChild(Sprite);
      _this._maskSprite.visible = false;
      _this._maskSprite.zIndex = 100;
      _this._maskSprite.shouldClone = false;
      return _this;
    }
    PictorialStackedSeries2.prototype.validateDataElements = function() {
      var maxWidth = this.slicesContainer.maxWidth;
      var maxHeight = this.slicesContainer.maxHeight;
      var maskSprite = this._maskSprite;
      var pictureWidth = maskSprite.measuredWidth / maskSprite.scale;
      var pictureHeight = maskSprite.measuredHeight / maskSprite.scale;
      var scale = min(maxHeight / pictureHeight, maxWidth / pictureWidth);
      if (scale == Infinity) {
        scale = 1;
      }
      scale = max(1e-3, scale);
      var startLocation = this.startLocation;
      var endLocation = this.endLocation;
      var newWidth = min(maxWidth, pictureWidth * scale);
      var newHeight = min(maxHeight, pictureHeight * scale);
      maskSprite.scale = scale;
      if (this.orientation == "vertical") {
        this.topWidth = newWidth + 4;
        this.bottomWidth = newWidth + 4;
        this.pyramidHeight = newHeight * (endLocation - startLocation);
        maskSprite.x = maxWidth / 2;
        maskSprite.y = newHeight / 2;
      } else {
        this.topWidth = newHeight + 4;
        this.bottomWidth = newHeight + 4;
        this.pyramidHeight = newWidth * (endLocation - startLocation);
        maskSprite.valign = "middle";
        maskSprite.x = newWidth / 2;
        maskSprite.y = maxHeight / 2;
      }
      maskSprite.verticalCenter = "middle";
      maskSprite.horizontalCenter = "middle";
      _super.prototype.validateDataElements.call(this);
      var y;
      var x;
      if (this.orientation == "vertical") {
        if (this.valign == "bottom") {
          y = maxHeight - newHeight;
        }
        if (this.valign == "middle") {
          y = (maxHeight - newHeight) / 2;
        }
        if (this.valign == "top") {
          y = 0;
        }
        if (this.align == "left") {
          x = -(maxWidth - newWidth) / 2;
        }
        if (this.align == "center") {
          x = 0;
        }
        if (this.align == "right") {
          x = (maxWidth - newWidth) / 2;
        }
        this.slices.template.dy = startLocation * newHeight;
        if (this.alignLabels) {
          this.slicesContainer.dx = x;
        }
      } else {
        if (this.valign == "bottom") {
          y = (maxHeight - newHeight) / 2;
        }
        if (this.valign == "middle") {
          y = 0;
        }
        if (this.valign == "top") {
          y = -(maxHeight - newHeight) / 2;
        }
        if (this.align == "left") {
          x = 0;
        }
        if (this.align == "center") {
          x = (maxWidth - newWidth) / 2;
        }
        if (this.align == "right") {
          x = maxWidth - newWidth;
        }
        this.slices.template.dx = startLocation * newWidth;
        if (this.alignLabels) {
          this.slicesContainer.dy = y;
        }
      }
      this.slicesContainer.x = x;
      this.labelsContainer.x = x;
      this.ticksContainer.x = x;
      this.slicesContainer.y = y;
      this.labelsContainer.y = y;
      this.ticksContainer.y = y;
      if (newWidth > 0 && newHeight > 0) {
        this.slicesContainer.mask = maskSprite;
      }
    };
    PictorialStackedSeries2.prototype.applyInternalDefaults = function() {
      _super.prototype.applyInternalDefaults.call(this);
      if (!hasValue(this.readerTitle)) {
        this.readerTitle = this.language.translate("Pyramid Series");
      }
    };
    PictorialStackedSeries2.prototype.createDataItem = function() {
      return new PictorialStackedSeriesDataItem();
    };
    Object.defineProperty(PictorialStackedSeries2.prototype, "maskSprite", {
      /**
       * A [[Sprite]] element that is used as a series mask.
       *
       * If set, this element's shape will be used to apply shape to the whole
       * stacked pictorial series.
       *
       * You can use this element's `path` property to set an SVG path for the
       * shape:
       *
       * ```TypeScript
       * let iconPath = "M511.82,329.991c-0.256-1.212-1.064-2.244-2.192-2.784l-24.396-11.684c17.688-29.776,11.804-68.912-15.58-91.88 c-53.756-45.084-131.696-70.936-213.828-70.936c-82.128,0-160.068,25.856-213.82,70.936c-27.416,22.992-33.28,62.18-15.524,91.972 L2.276,327.203c-1.128,0.54-1.936,1.572-2.192,2.792c-0.256,1.22,0.08,2.496,0.896,3.436l21.204,24.388 c0.764,0.88,1.868,1.376,3.02,1.376c0.084,0,0.172,0,0.26-0.008c1.244-0.084,2.384-0.74,3.072-1.776l14.852-22.376 c12.648,10.112,28.392,15.776,44.916,15.776c16.872,0,33.284-5.98,46.232-16.836c27.828-23.34,73.172-37.272,121.288-37.272 c48.12,0,93.464,13.932,121.296,37.272c12.944,10.856,29.36,16.836,46.228,16.836c16.596,0,32.4-5.724,45.08-15.916l14.94,22.512 c0.692,1.04,1.824,1.696,3.076,1.776c0.084,0.008,0.172,0.008,0.256,0.008c1.156,0,2.256-0.496,3.02-1.376l21.2-24.388C511.74,332.487,512.068,331.211,511.82,329.991z";
       * // ...
       * series.maskSprite.path = iconPath;
       * ```
       * ```JavaScript
       * let iconPath = "M511.82,329.991c-0.256-1.212-1.064-2.244-2.192-2.784l-24.396-11.684c17.688-29.776,11.804-68.912-15.58-91.88 c-53.756-45.084-131.696-70.936-213.828-70.936c-82.128,0-160.068,25.856-213.82,70.936c-27.416,22.992-33.28,62.18-15.524,91.972 L2.276,327.203c-1.128,0.54-1.936,1.572-2.192,2.792c-0.256,1.22,0.08,2.496,0.896,3.436l21.204,24.388 c0.764,0.88,1.868,1.376,3.02,1.376c0.084,0,0.172,0,0.26-0.008c1.244-0.084,2.384-0.74,3.072-1.776l14.852-22.376 c12.648,10.112,28.392,15.776,44.916,15.776c16.872,0,33.284-5.98,46.232-16.836c27.828-23.34,73.172-37.272,121.288-37.272 c48.12,0,93.464,13.932,121.296,37.272c12.944,10.856,29.36,16.836,46.228,16.836c16.596,0,32.4-5.724,45.08-15.916l14.94,22.512 c0.692,1.04,1.824,1.696,3.076,1.776c0.084,0.008,0.172,0.008,0.256,0.008c1.156,0,2.256-0.496,3.02-1.376l21.2-24.388C511.74,332.487,512.068,331.211,511.82,329.991z";
       * // ...
       * series.maskSprite.path = iconPath;
       * ```
       * ```JSON
       * let iconPath = "M511.82,329.991c-0.256-1.212-1.064-2.244-2.192-2.784l-24.396-11.684c17.688-29.776,11.804-68.912-15.58-91.88 c-53.756-45.084-131.696-70.936-213.828-70.936c-82.128,0-160.068,25.856-213.82,70.936c-27.416,22.992-33.28,62.18-15.524,91.972 L2.276,327.203c-1.128,0.54-1.936,1.572-2.192,2.792c-0.256,1.22,0.08,2.496,0.896,3.436l21.204,24.388 c0.764,0.88,1.868,1.376,3.02,1.376c0.084,0,0.172,0,0.26-0.008c1.244-0.084,2.384-0.74,3.072-1.776l14.852-22.376 c12.648,10.112,28.392,15.776,44.916,15.776c16.872,0,33.284-5.98,46.232-16.836c27.828-23.34,73.172-37.272,121.288-37.272 c48.12,0,93.464,13.932,121.296,37.272c12.944,10.856,29.36,16.836,46.228,16.836c16.596,0,32.4-5.724,45.08-15.916l14.94,22.512 c0.692,1.04,1.824,1.696,3.076,1.776c0.084,0.008,0.172,0.008,0.256,0.008c1.156,0,2.256-0.496,3.02-1.376l21.2-24.388C511.74,332.487,512.068,331.211,511.82,329.991z";
       * // ...
       * {
       *   // ...
       *   "series": [{
       *     "type": "PictorialStackedSeries",
       *     // ...
       *     "maskSprite": {
       *       "path": iconPath
       *     }
       *   }]
       * }
       * ```
       *
       * @return Mask sprite
       */
      get: function() {
        return this._maskSprite;
      },
      enumerable: true,
      configurable: true
    });
    PictorialStackedSeries2.prototype.initSlice = function(slice) {
      _super.prototype.initSlice.call(this, slice);
      var hs = slice.states.getKey("hover");
      if (hs) {
        hs.properties.expandDistance = 0;
      }
    };
    Object.defineProperty(PictorialStackedSeries2.prototype, "startLocation", {
      /**
       * @return  Start location
       */
      get: function() {
        return this.getPropertyValue("startLocation");
      },
      /**
       * Relative location to start series from.
       *
       * Range of values: 0 to 1.
       *
       * This setting indicates where actual slices will start relatively to the
       * whole height/width of the series.
       *
       * For example, if we want slices to start at 30% from the top/left of the
       * series, we can set `startLocation = 0.3`.
       *
       * To fill shape outside of the location range, use background of the
       * property `slicesContainer`.
       *
       * ```TypeScript
       * series.startLocation = 0.2;
       * series.endLocation = 0.8;
       * series.slicesContainer.background.fill = am4core.color("#eee");
       * ```
       * ```JavaScript
       * series.startLocation = 0.2;
       * series.endLocation = 0.8;
       * series.slicesContainer.background.fill = am4core.color("#eee");
       * ```
       * ```JSON
       * {
       *   // ...
       *   "series": [{
       *     // ...
       *     "startLocation": 0.2,
       *     "endLocation": 0.8,
       *     "slicesContainer": {
       *       "background": {
       *         "fill": "#eee"
       *       }
       *     }
       *   }]
       * }
       * ```
       *
       * @default 0
       * @since 4.1.13
       * @param  value  Start location
       */
      set: function(value) {
        if (this.setPropertyValue("startLocation", value)) {
          this.invalidateDataItems();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PictorialStackedSeries2.prototype, "endLocation", {
      /**
       * @return End location
       */
      get: function() {
        return this.getPropertyValue("endLocation");
      },
      /**
       * Relative location to end series at.
       *
       * Range of values: 0 to 1.
       *
       * This setting indicates where actual slices will end relatively to the
       * whole height/width of the series.
       *
       * For example, if we want slices to end at 70% from the top/left of the
       * series, we can set `endLocation = 0.7`.
       *
       * To fill shape outside of the location range, use background of the
       * property `slicesContainer`.
       *
       * ```TypeScript
       * series.startLocation = 0.2;
       * series.endLocation = 0.8;
       * series.slicesContainer.background.fill = am4core.color("#eee");
       * ```
       * ```JavaScript
       * series.startLocation = 0.2;
       * series.endLocation = 0.8;
       * series.slicesContainer.background.fill = am4core.color("#eee");
       * ```
       * ```JSON
       * {
       *   // ...
       *   "series": [{
       *     // ...
       *     "startLocation": 0.2,
       *     "endLocation": 0.8,
       *     "slicesContainer": {
       *       "background": {
       *         "fill": "#eee"
       *       }
       *     }
       *   }]
       * }
       * ```
       *
       * @default 1
       * @since 4.1.13
       * @param  value  End location
       */
      set: function(value) {
        if (this.setPropertyValue("endLocation", value)) {
          this.invalidateDataItems();
        }
      },
      enumerable: true,
      configurable: true
    });
    return PictorialStackedSeries2;
  }(PyramidSeries)
);
registry.registeredClasses["PictorialStackedSeries"] = PictorialStackedSeries;
registry.registeredClasses["PictorialStackedSeriesDataItem"] = PictorialStackedSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/ConeColumn.js
var ConeColumn = (
  /** @class */
  function(_super) {
    __extends(ConeColumn2, _super);
    function ConeColumn2() {
      var _this = _super.call(this) || this;
      _this.className = "ConeColumn";
      return _this;
    }
    ConeColumn2.prototype.createAssets = function() {
      this.coneColumn = this.createChild(Cone);
      this.coneColumn.shouldClone = false;
      this.column = this.coneColumn;
    };
    ConeColumn2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      if (this.coneColumn) {
        this.coneColumn.copyFrom(source.coneColumn);
      }
    };
    return ConeColumn2;
  }(Column)
);
registry.registeredClasses["ConeColumn"] = ConeColumn;

// node_modules/@amcharts/amcharts4/.internal/charts/series/ConeSeries.js
var ConeSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(ConeSeriesDataItem2, _super);
    function ConeSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "ConeSeriesDataItem";
      _this.applyTheme();
      return _this;
    }
    return ConeSeriesDataItem2;
  }(ColumnSeriesDataItem)
);
var ConeSeries = (
  /** @class */
  function(_super) {
    __extends(ConeSeries2, _super);
    function ConeSeries2() {
      var _this = _super.call(this) || this;
      _this.className = "ConeSeries";
      _this.applyTheme();
      return _this;
    }
    ConeSeries2.prototype.createColumnTemplate = function() {
      return new ConeColumn();
    };
    ConeSeries2.prototype.getMaskPath = function() {
      var dx = 0;
      var dy = 0;
      var column = this.columns.getIndex(0);
      if (column) {
        if (this.baseAxis == this.xAxis) {
          dy = column.coneColumn.innerWidth / 2 + 1;
        } else {
          dx = column.coneColumn.innerHeight / 2 + 1;
        }
        return rectToPath({
          x: -dx,
          y: 0,
          width: this.xAxis.axisLength + dx,
          height: this.yAxis.axisLength + dy
        });
      }
    };
    ConeSeries2.prototype.validateDataElementReal = function(dataItem) {
      _super.prototype.validateDataElementReal.call(this, dataItem);
      var column = dataItem.column;
      if (column) {
        var coneColumn = dataItem.column.coneColumn;
        coneColumn.fill = dataItem.column.fill;
        if (this.baseAxis == this.yAxis) {
          coneColumn.orientation = "horizontal";
        } else {
          coneColumn.orientation = "vertical";
        }
      }
    };
    return ConeSeries2;
  }(ColumnSeries)
);
registry.registeredClasses["ConeSeries"] = ConeSeries;
registry.registeredClasses["ConeSeriesDataItem"] = ConeSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/CurvedColumn.js
var CurvedColumn = (
  /** @class */
  function(_super) {
    __extends(CurvedColumn2, _super);
    function CurvedColumn2() {
      var _this = _super.call(this) || this;
      _this.className = "CurvedColumn";
      return _this;
    }
    CurvedColumn2.prototype.createAssets = function() {
      this.curvedColumn = this.createChild(Sprite);
      this.curvedColumn.shouldClone = false;
      this.setPropertyValue("tension", 0.7);
      this.width = percent(120);
      this.height = percent(120);
      this.column = this.curvedColumn;
    };
    CurvedColumn2.prototype.draw = function() {
      _super.prototype.draw.call(this);
      var w = this.realWidth;
      var h = this.realHeight;
      var x = this.realX - this.pixelX;
      var y = this.realY - this.pixelY;
      var points;
      used(this.width);
      var tensionX = 1;
      var tensionY = 1;
      if (this.orientation == "vertical") {
        tensionX = this.tension;
        points = [{ x: 0, y: h + y }, { x: w / 2, y }, { x: w, y: h + y }];
      } else {
        tensionY = this.tension;
        h = Math.abs(h);
        points = [{ x, y: h }, { x: x + w, y: h / 2 }, { x, y: 0 }];
      }
      var path = moveTo(points[0]) + new Tension(tensionX, tensionY).smooth(points);
      this.column.path = path;
    };
    CurvedColumn2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      if (this.curvedColumn) {
        this.curvedColumn.copyFrom(source.curvedColumn);
      }
    };
    Object.defineProperty(CurvedColumn2.prototype, "tension", {
      /**
       * @return Tension (0-1)
       */
      get: function() {
        return this.getPropertyValue("tension");
      },
      /**
       * Horizontal tension of the curve.
       *
       * Tension defines how "lose" the line will be.
       *
       * 1 is the maximum tension which would result in pointy columns with
       * straight edges.
       *
       * The smaller the tension th wider the column will be.
       *
       * @default 0.7
       * @param value tension (0-1)
       */
      set: function(value) {
        this.setPropertyValue("tension", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CurvedColumn2.prototype, "orientation", {
      /**
       * Orientation
       */
      get: function() {
        return this.getPropertyValue("orientation");
      },
      /**
       * Orientation of the column.
       *
       * Available options: "vertical" (default) and "horizontal".
       *
       * @default "vertical"
       * @param value  Orientation
       */
      set: function(value) {
        this.setPropertyValue("orientation", value, true);
      },
      enumerable: true,
      configurable: true
    });
    return CurvedColumn2;
  }(Column)
);
registry.registeredClasses["CurvedColumn"] = CurvedColumn;

// node_modules/@amcharts/amcharts4/.internal/charts/series/CurvedColumnSeries.js
var CurvedColumnSeriesDataItem = (
  /** @class */
  function(_super) {
    __extends(CurvedColumnSeriesDataItem2, _super);
    function CurvedColumnSeriesDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "CurvedColumnSeriesDataItem";
      _this.applyTheme();
      return _this;
    }
    return CurvedColumnSeriesDataItem2;
  }(ColumnSeriesDataItem)
);
var CurvedColumnSeries = (
  /** @class */
  function(_super) {
    __extends(CurvedColumnSeries2, _super);
    function CurvedColumnSeries2() {
      var _this = _super.call(this) || this;
      _this.className = "CurvedColumnSeries";
      _this.applyTheme();
      return _this;
    }
    CurvedColumnSeries2.prototype.createColumnTemplate = function() {
      return new CurvedColumn();
    };
    CurvedColumnSeries2.prototype.validateDataElementReal = function(dataItem) {
      _super.prototype.validateDataElementReal.call(this, dataItem);
      var column = dataItem.column;
      column = dataItem.column;
      if (column) {
        var curvedColumn = dataItem.column.curvedColumn;
        curvedColumn.fill = dataItem.column.fill;
        if (this.baseAxis == this.yAxis) {
          column.orientation = "horizontal";
        } else {
          column.orientation = "vertical";
        }
      }
    };
    return CurvedColumnSeries2;
  }(ColumnSeries)
);
registry.registeredClasses["CurvedColumnSeries"] = CurvedColumnSeries;
registry.registeredClasses["CurvedColumnSeriesDataItem"] = CurvedColumnSeriesDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/CircleBullet.js
var CircleBullet = (
  /** @class */
  function(_super) {
    __extends(CircleBullet2, _super);
    function CircleBullet2() {
      var _this = _super.call(this) || this;
      _this.className = "CircleBullet";
      var circle = _this.createChild(Circle);
      circle.shouldClone = false;
      circle.radius = 5;
      circle.isMeasured = false;
      _this.circle = circle;
      _this.applyTheme();
      return _this;
    }
    CircleBullet2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.circle.copyFrom(source.circle);
    };
    return CircleBullet2;
  }(Bullet)
);
registry.registeredClasses["CircleBullet"] = CircleBullet;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/ErrorBullet.js
var ErrorBullet = (
  /** @class */
  function(_super) {
    __extends(ErrorBullet2, _super);
    function ErrorBullet2() {
      var _this = _super.call(this) || this;
      _this.className = "ErrorBullet";
      _this.errorLine = _this.createChild(Sprite);
      _this.errorLine.shouldClone = false;
      _this.width = 20;
      _this.height = 20;
      _this.strokeOpacity = 1;
      _this.isDynamic = true;
      return _this;
    }
    ErrorBullet2.prototype.validatePosition = function() {
      _super.prototype.validatePosition.call(this);
      var w = this.pixelWidth / 2;
      var h = this.pixelHeight / 2;
      this.errorLine.path = moveTo({ x: -w, y: -h }) + lineTo({ x: w, y: -h }) + moveTo({ x: 0, y: -h }) + lineTo({ x: 0, y: h }) + moveTo({ x: -w, y: h }) + lineTo({ x: w, y: h });
    };
    ErrorBullet2.prototype.copyFrom = function(source) {
      _super.prototype.copyFrom.call(this, source);
      this.errorLine.copyFrom(source.errorLine);
    };
    return ErrorBullet2;
  }(Bullet)
);
registry.registeredClasses["ErrorBullet"] = ErrorBullet;

// node_modules/@amcharts/amcharts4/.internal/charts/elements/NavigationBar.js
var NavigationBarDataItem = (
  /** @class */
  function(_super) {
    __extends(NavigationBarDataItem2, _super);
    function NavigationBarDataItem2() {
      var _this = _super.call(this) || this;
      _this.className = "NavigationBarDataItem";
      _this.applyTheme();
      return _this;
    }
    Object.defineProperty(NavigationBarDataItem2.prototype, "name", {
      /**
       * @return Name
       */
      get: function() {
        return this.properties["name"];
      },
      /**
       * Name of the navigation bar item.
       *
       * @param value  Name
       */
      set: function(value) {
        this.setProperty("name", value);
      },
      enumerable: true,
      configurable: true
    });
    return NavigationBarDataItem2;
  }(DataItem)
);
var NavigationBar = (
  /** @class */
  function(_super) {
    __extends(NavigationBar2, _super);
    function NavigationBar2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "NavigationBar";
      var interfaceColors = new InterfaceColorSet();
      var textLink = new TextLink();
      textLink.valign = "middle";
      textLink.paddingTop = 8;
      textLink.paddingBottom = 8;
      _this.paddingBottom = 2;
      _this.links = new ListTemplate(textLink);
      _this._disposers.push(new ListDisposer(_this.links));
      _this._disposers.push(textLink);
      _this._linksIterator = new ListIterator(_this.links, function() {
        return _this.links.create();
      });
      _this._linksIterator.createNewItems = true;
      var triangle = new Triangle();
      triangle.direction = "right";
      triangle.width = 8;
      triangle.height = 12;
      triangle.fill = interfaceColors.getFor("alternativeBackground");
      triangle.fillOpacity = 0.5;
      triangle.valign = "middle";
      triangle.marginLeft = 10;
      triangle.marginRight = 10;
      _this.separators = new ListTemplate(triangle);
      _this._disposers.push(new ListDisposer(_this.separators));
      _this._disposers.push(triangle);
      var activeLink = new TextLink();
      _this.activeLink = activeLink;
      activeLink.copyFrom(textLink);
      activeLink.valign = "middle";
      activeLink.fontWeight = "bold";
      _this.width = percent(100);
      _this.layout = "grid";
      _this.dataFields.name = "name";
      _this.applyTheme();
      return _this;
    }
    NavigationBar2.prototype.validateDataElements = function() {
      this.removeChildren();
      this._linksIterator.reset();
      _super.prototype.validateDataElements.call(this);
    };
    NavigationBar2.prototype.validateDataElement = function(dataItem) {
      _super.prototype.validateDataElement.call(this, dataItem);
      var textLink;
      if (dataItem.index < this.dataItems.length - 1) {
        textLink = this._linksIterator.getLast();
        textLink.parent = this;
        var separator = this.separators.create();
        separator.parent = this;
        separator.valign = "middle";
      } else {
        textLink = this.activeLink;
        textLink.events.copyFrom(this.links.template.events);
        textLink.hide(0);
        textLink.show();
        textLink.parent = this;
      }
      textLink.dataItem = dataItem;
      textLink.text = dataItem.name;
      textLink.validate();
    };
    return NavigationBar2;
  }(Component)
);
registry.registeredClasses["NavigationBar"] = NavigationBar;
registry.registeredClasses["NavigationBarDataItem"] = NavigationBarDataItem;

// node_modules/@amcharts/amcharts4/.internal/charts/cursors/Cursor.js
var Cursor = (
  /** @class */
  function(_super) {
    __extends(Cursor2, _super);
    function Cursor2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.point = { x: 0, y: 0 };
      _this._stick = "none";
      _this.className = "Cursor";
      _this.width = percent(100);
      _this.height = percent(100);
      _this.shouldClone = false;
      _this.hide(0);
      _this.trackable = true;
      _this.clickable = true;
      _this.isMeasured = false;
      var interaction = getInteraction();
      _this._disposers.push(interaction.body.events.on("down", _this.handleCursorDown, _this));
      _this._disposers.push(interaction.body.events.on("up", _this.handleCursorUp, _this));
      _this._disposers.push(interaction.body.events.on("track", _this.handleCursorMove, _this));
      _this.applyTheme();
      return _this;
    }
    Cursor2.prototype.handleCursorMove = function(event) {
      if (!this.interactionsEnabled || this.interactions.isTouchProtected && event.touch) {
        return;
      }
      if ((this._generalBehavior != "zoom" && this._generalBehavior != "pan" || !this.downPoint) && !getInteraction().isLocalElement(event.pointer, this.paper.svg, this.uid)) {
        if (!this.isHidden || !this.isHiding) {
          this.hide();
        }
        return;
      }
      var local = documentPointToSprite(event.pointer.point, this);
      if (this._stick == "hard" && this._stickPoint) {
        local = this._stickPoint;
      }
      if (this._stick == "soft" && this._stickPoint) {
        if (!this.fitsToBounds(local)) {
          local = this._stickPoint;
        }
      }
      if (this._adapterO) {
        this._adapterO.apply("cursorPoint", local);
      }
      this.triggerMove(local);
      return local;
    };
    Cursor2.prototype.hideReal = function(duration) {
      if ((this._stick == "hard" || this._stick == "soft") && this._stickPoint) {
        return;
      }
      return _super.prototype.hideReal.call(this, duration);
    };
    Cursor2.prototype.triggerMove = function(point, stick, force) {
      point.x = round(point.x, 1);
      point.y = round(point.y, 1);
      if (stick) {
        this._stick = stick;
      }
      if (stick == "hard" || stick == "soft") {
        this._stickPoint = point;
      }
      this.triggerMoveReal(point, force);
    };
    Cursor2.prototype.triggerMoveReal = function(point, force) {
      if (this.point.x != point.x || this.point.y != point.y || force) {
        this.point = point;
        this.invalidatePosition();
        if (this.fitsToBounds(point)) {
          this.show(0);
        } else {
          if (!this.downPoint) {
            this.hide(0);
          }
        }
        if (this.visible) {
          this.getPositions();
          this.dispatch("cursorpositionchanged");
        }
      }
    };
    Cursor2.prototype.triggerDown = function(point) {
      this.triggerDownReal(point);
    };
    Cursor2.prototype.triggerDownReal = function(point) {
      switch (this._generalBehavior) {
        case "zoom":
          this.dispatchImmediately("zoomstarted");
          break;
        case "select":
          this.dispatchImmediately("selectstarted");
          break;
        case "pan":
          this.dispatchImmediately("panstarted");
          getInteraction().setGlobalStyle(MouseCursorStyle.grabbing);
          break;
      }
    };
    Cursor2.prototype.triggerUp = function(point) {
      this.triggerUpReal(point);
    };
    Cursor2.prototype.triggerUpReal = function(point) {
      system.requestFrame();
      this.updatePoint(this.upPoint);
      var interaction = getInteraction();
      if (getDistance(this._upPointOrig, this._downPointOrig) > interaction.getHitOption(this.interactions, "hitTolerance")) {
        switch (this._generalBehavior) {
          case "zoom":
            this.dispatch("zoomended");
            break;
          case "select":
            this.dispatch("selectended");
            break;
          case "pan":
            this.dispatch("panended");
            interaction.setGlobalStyle(MouseCursorStyle.default);
            break;
        }
        this.downPoint = void 0;
        this.updateSelection();
      }
    };
    Cursor2.prototype.updateSelection = function() {
    };
    Cursor2.prototype.getPositions = function() {
      this.xPosition = this.point.x / this.innerWidth;
      this.yPosition = 1 - this.point.y / this.innerHeight;
    };
    Cursor2.prototype.handleCursorDown = function(event) {
      if (!this.interactionsEnabled || this.interactions.isTouchProtected && event.touch || !getInteraction().isLocalElement(event.pointer, this.paper.svg, this.uid)) {
        return;
      }
      blur();
      var local = documentPointToSprite(event.pointer.point, this);
      if (this._stick == "hard" && this._stickPoint) {
        local = this._stickPoint;
      }
      if (this._adapterO) {
        this._adapterO.apply("cursorPoint", local);
      }
      if (!this.fitsToBounds(local)) {
        return;
      }
      this._downPointOrig = { x: local.x, y: local.y };
      if (event.event.cancelable && this.shouldPreventGestures(event.touch) && this.fitsToBounds(local)) {
        event.event.preventDefault();
      }
      this.triggerMove(local);
      this.triggerDown(local);
    };
    Cursor2.prototype.shouldPreventGestures = function(touch) {
      return true;
    };
    Cursor2.prototype.updatePoint = function(point) {
    };
    Cursor2.prototype.handleCursorUp = function(event) {
      if (!this.interactionsEnabled) {
        return;
      }
      if (!this.downPoint && !getInteraction().isLocalElement(event.pointer, this.paper.svg, this.uid)) {
        return;
      }
      var local = documentPointToSprite(event.pointer.point, this);
      if (this._adapterO) {
        this._adapterO.apply("cursorPoint", local);
      }
      if (!this.downPoint || !this.fitsToBounds(this.downPoint)) {
        return;
      }
      if (this._stick == "hard" && this._stickPoint) {
        local = this._stickPoint;
      }
      this._upPointOrig = { x: local.x, y: local.y };
      this.triggerMove(local);
      this.triggerUp(local);
    };
    Object.defineProperty(Cursor2.prototype, "chart", {
      /**
       * @return Chart
       */
      get: function() {
        return this._chart;
      },
      /**
       * A reference to a [[Chart]] the cursor belongs to.
       *
       * @param value  Chart
       */
      set: function(value) {
        this._chart = value;
        if (hasValue(this._chart.plotContainer)) {
          getInteraction().lockElement(this._chart.plotContainer.interactions);
        }
      },
      enumerable: true,
      configurable: true
    });
    return Cursor2;
  }(Container)
);
registry.registeredClasses["Cursor"] = Cursor;

// node_modules/@amcharts/amcharts4/.internal/charts/cursors/XYCursor.js
var XYCursor = (
  /** @class */
  function(_super) {
    __extends(XYCursor2, _super);
    function XYCursor2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this._lineX = new MutableValueDisposer();
      _this._lineY = new MutableValueDisposer();
      _this._xAxis = new MutableValueDisposer();
      _this._yAxis = new MutableValueDisposer();
      _this._snapToDisposers = [];
      _this.className = "XYCursor";
      _this.behavior = "zoomX";
      _this.maxPanOut = 0.1;
      var interfaceColors = new InterfaceColorSet();
      _this.snapOnPan = true;
      var selection = _this.createChild(Sprite);
      selection.shouldClone = false;
      selection.fillOpacity = 0.2;
      selection.fill = interfaceColors.getFor("alternativeBackground");
      selection.isMeasured = false;
      selection.visible = false;
      selection.interactionsEnabled = false;
      _this.selection = selection;
      _this._disposers.push(_this.selection);
      var lineX = _this.createChild(Sprite);
      lineX.shouldClone = false;
      lineX.stroke = interfaceColors.getFor("grid");
      lineX.fill = color();
      lineX.strokeDasharray = "3,3";
      lineX.isMeasured = false;
      lineX.strokeOpacity = 0.4;
      lineX.interactionsEnabled = false;
      lineX.y = 0;
      _this.lineX = lineX;
      _this._disposers.push(_this.lineX);
      var lineY = _this.createChild(Sprite);
      lineY.shouldClone = false;
      lineY.stroke = interfaceColors.getFor("grid");
      lineY.fill = color();
      lineY.strokeDasharray = "3,3";
      lineY.isMeasured = false;
      lineY.strokeOpacity = 0.4;
      lineY.interactionsEnabled = false;
      lineY.x = 0;
      _this.lineY = lineY;
      _this._disposers.push(_this.lineY);
      _this.events.on("sizechanged", _this.updateSize, _this, false);
      _this._disposers.push(_this._lineX);
      _this._disposers.push(_this._lineY);
      _this._disposers.push(_this._xAxis);
      _this._disposers.push(_this._yAxis);
      _this.mask = _this;
      _this.hideSeriesTooltipsOnSelection = true;
      _this.applyTheme();
      return _this;
    }
    XYCursor2.prototype.updateSize = function() {
      if (this.lineX) {
        this.lineX.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: 0, y: this.innerHeight });
      }
      if (this.lineY) {
        this.lineY.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: this.innerWidth, y: 0 });
      }
    };
    XYCursor2.prototype.updateSelection = function() {
      if (this._usesSelection) {
        var downPoint = this.downPoint;
        var behavior = this.behavior;
        if (downPoint) {
          var point = this.point;
          if (this.lineX) {
            point.x = this.lineX.pixelX;
          }
          if (this.lineY) {
            point.y = this.lineY.pixelY;
          }
          var selection = this.selection;
          var x = Math.min(point.x, downPoint.x);
          var y = Math.min(point.y, downPoint.y);
          var w = round(Math.abs(downPoint.x - point.x), this._positionPrecision);
          var h = round(Math.abs(downPoint.y - point.y), this._positionPrecision);
          switch (behavior) {
            case "zoomX":
              y = 0;
              h = this.pixelHeight;
              break;
            case "zoomY":
              x = 0;
              w = this.pixelWidth;
              break;
            case "selectX":
              y = 0;
              h = this.pixelHeight;
              break;
            case "selectY":
              x = 0;
              w = this.pixelWidth;
              break;
          }
          selection.x = x;
          selection.y = y;
          selection.path = rectangle(w, h);
          selection.validatePosition();
        } else {
          if (this._generalBehavior != "select") {
            this.selection.hide();
          }
        }
      }
    };
    XYCursor2.prototype.fixPoint = function(point) {
      point.x = Math.max(0, point.x);
      point.y = Math.max(0, point.y);
      point.x = Math.min(this.pixelWidth, point.x);
      point.y = Math.min(this.pixelHeight, point.y);
      return point;
    };
    XYCursor2.prototype.triggerMoveReal = function(point, force) {
      _super.prototype.triggerMoveReal.call(this, point, force);
      var snapToSeries = this.snapToSeries;
      if (snapToSeries && !this.downPoint) {
        if (snapToSeries instanceof XYSeries) {
          if (snapToSeries.isHidden) {
            this.updateLinePositions(point);
          }
        } else {
          var allHidden_1 = true;
          each(snapToSeries, function(s) {
            if (!s.isHidden) {
              allHidden_1 = false;
            }
          });
          if (allHidden_1) {
            this.updateLinePositions(point);
          }
        }
      } else {
        this.updateLinePositions(point);
      }
      if (this.downPoint && getDistance(this.downPoint, point) > 3) {
        if (this._generalBehavior == "pan") {
          this.getPanningRanges();
          this.dispatch("panning");
        }
      }
    };
    XYCursor2.prototype.updateLinePositions = function(point) {
      point = this.fixPoint(this.point);
      if (this.lineX && this.lineX.visible && !this.xAxis) {
        this.lineX.x = point.x;
      }
      if (this.lineY && this.lineY.visible && !this.yAxis) {
        this.lineY.y = point.y;
      }
      this.updateSelection();
    };
    XYCursor2.prototype.triggerDownReal = function(point) {
      if (this.visible && !this.isHiding) {
        if (this._generalBehavior == "select") {
          this.selection.parent = this.parent;
        }
        if (this.fitsToBounds(point)) {
          this.downPoint = { x: point.x, y: point.y };
          this.updatePoint(point);
          this.point.x = this.downPoint.x;
          this.point.y = this.downPoint.y;
          var selection = this.selection;
          var selectionX = this.downPoint.x;
          var selectionY = this.downPoint.y;
          if (this._usesSelection) {
            selection.x = selectionX;
            selection.y = selectionY;
            selection.path = "";
            selection.show();
          }
          _super.prototype.triggerDownReal.call(this, point);
        } else {
          this.downPoint = void 0;
        }
      } else {
        this.downPoint = void 0;
      }
    };
    XYCursor2.prototype.updatePoint = function(point) {
      if (this.lineX) {
        point.x = this.lineX.pixelX;
      }
      if (this.lineY) {
        point.y = this.lineY.pixelY;
      }
    };
    XYCursor2.prototype.triggerUpReal = function(point) {
      if (this.hasMoved()) {
        if (this.downPoint) {
          this.upPoint = point;
          this.updatePoint(this.upPoint);
          if (this._generalBehavior != "pan") {
            this.getRanges();
          }
          if (this._generalBehavior != "select") {
            this.selection.hide();
          }
          _super.prototype.triggerUpReal.call(this, point);
        }
      } else {
        if (this._generalBehavior != "select") {
          this.selection.hide(0);
        } else {
          this.xRange = void 0;
          this.yRange = void 0;
          this.dispatchImmediately("selectended");
        }
        if (this._generalBehavior == "pan") {
          var interaction = getInteraction();
          interaction.setGlobalStyle(MouseCursorStyle.default);
        }
        this.dispatchImmediately("behaviorcanceled");
      }
      this.downPoint = void 0;
      this.dispatch("cursorpositionchanged");
    };
    XYCursor2.prototype.hasMoved = function() {
      var distance;
      if (this.behavior == "zoomX" || this.behavior == "panX") {
        distance = getHorizontalDistance(this._upPointOrig, this._downPointOrig);
      } else if (this.behavior == "zoomY" || this.behavior == "panY") {
        distance = getVerticalDistance(this._upPointOrig, this._downPointOrig);
      } else {
        distance = getDistance(this._upPointOrig, this._downPointOrig);
      }
      return distance > getInteraction().getHitOption(this.interactions, "hitTolerance");
    };
    XYCursor2.prototype.getPanningRanges = function() {
      var startX = round(this.downPoint.x / this.innerWidth, 5);
      var startY = 1 - round(this.downPoint.y / this.innerHeight, 5);
      var currentX = round(this.point.x / this.innerWidth, 5);
      var currentY = 1 - round(this.point.y / this.innerHeight, 5);
      var deltaX = startX - currentX;
      var deltaY = startY - currentY;
      this.xRange = { start: deltaX, end: 1 + deltaX };
      this.yRange = { start: deltaY, end: 1 + deltaY };
      if (this.behavior == "panX") {
        this.yRange.start = 0;
        this.yRange.end = 1;
      }
      if (this.behavior == "panY") {
        this.xRange.start = 0;
        this.xRange.end = 1;
      }
    };
    XYCursor2.prototype.getRanges = function() {
      if (this.lineX) {
        this.upPoint.x = this.lineX.pixelX;
      }
      if (this.lineY) {
        this.upPoint.y = this.lineY.pixelY;
      }
      used(this.selection);
      var startX = round(this.downPoint.x / this.innerWidth, 5);
      var endX = round(this.upPoint.x / this.innerWidth, 5);
      var startY = 1 - round(this.downPoint.y / this.innerHeight, 5);
      var endY = 1 - round(this.upPoint.y / this.innerHeight, 5);
      this.xRange = { start: min(startX, endX), end: max(startX, endX) };
      this.yRange = { start: min(startY, endY), end: max(startY, endY) };
    };
    Object.defineProperty(XYCursor2.prototype, "behavior", {
      /**
       * Behavior
       */
      get: function() {
        return this.getPropertyValue("behavior");
      },
      /**
       * Cursor's behavior when it's moved with pointer down:
       *
       * * `"zoomX"` - zooms horizontally.
       * * `"zoomY"` - zooms vertically.
       * * `"zoomXY"` - zooms both horizontally and vertically.
       * * `"selectX"` - selects a range horizontally.
       * * `"selectY"` - selects a range vertically.
       * * `"selectXY"` - selects a range both horizontally and vertically.
       * * `"panX"` - moves (pans) current selection horizontally.
       * * `"panY"` - moves (pans) current selection vertically.
       * * `"panXY"` - moves (pans) current selection both horizontally and vertically.
       * * `"none"` - does nothing with pointer down.
       *
       * E.g. "zoomXY" will mean that pressing a mouse (or touching) over plot area
       * and dragging it will start zooming the chart.
       *
       * NOTE: `"zoomXY"` acts differently when used on a `DateAxis`.
       * See [this note](https://www.amcharts.com/docs/v4/concepts/chart-cursor/#zoomXY_behavior_and_DateAxis).
       *
       * @param value Bheavior
       */
      set: function(value) {
        this.setPropertyValue("behavior", value, true);
        this._usesSelection = false;
        if (value.indexOf("zoom") != -1) {
          this._generalBehavior = "zoom";
          this._usesSelection = true;
        }
        if (value.indexOf("select") != -1) {
          this._generalBehavior = "select";
          this._usesSelection = true;
        }
        if (value.indexOf("pan") != -1) {
          this._generalBehavior = "pan";
          this._usesSelection = false;
        }
      },
      enumerable: true,
      configurable: true
    });
    XYCursor2.prototype.shouldPreventGestures = function(touch) {
      return (!this.interactions.isTouchProtected || !touch) && this.behavior != "none";
    };
    Object.defineProperty(XYCursor2.prototype, "fullWidthLineX", {
      /**
       * @return Full width?
       */
      get: function() {
        return this.getPropertyValue("fullWidthLineX");
      },
      /**
       * Cursor's horizontal line is expanded to take full width of the related
       * Axis' cell/category.
       *
       * NOTE: this setting will work properly if `xAxis` is set and only in case
       * `xAxis` is [[CategoryAxis]] or [[DateAxis]].
       *
       * @param value Full width?
       */
      set: function(value) {
        this.setPropertyValue("fullWidthLineX", value);
        if (!value) {
          this.updateSize();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYCursor2.prototype, "fullWidthLineY", {
      /**
       * @return Full width?
       */
      get: function() {
        return this.getPropertyValue("fullWidthLineY");
      },
      /**
       * Cursor's vertical line is expanded to take full width of the related
       * Axis' cell/category.
       *
       * NOTE: this setting will work properly if `yAxis` is set and only in case
       * `yAxis` is [[CategoryAxis]] or [[DateAxis]].
       *
       * @param value Full width?
       */
      set: function(value) {
        this.setPropertyValue("fullWidthLineY", value);
        if (!value) {
          this.updateSize();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYCursor2.prototype, "hideSeriesTooltipsOnSelection", {
      /**
       * @return hide tooltip?
       */
      get: function() {
        return this.getPropertyValue("hideSeriesTooltipsOnSelection");
      },
      /**
       * If set to `true` this will hide series tooltips when selecting with cursor.
       *
       * @since 4.5.15
       * @param  value  hide tooltips?
       */
      set: function(value) {
        this.setPropertyValue("hideSeriesTooltipsOnSelection", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYCursor2.prototype, "maxTooltipDistance", {
      /**
       * @return Distance
       */
      get: function() {
        return this.getPropertyValue("maxTooltipDistance");
      },
      /**
       * If set to a numeric value, cursor will display closest series' tooltips
       * plus tooltips from series that are closer to than `maxTooltipDistance` to
       * it.
       *
       * Set it to `-1` to always force one tooltip, even if there are multiple
       * data items in exactly same place.
       *
       * @since 4.7.18
       * @param  value  Distance
       */
      set: function(value) {
        this.setPropertyValue("maxTooltipDistance", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYCursor2.prototype, "maxPanOut", {
      /**
       * @return Full width?
       */
      get: function() {
        return this.getPropertyValue("maxPanOut");
      },
      /**
       * If cursor behavior is panX or panY, we allow to pan plot out of it's max bounds for a better user experience.
       * This setting specifies relative value by how much we can pan out the plot
       *
       * @param value
       */
      set: function(value) {
        this.setPropertyValue("maxPanOut", value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYCursor2.prototype, "xAxis", {
      /**
       * @return X axis
       */
      get: function() {
        return this._xAxis.get();
      },
      /**
       * A reference to X [[Axis]].
       *
       * An XY cursor can live without `xAxis` set. You set xAxis for cursor when
       * you have axis tooltip enabled and you want cursor line to be at the same
       * position as tooltip.
       *
       * This works with [[CategoryAxis]] and [[DateAxis]] but not with
       * [[ValueAxis]].
       *
       * @todo Description (review)
       * @param axis X axis
       */
      set: function(axis) {
        var _this = this;
        if (this._xAxis.get() != axis) {
          this._xAxis.set(axis, new MultiDisposer([
            axis.tooltip.events.on("positionchanged", this.handleXTooltipPosition, this, false),
            axis.events.on("rangechangestarted", function(event) {
              _this.hide(0);
              _this.preventShow = true;
            }, void 0, false),
            axis.events.on("rangechangeended", function(event) {
              _this.preventShow = false;
              _this.hide(0);
              _this.dispatch("cursorpositionchanged");
            }, void 0, false)
          ]));
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYCursor2.prototype, "yAxis", {
      /**
       * @return Y Axis
       */
      get: function() {
        return this._yAxis.get();
      },
      /**
       * A reference to Y [[Axis]].
       *
       * An XY cursor can live without `yAxis` set. You set xAxis for cursor when
       * you have axis tooltip enabled and you want cursor line to be at the same
       * position as tooltip.
       *
       * This works with [[CategoryAxis]] and [[DateAxis]] but not with
       * [[ValueAxis]].
       *
       * @todo Description (review)
       * @param axis Y axis
       */
      set: function(axis) {
        var _this = this;
        if (this._yAxis.get() != axis) {
          this._yAxis.set(axis, new MultiDisposer([
            axis.tooltip.events.on("positionchanged", this.handleYTooltipPosition, this, false),
            axis.events.on("rangechangestarted", function(event) {
              _this.hide(0);
              _this.__disabled = true;
            }, void 0, false),
            axis.events.on("rangechangeended", function(event) {
              _this.__disabled = false;
              _this.hide(0);
              _this.dispatch("cursorpositionchanged");
            }, void 0, false)
          ]));
        }
      },
      enumerable: true,
      configurable: true
    });
    XYCursor2.prototype.handleXTooltipPosition = function(event) {
      var tooltip = this.xAxis.tooltip;
      var point = svgPointToSprite({ x: tooltip.pixelX, y: tooltip.pixelY }, this);
      var x = point.x;
      point.y = 1;
      if (this.lineX) {
        this.lineX.x = x;
        if (!this.fitsToBounds(point)) {
          this.hide();
        }
      }
      if (this.xAxis && this.fullWidthLineX) {
        var startPoint = this.xAxis.currentItemStartPoint;
        var endPoint = this.xAxis.currentItemEndPoint;
        if (startPoint && endPoint) {
          this.lineX.x = x;
          var width = endPoint.x - startPoint.x;
          this.lineX.path = rectangle(width, this.innerHeight, -width / 2);
        }
      }
    };
    XYCursor2.prototype.handleYTooltipPosition = function(event) {
      var tooltip = this.yAxis.tooltip;
      var point = svgPointToSprite({ x: tooltip.pixelX, y: tooltip.pixelY }, this);
      var y = point.y;
      point.x = 1;
      if (this.lineY) {
        this.lineY.y = y;
        if (!this.fitsToBounds(point)) {
          this.hide();
        }
      }
      if (this.yAxis && this.fullWidthLineY) {
        var startPoint = this.yAxis.currentItemStartPoint;
        var endPoint = this.yAxis.currentItemEndPoint;
        if (startPoint && endPoint) {
          this.lineY.y = y;
          var height = endPoint.y - startPoint.y;
          this.lineY.path = rectangle(this.innerWidth, height, 0, -height / 2);
        }
      }
    };
    Object.defineProperty(XYCursor2.prototype, "lineX", {
      /**
       * @return Line element
       */
      get: function() {
        return this._lineX.get();
      },
      /**
       * A Line element to use for X axis.
       *
       * @param lineX Line
       */
      set: function(lineX) {
        if (lineX) {
          lineX.setElement(this.paper.add("path"));
          this._lineX.set(lineX, lineX.events.on("positionchanged", this.updateSelection, this, false));
          lineX.interactionsEnabled = false;
          lineX.parent = this;
        } else {
          this._lineX.reset();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYCursor2.prototype, "lineY", {
      /**
       * @return Line element
       */
      get: function() {
        return this._lineY.get();
      },
      /**
       * A Line element to use Y axis.
       *
       * @param lineY Line
       */
      set: function(lineY) {
        if (lineY) {
          lineY.setElement(this.paper.add("path"));
          this._lineY.set(lineY, lineY.events.on("positionchanged", this.updateSelection, this, false));
          lineY.parent = this;
          lineY.interactionsEnabled = false;
        } else {
          this._lineY.reset();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYCursor2.prototype, "selection", {
      /**
       * @return Selection rectangle
       */
      get: function() {
        return this._selection;
      },
      /**
       * A selection element ([[Sprite]]).
       *
       * @param selection Selection rectangle
       */
      set: function(selection) {
        this._selection = selection;
        if (selection) {
          selection.element = this.paper.add("path");
          selection.parent = this;
        }
      },
      enumerable: true,
      configurable: true
    });
    XYCursor2.prototype.processConfig = function(config) {
      var _this = this;
      if (config) {
        if (hasValue(config.xAxis) && isString(config.xAxis)) {
          if (this.map.hasKey(config.xAxis)) {
            config.xAxis = this.map.getKey(config.xAxis);
          } else {
            this.processingErrors.push('[XYCursor] No axis with id "' + config.xAxis + '" found for `xAxis`');
            delete config.xAxis;
          }
        }
        if (hasValue(config.yAxis) && isString(config.yAxis)) {
          if (this.map.hasKey(config.yAxis)) {
            config.yAxis = this.map.getKey(config.yAxis);
          } else {
            this.processingErrors.push('[XYCursor] No axis with id "' + config.yAxis + '" found for `yAxis`');
            delete config.yAxis;
          }
        }
        if (hasValue(config.snapToSeries)) {
          var snapTo_1 = isArray(config.snapToSeries) ? config.snapToSeries : [config.snapToSeries];
          var snapError_1 = false;
          each(snapTo_1, function(snap, index) {
            if (isString(snap)) {
              if (_this.map.hasKey(snap)) {
                snapTo_1[index] = _this.map.getKey(snap);
              } else {
                _this.processingErrors.push('[XYCursor] No series with id "' + snap + '" found for `series`');
                snapError_1 = true;
              }
            }
          });
          if (snapError_1) {
            delete config.snapToSeries;
          } else {
            config.snapToSeries = snapTo_1;
          }
        }
      }
      _super.prototype.processConfig.call(this, config);
    };
    Object.defineProperty(XYCursor2.prototype, "snapToSeries", {
      /**
       * @return {XYSeries | XYSeries[]}
       */
      get: function() {
        return this.getPropertyValue("snapToSeries");
      },
      /**
       * Specifies to which series cursor lines should be snapped.
       *
       * Can be a single series instance or an array of series.
       *
       * @param {XYSeries | XYSeries[]}
       */
      set: function(series) {
        var _this = this;
        if (this.setPropertyValue("snapToSeries", series)) {
          if (series instanceof XYSeries) {
            series = [series];
          }
          if (this._snapToDisposers) {
            each(this._snapToDisposers, function(disposer) {
              disposer.dispose();
            });
          }
          this._snapToDisposers = [];
          if (series) {
            each(series, function(s) {
              _this._snapToDisposers.push(s.events.on("tooltipshownat", function() {
                _this.handleSnap(s);
              }, void 0, false));
            });
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(XYCursor2.prototype, "snapOnPan", {
      /**
       * Should zoom selection "snap" into equal categories/intervals after panning
       * the chart? (when `behavior == "panX"`)
       *
       * @default true
       * @since 4.10.17
       * @return Snap on pan?
       */
      get: function() {
        return this.getPropertyValue("snapOnPan");
      },
      /**
       * @param value Snap on pan?
       */
      set: function(value) {
        this.setPropertyValue("snapOnPan", value);
      },
      enumerable: true,
      configurable: true
    });
    XYCursor2.prototype.handleSnap = function(series) {
      if (!this.downPoint) {
        var x = series.getTooltipX() + series.xAxis.pixelX;
        var y = series.getTooltipY() + series.yAxis.pixelY;
        var xAxis = series.xAxis;
        var yAxis = series.yAxis;
        if (xAxis) {
          if (xAxis.renderer.opposite) {
            y -= this.pixelHeight;
          }
        }
        this.point = { x, y };
        this.getPositions();
        var xx = x;
        var yy = y;
        x -= this.pixelWidth;
        if (yAxis) {
          if (yAxis.renderer.opposite) {
            x += this.pixelWidth;
          }
        }
        var tooltip = series.tooltip;
        var duration = tooltip.animationDuration;
        var easing = tooltip.animationEasing;
        if (xAxis instanceof ValueAxis && !(xAxis instanceof DateAxis) && yAxis instanceof ValueAxis && !(yAxis instanceof DateAxis)) {
          series.yAxis.showTooltipAtPosition(this.yPosition);
          series.xAxis.showTooltipAtPosition(this.xPosition);
        } else {
          if (series.baseAxis == series.xAxis) {
            series.yAxis.showTooltipAtPosition(this.yPosition);
          }
          if (series.baseAxis == series.yAxis) {
            series.xAxis.showTooltipAtPosition(this.xPosition);
          }
        }
        this.lineY.x = x;
        this.lineX.y = y;
        if (!this.xAxis) {
          this.lineX.animate([{ property: "x", to: xx }], duration, easing);
        }
        if (!this.yAxis) {
          this.lineY.animate([{ property: "y", to: yy }], duration, easing);
        }
      }
    };
    XYCursor2.prototype.dispose = function() {
      this.hide(0);
      _super.prototype.dispose.call(this);
    };
    return XYCursor2;
  }(Cursor)
);
registry.registeredClasses["XYCursor"] = XYCursor;

// node_modules/@amcharts/amcharts4/.internal/charts/cursors/RadarCursor.js
var RadarCursor = (
  /** @class */
  function(_super) {
    __extends(RadarCursor2, _super);
    function RadarCursor2() {
      var _this = (
        // Init
        _super.call(this) || this
      );
      _this.className = "RadarCursor";
      _this.radius = percent(100);
      _this.innerRadius = percent(0);
      _this.applyTheme();
      _this.mask = void 0;
      return _this;
    }
    RadarCursor2.prototype.fitsToBounds = function(point) {
      var radius = getDistance(point);
      if (radius < this.truePixelRadius + 1 && radius > this.pixelInnerRadius - 1) {
        return true;
      }
      return false;
    };
    Object.defineProperty(RadarCursor2.prototype, "startAngle", {
      /**
       * @return Start angle
       */
      get: function() {
        return this.getPropertyValue("startAngle");
      },
      /**
       * Starting angle of the cursor's radial line.
       *
       * @param value Start angle
       */
      set: function(value) {
        this.setPropertyValue("startAngle", value, true);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RadarCursor2.prototype, "endAngle", {
      /**
       * @return End angle
       */
      get: function() {
        return this.getPropertyValue("endAngle");
      },
      /**
       * End angle of the cursor's radial line.
       *
       * @param value End angle
       */
      set: function(value) {
        this.setPropertyValue("endAngle", value, true);
      },
      enumerable: true,
      configurable: true
    });
    RadarCursor2.prototype.triggerMoveReal = function(point, force) {
      if (!this.xAxis || this.xAxis && (!this.xAxis.cursorTooltipEnabled || this.xAxis.tooltip.disabled)) {
        this.updateLineX(this.point);
      }
      if (!this.yAxis || this.yAxis && (!this.yAxis.cursorTooltipEnabled || this.yAxis.tooltip.disabled)) {
        this.updateLineY(this.point);
      }
      this.updateSelection();
      _super.prototype.triggerMoveReal.call(this, point, force);
    };
    RadarCursor2.prototype.updateLineX = function(point) {
      var radius = this.pixelRadius;
      var startAngle = this.startAngle;
      var endAngle = this.endAngle;
      var innerRadius = this.pixelInnerRadius;
      if (radius > 0 && isNumber(startAngle) && isNumber(endAngle) && isNumber(innerRadius)) {
        var angle = fitAngleToRange(getAngle(point), startAngle, endAngle);
        var path = void 0;
        if (this.lineX && this.lineX.visible) {
          this.lineX.moveTo({ x: 0, y: 0 });
          if (this.xAxis && this.fullWidthLineX) {
            var startPoint = this.xAxis.currentItemStartPoint;
            var endPoint = this.xAxis.currentItemEndPoint;
            if (startPoint && endPoint) {
              var fillStartAngle = fitAngleToRange(getAngle(startPoint), startAngle, endAngle);
              var fillEndAngle = fitAngleToRange(getAngle(endPoint), startAngle, endAngle);
              var arc2 = fillEndAngle - fillStartAngle;
              if (startAngle < endAngle) {
                if (arc2 < 0) {
                  arc2 += 360;
                }
              } else {
                if (arc2 > 0) {
                  arc2 -= 360;
                }
              }
              angle -= arc2 / 2;
              path = moveTo({ x: innerRadius * cos(angle), y: innerRadius * sin(angle) }) + lineTo({ x: radius * cos(angle), y: radius * sin(angle) }) + arcTo(angle, arc2, radius) + lineTo({ x: innerRadius * cos(angle + arc2), y: innerRadius * sin(angle + arc2) }) + arcTo(angle + arc2, -arc2, innerRadius);
            }
          }
          if (!path) {
            path = moveTo({ x: innerRadius * cos(angle), y: innerRadius * sin(angle) }) + lineTo({ x: radius * cos(angle), y: radius * sin(angle) });
          }
          this.lineX.path = path;
        }
      }
    };
    RadarCursor2.prototype.updateLineY = function(point) {
      if (this.lineY && this.lineY.visible) {
        var startAngle = this.startAngle;
        var endAngle = this.endAngle;
        var truePixelRadius = this.truePixelRadius;
        var radius = fitToRange(getDistance(point), 0, this.truePixelRadius);
        if (isNumber(radius) && isNumber(startAngle)) {
          this.lineY.moveTo({ x: 0, y: 0 });
          var path = void 0;
          var arc2 = endAngle - startAngle;
          if (this.yAxis && this.fullWidthLineY) {
            var startPoint = this.yAxis.currentItemStartPoint;
            var endPoint = this.yAxis.currentItemEndPoint;
            if (startPoint && endPoint) {
              var innerRadius = fitToRange(getDistance(startPoint), 0, truePixelRadius);
              radius = fitToRange(getDistance(endPoint), 0, truePixelRadius);
              path = moveTo({ x: radius * cos(startAngle), y: radius * sin(startAngle) }) + arcTo(startAngle, arc2, radius);
              path += moveTo({ x: innerRadius * cos(endAngle), y: innerRadius * sin(endAngle) }) + arcTo(endAngle, -arc2, innerRadius);
            }
          }
          if (!path) {
            path = moveTo({ x: radius * cos(startAngle), y: radius * sin(startAngle) }) + arcTo(startAngle, endAngle - startAngle, radius);
          }
          this.lineY.path = path;
        }
      }
    };
    RadarCursor2.prototype.updateSelection = function() {
      if (this._usesSelection) {
        var downPoint = this.downPoint;
        if (downPoint) {
          var point = this.point;
          var radius = this.pixelRadius;
          var truePixelRadius = this.truePixelRadius;
          var innerRadius = this.pixelInnerRadius;
          var startAngle = Math.min(this.startAngle, this.endAngle);
          var endAngle = Math.max(this.startAngle, this.endAngle);
          var downAngle = fitAngleToRange(getAngle(downPoint), startAngle, endAngle);
          var angle = fitAngleToRange(getAngle(point), startAngle, endAngle);
          var downRadius = getDistance(downPoint);
          if (downRadius < truePixelRadius) {
            var currentRadius = fitToRange(getDistance(point), 0, truePixelRadius);
            this._prevAngle = angle;
            var path = moveTo({ x: 0, y: 0 });
            var downSin = sin(downAngle);
            var downCos = cos(downAngle);
            var sin2 = sin(angle);
            var cos2 = cos(angle);
            var behavior = this.behavior;
            if (behavior == "zoomX" || behavior == "selectX") {
              path += lineTo({ x: radius * downCos, y: radius * downSin }) + arcTo(downAngle, angle - downAngle, radius) + lineTo({ x: innerRadius * cos2, y: innerRadius * sin2 }) + arcTo(angle, downAngle - angle, innerRadius);
            } else if (behavior == "zoomY" || behavior == "selectY") {
              path = moveTo({ x: currentRadius * cos(startAngle), y: currentRadius * sin(startAngle) }) + arcTo(startAngle, endAngle - startAngle, currentRadius) + lineTo({ x: downRadius * cos(endAngle), y: downRadius * sin(endAngle) }) + arcTo(endAngle, startAngle - endAngle, downRadius) + closePath();
            } else if (behavior == "zoomXY") {
              path = moveTo({ x: currentRadius * cos(downAngle), y: currentRadius * sin(downAngle) }) + arcTo(downAngle, angle - downAngle, currentRadius) + lineTo({ x: downRadius * cos(angle), y: downRadius * sin(angle) }) + arcTo(angle, downAngle - angle, downRadius) + closePath();
            }
            this.selection.path = path;
          }
          this.selection.moveTo({ x: 0, y: 0 });
        }
      }
    };
    RadarCursor2.prototype.getPositions = function() {
      var chart = this.chart;
      if (chart) {
        var innerRadius = this.pixelInnerRadius;
        var radius = this.truePixelRadius - innerRadius;
        var startAngle = this.startAngle;
        var endAngle = this.endAngle;
        var angle = fitAngleToRange(getAngle(this.point), startAngle, endAngle);
        var xPosition = (angle - startAngle) / (endAngle - startAngle);
        this.xPosition = xPosition;
        this.yPosition = fitToRange((getDistance(this.point) - innerRadius) / radius, 0, 1);
      }
    };
    RadarCursor2.prototype.updatePoint = function(point) {
    };
    RadarCursor2.prototype.handleXTooltipPosition = function(event) {
      if (this.xAxis.cursorTooltipEnabled) {
        var tooltip = this.xAxis.tooltip;
        this.updateLineX(svgPointToSprite({ x: tooltip.pixelX, y: tooltip.pixelY }, this));
      }
    };
    RadarCursor2.prototype.handleYTooltipPosition = function(event) {
      if (this.yAxis.cursorTooltipEnabled) {
        var tooltip = this.yAxis.tooltip;
        this.updateLineY(svgPointToSprite({ x: tooltip.pixelX, y: tooltip.pixelY }, this));
      }
    };
    RadarCursor2.prototype.updateLinePositions = function(point) {
    };
    RadarCursor2.prototype.getRanges = function() {
      var downPoint = this.downPoint;
      if (downPoint) {
        var upPoint = this.upPoint;
        var chart = this.chart;
        if (chart) {
          var radius = this.pixelRadius;
          var startAngle = this.startAngle;
          var endAngle = this.endAngle;
          var downAngle = fitAngleToRange(getAngle(downPoint), this.startAngle, this.endAngle);
          var upAngle = fitAngleToRange(getAngle(upPoint), this.startAngle, this.endAngle);
          var downRadius = fitToRange(getDistance(downPoint), 0, radius);
          var upRadius = fitToRange(getDistance(upPoint), 0, radius);
          var startX = 0;
          var endX = 1;
          var startY = 0;
          var endY = 1;
          var behavior = this.behavior;
          if (behavior == "zoomX" || behavior == "selectX" || behavior == "zoomXY" || behavior == "selectXY") {
            var arc2 = endAngle - startAngle;
            startX = round((downAngle - startAngle) / arc2, 5);
            endX = round((upAngle - startAngle) / arc2, 5);
          }
          if (behavior == "zoomY" || behavior == "selectY" || behavior == "zoomXY" || behavior == "selectXY") {
            startY = round(downRadius / radius, 5);
            endY = round(upRadius / radius, 5);
          }
          this.xRange = { start: Math.min(startX, endX), end: Math.max(startX, endX) };
          this.yRange = { start: Math.min(startY, endY), end: Math.max(startY, endY) };
          if (this.behavior == "selectX" || this.behavior == "selectY" || this.behavior == "selectXY") {
          } else {
            this.selection.hide();
          }
        }
      }
    };
    RadarCursor2.prototype.updateSize = function() {
    };
    Object.defineProperty(RadarCursor2.prototype, "radius", {
      /**
       * @return Outer radius
       */
      get: function() {
        return this.getPropertyValue("radius");
      },
      /**
       * Outer radius of the cursor's circular line.
       * Absolute (px) or relative ([[Percent]]).
       *
       * @param value  Outer radius
       */
      set: function(value) {
        this.setPercentProperty("radius", value, false, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RadarCursor2.prototype, "pixelRadius", {
      /**
       * Outer radius of the circular line in pixels.
       *
       * @return Outer radius (px)
       * @readonly
       */
      get: function() {
        return relativeRadiusToValue(this.radius, this.truePixelRadius);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RadarCursor2.prototype, "truePixelRadius", {
      /**
       * [truePixelRadius description]
       *
       * @todo Description
       * @return Outer radius (px)
       * @readonly
       */
      get: function() {
        return relativeToValue(percent(100), min(this.innerWidth / 2, this.innerHeight / 2));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RadarCursor2.prototype, "innerRadius", {
      /**
       * @return Inner radius
       */
      get: function() {
        return this.getPropertyValue("innerRadius");
      },
      /**
       * Inner radius of the cursor's circular line.
       * Absolute (px) or relative ([[Percent]]).
       *
       * @param value  Inner radius
       */
      set: function(value) {
        this.setPercentProperty("innerRadius", value, false, false, 10, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RadarCursor2.prototype, "pixelInnerRadius", {
      /**
       * Inner radius of the circular line in pixels.
       *
       * @return Inner radius (px)
       * @readonly
       */
      get: function() {
        var innerRadius = this.innerRadius;
        if (innerRadius instanceof Percent) {
          innerRadius = percent(100 * innerRadius.value * this.chart.innerRadiusModifyer);
        }
        return relativeRadiusToValue(innerRadius, this.truePixelRadius) || 0;
      },
      enumerable: true,
      configurable: true
    });
    RadarCursor2.prototype.fixPoint = function(point) {
      return point;
    };
    return RadarCursor2;
  }(XYCursor)
);
registry.registeredClasses["RadarCursor"] = RadarCursor;
export {
  Axis,
  AxisBreak,
  AxisBullet,
  AxisDataItem,
  AxisFill,
  AxisFillCircular,
  AxisLabel,
  AxisLabelCircular,
  AxisLine,
  AxisRenderer,
  AxisRendererCircular,
  AxisRendererRadial,
  AxisRendererX,
  AxisRendererX3D,
  AxisRendererY,
  AxisRendererY3D,
  AxisTick,
  Bullet,
  Candlestick,
  CandlestickSeries,
  CandlestickSeriesDataItem,
  CategoryAxis,
  CategoryAxisBreak,
  CategoryAxisDataItem,
  Chart,
  ChartDataItem,
  ChordDiagram,
  ChordDiagramDataItem,
  ChordLink,
  ChordNode,
  CircleBullet,
  ClockHand,
  Column,
  Column3D,
  ColumnSeries,
  ColumnSeries3D,
  ColumnSeries3DDataItem,
  ColumnSeriesDataItem,
  ConeColumn,
  ConeSeries,
  ConeSeriesDataItem,
  Cursor,
  CurvedColumn,
  CurvedColumnSeries,
  CurvedColumnSeriesDataItem,
  DateAxis,
  DateAxisBreak,
  DateAxisDataItem,
  DurationAxis,
  DurationAxisDataItem,
  ErrorBullet,
  FlowDiagram,
  FlowDiagramDataItem,
  FlowDiagramLink,
  FlowDiagramNode,
  FunnelSeries,
  FunnelSeriesDataItem,
  FunnelSlice,
  GaugeChart,
  GaugeChartDataItem,
  Grid,
  GridCircular,
  HeatLegend,
  LabelBullet,
  Legend,
  LegendDataItem,
  LegendSettings,
  LineSeries,
  LineSeriesDataItem,
  LineSeriesSegment,
  NavigationBar,
  NavigationBarDataItem,
  OHLC,
  OHLCSeries,
  OHLCSeriesDataItem,
  PictorialStackedSeries,
  PictorialStackedSeriesDataItem,
  PieChart,
  PieChart3D,
  PieChart3DDataItem,
  PieChartDataItem,
  PieSeries,
  PieSeries3D,
  PieSeries3DDataItem,
  PieSeriesDataItem,
  PieTick,
  PyramidSeries,
  PyramidSeriesDataItem,
  RadarChart,
  RadarChartDataItem,
  RadarColumn,
  RadarColumnSeries,
  RadarColumnSeriesDataItem,
  RadarCursor,
  RadarSeries,
  RadarSeriesDataItem,
  SankeyDiagram,
  SankeyDiagramDataItem,
  SankeyLink,
  SankeyNode,
  SerialChart,
  SerialChartDataItem,
  Series,
  SeriesDataItem,
  SlicedChart,
  SlicedChartDataItem,
  StepLineSeries,
  StepLineSeriesDataItem,
  Tick,
  TreeMap,
  TreeMapDataItem,
  TreeMapSeries,
  TreeMapSeriesDataItem,
  ValueAxis,
  ValueAxisBreak,
  ValueAxisDataItem,
  XYChart,
  XYChart3D,
  XYChart3DDataItem,
  XYChartDataItem,
  XYChartScrollbar,
  XYCursor,
  XYSeries,
  XYSeriesDataItem
};
//# sourceMappingURL=@amcharts_amcharts4_charts.js.map
